<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DeferredShadingPBRTest</title>
</head>
<body>
<div style="width: 100%;height: 100%;position:fixed;left: 0px;top: 0px;">
    <canvas id="canvas" style="position:absolute;left: 0px;top: 0px;background-color: aliceblue" tabindex="0"></canvas>
</div>
<script src="./../dat.gui.min.js"></script>
<script type="module">
    import Scene from "../../src/Core/Scene/Scene.js";
    import RenderEngine from "../../src/Core/RenderEngine.js";
    import Node from "../../src/Core/Node/Node.js";
    import Material from "../../src/Core/Material/Material.js";
    import Vector3 from "../../src/Core/Math3d/Vector3.js";
    import MaterialDef from "../../src/Core/Material/MaterialDef.js";
    import Box from "../../src/Core/Node/Shape/Box.js";
    import Vec4Vars from "../../src/Core/WebGL/Vars/Vec4Vars.js";
    import FirstPersonController from "../../src/Core/InputControl/FirstPersonController.js";
    import Texture2DVars from "../../src/Core/WebGL/Vars/Texture2DVars.js";
    import Vector4 from "../../src/Core/Math3d/Vector4.js";
    import FloatVars from "../../src/Core/WebGL/Vars/FloatVars.js";
    import DirectionalLight from "../../src/Core/Light/DirectionalLight.js";
    import SceneBrowsingController from "../../src/Core/InputControl/SceneBrowsingController.js";
    import OBJLoader from "../../src/Supp/OBJLoader.js";
    import PointLight from "../../src/Core/Light/PointLight.js";
    import Stats from "../stats.min.js";

    // 案例内容
    import Ext from "../Ext.js";
    import RadianceLoader from "../../src/Supp/RadianceLoader.js";
    import SkyBox from "../../src/Core/Node/Sky/SkyBox.js";
    import GLTFLoader from "../../src/Supp/GLTFLoader.js";
    import BoolVars from "../../src/Core/WebGL/Vars/BoolVars.js";
    import GIProbe from "../../src/Core/Light/GIProbe.js";
    import ProbeTools from "../../src/Core/Util/ProbeTools.js";

    let ext = new Ext();
    ext.show('  这个案例演示了Teort中的基于Deferred Pipeline策略的光照，该场景包含1000个动态点光源和一个定向光，默认下，DeferredLightingDef材质使用SinglePass方案，这个案例演示了优先启用MultiPassDeferred Technology，该技术使用MultiPass渲染模式，你可以切换这两种渲染模式，以查看性能区别。', {lineheight:50});


    let scene = new Scene({cavnas:document.getElementById('canvas')});
    scene.setAmbientLightColor(1.0, 1.0, 1.0, 1.0);
    // 设置默认启用的技术方案为MultiPassDeferred
    // scene.getRender().setPriorityTechnology('MultiPassDeferred');

    let mainCamera = scene.getComponent('mainCamera');
    mainCamera.lookAt(new Vector3(0, 0, 10), new Vector3(0, 0, 0), new Vector3(0, 1, 0));
    let rootNode = new Node(scene, {id:'rootNode'});

    // 环境纹理加载完再开始创建创建
    let radianceLoader = new RadianceLoader();
    radianceLoader.loadHDR('./../Assets/Textures/hdr/env1.hdr', imageData=>{
        // 创建一个sky
        let sky = new SkyBox(scene, {id:'sky'});
        // 使用cubeMap作为天空盒材质
        let envMap = new Texture2DVars(scene);
        envMap.setPreloadColor(scene, new Vector4(0.5, 0.5, 0.5, 1.0));
        envMap.setWrap(scene, Texture2DVars.S_WRAPS.S_CLAMP_TO_EDGE, Texture2DVars.S_WRAPS.S_CLAMP_TO_EDGE);
        envMap.setFilter(scene, Texture2DVars.S_FILTERS.S_LINEAR, Texture2DVars.S_FILTERS.S_LINEAR);
        envMap.setImage(scene, imageData, {rgbe:true});
        sky.getMaterial().setParam('envMap', envMap);
        sky.getMaterial().setParam('useEnvMap', new BoolVars().valueOf(true));
        sky.getMaterial().setParam('useHDR', new BoolVars().valueOf(true));

        scene.setSky(sky);

        let gltfLoader = new GLTFLoader();
        gltfLoader.setAssetsPath("../../src/Core/Assets/MaterialDef/", 'PrincipledDeferredLightingDef');
        gltfLoader.load(scene, './../Assets/Models/GLTF/Sponza/Sponza.gltf', modelNode=>{
            rootNode.addChildren(modelNode);
            let sceneControl = new SceneBrowsingController(scene, {id:'sceneControl'});
            sceneControl.lookScene(rootNode);
            sceneControl.setTargetDistance(1);

            let aabb = modelNode.getBoundingVolume();
            let dx = aabb.getXHalf() * 2;
            let dy = aabb.getYHalf() * 2;
            let dz = aabb.getZHalf() * 2;
            let center = aabb.getCenter();
            let lx = center._m_X - dx * 0.5;
            let ly = center._m_Y - dy * 0.5;
            let lz = center._m_Z - dz * 0.5;
            let ps = [];
            for(let i = 0;i < 250;i++){
                let pointLight = new PointLight(scene, {id:'pointLight' + i});
                pointLight.setRadius(3);
                pointLight.setColorRGBA(Math.random() * 1.0, Math.random() * 1.0, Math.random() * 1.0, 1.0);
                pointLight.setPositionXYZ(Math.random() * dx + lx, Math.random() * dy + ly, Math.random() * dz + lz);
                pointLight.dx = 1.0;
                pointLight.dy = 1.0;
                pointLight.dz = 1.0;
                rootNode.addChildren(pointLight);
                ps.push(pointLight);
            }

            // 使用dat gui
            let gui = new dat.GUI();
            var settings = {
                renderTechnology: 'MultiPassDeferred',
                directionalLight: true,
                pointLights: true,
                pointLightAnim: true
            };
            gui.add(settings, 'renderTechnology', ['MultiPassDeferred', 'Default']).name('渲染技术').onChange(function(value) {
                modelNode.traverse((node)=>{
                    if(node.isDrawable()){
                        // SinglePass是默认技术，所以传递""即可
                        node.getMaterial().selectTechnology(value == 'Default' ? "" : value);
                    }
                });
            });
            gui.add(settings, 'directionalLight').onChange(swi=>{
                if(swi){
                    dirLight.enable();
                }
                else{
                    dirLight.disable();
                }
            });
            gui.add(settings, 'pointLights').onChange(swi=>{
                ps.forEach(p=>{
                    if(swi){
                        p.enable();
                    }
                    else{
                        p.disable();
                    }
                });
            });
            gui.add(settings, 'pointLightAnim');
            gui.width = 300;
            gui.open();


            // 使用stats.js统计fps
            let stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);
            scene.on('update', (exTime)=>{
                stats.update();
                if(settings.pointLightAnim){
                    ps.forEach(p=>{
                        let pos = p.getPosition();
                        pos.addInXYZ(p.dx * exTime, 0, 0);
                        if(pos._m_X >= dx && p.dx > 0.0){
                            p.dx *= -1.0;
                        }
                        else if(pos._m_X <= lx && p.dx < 0.0){
                            p.dx *= -1.0;
                        }
                        if(pos._m_Y >= dy && p.dy > 0.0){
                            p.dy *= -1.0;
                        }
                        else if(pos._m_Y <= ly && p.dy < 0.0){
                            p.dy *= -1.0;
                        }
                        if(pos._m_Z >= dz && p.dz > 0.0){
                            p.dz *= -1.0;
                        }
                        else if(pos._m_Z <= lz && p.dz < 0.0){
                            p.dz *= -1.0;
                        }
                        p.updateBounding();
                    });
                }
            });
        }, {batch:true});

        let dirLight = new DirectionalLight(scene, {id:'dirLight'});
        dirLight.setDirectionXYZ(-1, -1, 1);
        dirLight.setColorRGBA(1.0, 1.0, 1.0, 1.0);
        rootNode.addChildren(dirLight);

        let giProbe = new GIProbe(scene, {id:'giProbe'});
        giProbe.setRadius(20);
        giProbe.setPositionFromXYZ(0, 5, 0);
        let envCapture = ProbeTools.bakeGIProbe(scene, giProbe, {resolute:128});
    });


    let renderEngine = new RenderEngine();
    scene.addSceneNode(rootNode);
    renderEngine.addScene(scene);
    renderEngine.launch();
</script>
</body>
</html>
