(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Try3d"] = factory();
	else
		root["Try3d"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 4755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ActionClip = /*#__PURE__*/function () {
  function ActionClip(pathName) {
    _classCallCheck(this, ActionClip);

    // 轨迹路径名称(定义当前轨迹通道)
    this._m_PathName = pathName; // 关键帧数组

    this._m_Keyframes = []; // 剪辑轨迹通道

    this._m_ActionTrack = null;
  }
  /**
   * 返回剪辑长度。<br/>
   * @return {Number}
   */


  _createClass(ActionClip, [{
    key: "getLength",
    value: function getLength() {
      var length = -Number.MAX_VALUE;

      this._m_Keyframes.forEach(function (keyframe) {
        length = Math.max(length, keyframe.getTime());
      });

      return length == -Number.MAX_VALUE ? 0 : length;
    }
    /**
     * 添加关键帧。<br/>
     * @param {AnimKeyframe}[keyframe]
     */

  }, {
    key: "addKeyframe",
    value: function addKeyframe(keyframe) {
      this._m_Keyframes.push(keyframe);
    }
    /**
     * 返回轨迹路径。<br/>
     * @return {String}
     */

  }, {
    key: "getPathName",
    value: function getPathName() {
      return this._m_PathName;
    }
    /**
     * 设置动作轨迹。<br/>
     * @param {TrackBinding}[track]
     */

  }, {
    key: "setActionTrack",
    value: function setActionTrack(track) {
      this._m_ActionTrack = track;
    }
    /**
     * 更新动作。<br/>
     * @param {Number}[time 当前时间]
     */

  }, {
    key: "update",
    value: function update(time) {
      var keyFrameId = 0;
      var keyFrame = null;
      var keyFrames = this._m_Keyframes.length;

      while (keyFrameId < keyFrames && this._m_Keyframes[keyFrameId].getTime() < time) {
        keyFrameId++;
      }

      if (keyFrameId == 0) {
        keyFrame = this._m_Keyframes[keyFrameId];

        this._m_ActionTrack.setValue(keyFrame.getValue());
      } else if (keyFrameId == keyFrames) {
        keyFrameId -= 1;
        keyFrame = this._m_Keyframes[keyFrameId];

        this._m_ActionTrack.setValue(keyFrame.getValue());
      } else {
        var left = this._m_Keyframes[keyFrameId - 1];
        var right = this._m_Keyframes[keyFrameId];
        var k = 1.0 / (right.getTime() - left.getTime());
        keyFrame = left.interpolation(left.getValue(), right.getValue(), (time - left.getTime()) * k);

        this._m_ActionTrack.setValue(keyFrame);
      }
    }
  }]);

  return ActionClip;
}();

exports["default"] = ActionClip;

/***/ }),

/***/ 479:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var AnimationAction = /*#__PURE__*/function () {
  function AnimationAction(name) {
    _classCallCheck(this, AnimationAction);

    // 动画名称
    this._m_Name = name; // 动画进度

    this._m_Time = 0; // 动画长度

    this._m_TimeLength = 0; // 播放模式

    this._m_Mode = AnimationAction.S_LOOP;
    this._m_TimeMode = 1; // 处理器

    this._m_Processor = null; // 轨迹合成器

    this._m_TrackMixer = null; // 动画状态

    this._m_State = AnimationAction.S_STOP;
  }

  _createClass(AnimationAction, [{
    key: "setAnimationMode",
    value: function setAnimationMode(mode) {}
    /**
     * 设置处理器，内部调用。<br/>
     * @param {AnimationProcessor}[processor]
     * @private
     */

  }, {
    key: "_setProcessor",
    value: function _setProcessor(processor) {
      this._m_Processor = processor;
    }
    /**
     * 返回动画名称。<br/>
     * @return {String}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
    /**
     * 返回动画长度。<br/>
     * @return {Number}[秒]
     */

  }, {
    key: "getAnimationLength",
    value: function getAnimationLength() {
      return this._m_TimeLength;
    }
    /**
     * 设置轨迹合成器。<br/>
     * @param {TrackMixer}[trackMixer]
     */

  }, {
    key: "setTrackMixer",
    value: function setTrackMixer(trackMixer) {
      var _this = this;

      this._m_TrackMixer = trackMixer; // 更新动画长度

      this._m_Time = 0;
      this._m_TimeLength = -Number.MAX_VALUE;
      trackMixer.getClips().forEach(function (clip) {
        _this._m_TimeLength = Math.max(clip.getLength(), _this._m_TimeLength);
      });

      if (this._m_TimeLength == -Number.MAX_VALUE) {
        this._m_TimeLength = 0;
      }

      _Log.default.log('[[' + this.getName() + ']]动画时长:' + this._m_TimeLength + "s");
    }
    /**
     * 播放当前动画。<br/>
     */

  }, {
    key: "play",
    value: function play() {
      if (this._m_State == AnimationAction.S_PLAY) {
        return;
      } // 激活动画


      this._m_Processor._activeAnimationAction(this);

      this._m_State = AnimationAction.S_PLAY;
    }
    /**
     * 暂停当前动画。<br/>
     */

  }, {
    key: "pause",
    value: function pause() {
      if (this._m_State == AnimationAction.S_PAUSE) {
        return;
      } // 只有播放过的动画才需要禁用


      if (this._m_State == AnimationAction.S_PLAY) this._m_Processor._disableAnimationAction(this);
      this._m_State = AnimationAction.S_PAUSE;
    }
    /**
     * 停止当前动画。<br/>
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._m_State == AnimationAction.S_STOP) {
        return;
      } // 只有播放过的动画才需要禁用


      if (this._m_State == AnimationAction.S_PLAY) this._m_Processor._disableAnimationAction(this);
      this._m_State = AnimationAction.S_STOP; // 重置时间

      this._m_Time = 0;
    }
    /**
     * 更新动画。<br/>
     * @param {Number}[exTime 经过时间毫秒]
     */

  }, {
    key: "update",
    value: function update(exTime) {
      if (this._m_Time >= this._m_TimeLength) {
        if (this._m_Mode == AnimationAction.S_DONT_LOOP) {
          this._m_TimeMode = 1;
          return;
        }

        if (this._m_Mode == AnimationAction.S_LOOP) {
          this._m_Time = 0;
          this._m_TimeMode = 1;
        }

        if (this._m_Mode == AnimationAction.S_BACK_AND_FORTH) {
          this._m_Time = this._m_TimeLength;
          this._m_TimeMode = -1;
        }
      }

      this._m_Time += exTime * this._m_TimeMode;

      this._m_TrackMixer.update(this._m_Time);
    }
  }]);

  return AnimationAction;
}();

exports["default"] = AnimationAction;

_defineProperty(AnimationAction, "S_LOOP", 0x001);

_defineProperty(AnimationAction, "S_DONT_LOOP", 0x002);

_defineProperty(AnimationAction, "S_BACK_AND_FORTH", 0x003);

_defineProperty(AnimationAction, "S_PLAY", 1);

_defineProperty(AnimationAction, "S_PAUSE", 1 << 1);

_defineProperty(AnimationAction, "S_STOP", 1 << 2);

/***/ }),

/***/ 1648:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * AnimationProcessor。<br/>
 * 作为提供轨迹动画，变形动画和Skin动画的控制器。<br/>
 * @author Kkk
 * @date 2021年3月8日2点28分
 * @lastdate 2021年3月13日22点00分
 */
var AnimationProcessor = /*#__PURE__*/function (_Component) {
  _inherits(AnimationProcessor, _Component);

  var _super = _createSuper(AnimationProcessor);

  function AnimationProcessor(owner, cfg) {
    var _this;

    _classCallCheck(this, AnimationProcessor);

    _this = _super.call(this, owner, cfg); // 所有动画

    _this._m_AnimationActions = [];
    _this._m_AnimationActionMaps = {}; // 激活的动画

    _this._m_ActiveAnimationActions = []; // 这里监听场景的update而不是组件的update()事件

    var count = -1;

    _this._m_Scene.on('update', function (exTime) {
      // Log.log('更新AnimationProcessor!');
      count = _this._m_ActiveAnimationActions.length;

      if (count > 0) {
        for (var i = 0; i < count; i++) {
          // 播放所有动画
          _this._m_ActiveAnimationActions[i].update(exTime);
        }
      }
    });

    return _this;
  }
  /**
   * 激活一个动画,由内部调用。<br/>
   * @param {AnimationAction}[activeAnimation]
   * @private
   */


  _createClass(AnimationProcessor, [{
    key: "getType",
    value: function getType() {
      return 'AnimationProcessor';
    }
  }, {
    key: "_activeAnimationAction",
    value: function _activeAnimationAction(activeAnimation) {
      this._m_ActiveAnimationActions.push(activeAnimation);
    }
    /**
     * 禁用一个动画,由内部调用。<br/>
     * @param {AnimationAction}[disableAnimation]
     * @private
     */

  }, {
    key: "_disableAnimationAction",
    value: function _disableAnimationAction(disableAnimation) {
      var i = this._m_ActiveAnimationActions.indexOf(disableAnimation);

      if (i > -1) {
        this._m_ActiveAnimationActions.splice(i, 1);
      }
    }
    /**
     * 添加一个动画。<br/>
     * @param {AnimationAction}[animationAction]
     */

  }, {
    key: "addAnimationAction",
    value: function addAnimationAction(animationAction) {
      if (!this._m_AnimationActionMaps[animationAction.getName()]) {
        this._m_AnimationActionMaps[animationAction.getName()] = animationAction;

        this._m_AnimationActions.push(animationAction);

        animationAction._setProcessor(this);
      }
    }
    /**
     * 返回一个动画。<br/>
     * @param {String}[name]
     * @return {AnimationAction/null}
     */

  }, {
    key: "getAnimationAction",
    value: function getAnimationAction(name) {
      return this._m_AnimationActionMaps[name];
    }
    /**
     * 返回指定索引的动画。<br/>
     * @param {Number}[i]
     * @return {AnimationAction}
     */

  }, {
    key: "getAnimationActionAtIndex",
    value: function getAnimationActionAtIndex(i) {
      if (i >= this._m_AnimationActions.length) {
        return null;
      }

      return this._m_AnimationActions[i];
    }
    /**
     * 返回所有动画。<br/>
     * @return {AnimationAction[]}
     */

  }, {
    key: "getAnimationActions",
    value: function getAnimationActions() {
      return this._m_AnimationActions;
    }
  }]);

  return AnimationProcessor;
}(_Component2.default);

exports["default"] = AnimationProcessor;

/***/ }),

/***/ 9586:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Node2 = _interopRequireDefault(__webpack_require__(2949));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Bone。<br/>
 * 表示骨骼的Node。<br/>
 * @author Kkk
 * @date 2021年3月8日15点58分
 * @date 2021年3月13日22点01分
 */
var Bone = /*#__PURE__*/function (_Node) {
  _inherits(Bone, _Node);

  var _super = _createSuper(Bone);

  function Bone(owner, cfg) {
    var _this;

    _classCallCheck(this, Bone);

    _this = _super.call(this, owner, cfg);
    _this._m_Bind = null;
    return _this;
  }
  /**
   * 绑定Joint。<br/>
   * @param {Joint}[b]
   */


  _createClass(Bone, [{
    key: "getType",
    value: function getType() {
      return 'Bone';
    }
  }, {
    key: "bind",
    value: function bind(b) {
      this._m_Bind = b;
    }
    /**
     * 返回绑定Joint。<br/>
     * @return {Joint}
     */

  }, {
    key: "getBind",
    value: function getBind() {
      return this._m_Bind;
    }
    /**
     * 更新LocalMatrix。<br/>
     * @private
     */

  }, {
    key: "_updateLocalMatrix",
    value: function _updateLocalMatrix() {
      _get(_getPrototypeOf(Bone.prototype), "_updateLocalMatrix", this).call(this);

      if (this._m_Bind) {
        this._m_Bind.actived();
      }
    }
  }]);

  return Bone;
}(_Node2.default);

exports["default"] = Bone;

/***/ }),

/***/ 6458:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * AnimKeyframe。<br/>
 * 动画关键帧，所有关键帧类型的根类。<br/>
 * @author Kkk
 * @date 2021年3月8日15点59分
 */
var AnimKeyframe = /*#__PURE__*/function () {
  function AnimKeyframe(time) {
    _classCallCheck(this, AnimKeyframe);

    // 关键帧时间
    this._m_Time = time; // 当前关键帧值

    this._m_Value = null; // 插值方式

    this._m_InterpolationMode = AnimKeyframe.S_INTERPOLATION_MODE[AnimKeyframe.S_LINEAR]; // 插值函数

    this.interpolation = null;
  }
  /**
   * 返回关键帧时间。<br/>
   * @return {Number}
   */


  _createClass(AnimKeyframe, [{
    key: "getTime",
    value: function getTime() {
      return this._m_Time;
    }
    /**
     * 返回关键帧值。<br/>
     * @return {Object}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this._m_Value;
    }
    /**
     * 设置插值方式。<br/>
     * @param {Number}[interpolationMode]
     */

  }, {
    key: "setInterpolationMode",
    value: function setInterpolationMode(interpolationMode) {
      this._m_InterpolationMode = AnimKeyframe.S_INTERPOLATION_MODE[interpolationMode];
    }
  }]);

  return AnimKeyframe;
}();

exports["default"] = AnimKeyframe;

_defineProperty(AnimKeyframe, "S_INTERPOLATION_MODE", {
  'LINEAR': 0
});

_defineProperty(AnimKeyframe, "S_LINEAR", 'LINEAR');

/***/ }),

/***/ 7868:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector3Keyframe = _interopRequireDefault(__webpack_require__(6454));

var _QuaternionKeyframe = _interopRequireDefault(__webpack_require__(8081));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * AnimKeyframeEnum。<br/>
 * 轨迹通道。<br/>
 * @author Kkk
 * @date 2021年3月11日12点25分
 */
var AnimKeyframeEnum = function AnimKeyframeEnum() {
  _classCallCheck(this, AnimKeyframeEnum);
};

exports["default"] = AnimKeyframeEnum;

_defineProperty(AnimKeyframeEnum, "S_KEY_FRAME", {
  'scale': _Vector3Keyframe.default,
  'rotation': _QuaternionKeyframe.default,
  'translation': _Vector3Keyframe.default
});

/***/ }),

/***/ 8081:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _AnimKeyframe2 = _interopRequireDefault(__webpack_require__(6458));

var _Quaternion = _interopRequireDefault(__webpack_require__(453));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * QuaternionKeyframe。<br/>
 * 四元数关键帧用于表达需要球面插值的旋转关键帧动画。<br/>
 * @author Kkk
 * @date 2021年3月8日16点05分
 */
var QuaternionKeyframe = /*#__PURE__*/function (_AnimKeyframe) {
  _inherits(QuaternionKeyframe, _AnimKeyframe);

  var _super = _createSuper(QuaternionKeyframe);

  function QuaternionKeyframe(time, x, y, z, w) {
    var _this;

    _classCallCheck(this, QuaternionKeyframe);

    _this = _super.call(this, time);
    _this._m_Value = new _Quaternion.default(x, y, z, w);
    return _this;
  }

  _createClass(QuaternionKeyframe, [{
    key: "setInterpolationMode",
    value: function setInterpolationMode(interpolationMode) {
      _get(_getPrototypeOf(QuaternionKeyframe.prototype), "setInterpolationMode", this).call(this, interpolationMode); // 根据具体插值模式修改插值计算函数
      // Log.log('interpolationMode:' + interpolationMode);


      if (interpolationMode == _AnimKeyframe2.default.S_LINEAR) {
        this.interpolation = _Quaternion.default.slerp;
      }
    }
  }]);

  return QuaternionKeyframe;
}(_AnimKeyframe2.default);

exports["default"] = QuaternionKeyframe;

/***/ }),

/***/ 6454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _AnimKeyframe2 = _interopRequireDefault(__webpack_require__(6458));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Vector3Keyframe。<br/>
 * 用于定义3维数值变换的关键帧。<br/>
 * @author Kkk
 * @date 2021年3月8日16点02分
 */
var Vector3Keyframe = /*#__PURE__*/function (_AnimKeyframe) {
  _inherits(Vector3Keyframe, _AnimKeyframe);

  var _super = _createSuper(Vector3Keyframe);

  function Vector3Keyframe(time, x, y, z) {
    var _this;

    _classCallCheck(this, Vector3Keyframe);

    _this = _super.call(this, time);
    _this._m_Value = new _Vector.default(x, y, z);
    return _this;
  }

  _createClass(Vector3Keyframe, [{
    key: "setInterpolationMode",
    value: function setInterpolationMode(interpolationMode) {
      _get(_getPrototypeOf(Vector3Keyframe.prototype), "setInterpolationMode", this).call(this, interpolationMode); // 根据具体插值模式修改插值计算函数
      // Log.log('interpolationMode:' + interpolationMode);


      if (interpolationMode == _AnimKeyframe2.default.S_LINEAR) {
        this.interpolation = _Vector.default.inter;
      }
    }
  }]);

  return Vector3Keyframe;
}(_AnimKeyframe2.default);

exports["default"] = Vector3Keyframe;

/***/ }),

/***/ 2414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _AnimKeyframe2 = _interopRequireDefault(__webpack_require__(6458));

var _Vector = _interopRequireDefault(__webpack_require__(7141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Vector4Keyframe。<br/>
 * 用于定义4维数值变换的关键帧。<br/>
 * @author Kkk
 * @date 2021年3月8日16点02分
 */
var Vector4Keyframe = /*#__PURE__*/function (_AnimKeyframe) {
  _inherits(Vector4Keyframe, _AnimKeyframe);

  var _super = _createSuper(Vector4Keyframe);

  function Vector4Keyframe(time, x, y, z, w) {
    var _this;

    _classCallCheck(this, Vector4Keyframe);

    _this = _super.call(this, time);
    _this._m_Value = new _Vector.default(x, y, z, w);
    return _this;
  }

  _createClass(Vector4Keyframe, [{
    key: "setInterpolationMode",
    value: function setInterpolationMode(interpolationMode) {
      _get(_getPrototypeOf(Vector4Keyframe.prototype), "setInterpolationMode", this).call(this, interpolationMode); // 根据具体插值模式修改插值计算函数
      // Log.log('interpolationMode:' + interpolationMode);


      if (interpolationMode == _AnimKeyframe2.default.S_LINEAR) {
        this.interpolation = _Vector.default.inter;
      }
    }
  }]);

  return Vector4Keyframe;
}(_AnimKeyframe2.default);

exports["default"] = Vector4Keyframe;

/***/ }),

/***/ 1245:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TrackBinding = /*#__PURE__*/function () {
  function TrackBinding(node, property) {
    _classCallCheck(this, TrackBinding);

    // 绑定的对象
    this._m_Node = node;

    if (!this._m_Node) {
      _Log.default.warn('node为null:');
    }

    this.setValue = null;
    this.getValue = null; // 对绑定对象的property进行轨迹操作

    switch (property) {
      case 'rotation':
        this.setValue = function (value) {
          // Log.log(value.toString());
          node.setLocalRotation(value);
        };

        this.getValue = function () {
          return node.getLocalRotation();
        };

        break;

      case 'translation':
        this.setValue = function (value) {
          node.setLocalTranslation(value);
        };

        this.getValue = function () {
          return node.getLocalTranslation();
        };

        break;

      case 'scale':
        this.setValue = function (value) {
          node.setLocalScale(value);
        };

        this.getValue = function () {
          return node.getLocalScale();
        };

        break;
    }
  }
  /**
   * 创建轨迹通道绑定。<br/>
   * @param {Object}[obj]
   * @param {String}[track]
   * @return {TrackBinding}
   */


  _createClass(TrackBinding, null, [{
    key: "bind",
    value: function bind(obj, track) {
      return new TrackBinding(obj, track);
    }
    /**
     * 创建轨迹。<br/>
     * @param {ActionClip}[actionClip]
     * @param {Object}[obj]
     */

  }, {
    key: "createTrack",
    value: function createTrack(actionClip, obj) {
      actionClip.setActionTrack(TrackBinding.bind(obj, actionClip.getPathName()));
    }
  }]);

  return TrackBinding;
}();

exports["default"] = TrackBinding;

/***/ }),

/***/ 7938:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * TrackMixer。<br/>
 * 将多个轨迹合成，通常一个Mixer包含多个ActionClip，在一段动画时间中插补关键帧得到对应的值并进行合成，最终更新到指定轨迹上。<br/>
 * @author Kkk
 * @date 2021年3月13日21点58分
 * @lastdata 2021年3月13日21点59分
 */
var TrackMixer = /*#__PURE__*/function () {
  function TrackMixer() {
    _classCallCheck(this, TrackMixer);

    // 从当前时间插值所有ActionClip的关键帧
    // 然后将更新后的ActionClip的各个Track绑定应用到指定的Node.property上。
    // 轨迹数组
    this._m_Clips = [];
  }
  /**
   * 添加剪辑。<br/>
   * @param {ActionClip}[clip]
   */


  _createClass(TrackMixer, [{
    key: "addClip",
    value: function addClip(clip) {
      this._m_Clips.push(clip);
    }
    /**
     * 返回指定动作剪辑。<br/>
     * @param {Number}[index]
     * @return {ActionClip}
     */

  }, {
    key: "getClip",
    value: function getClip(index) {
      return this._m_Clips[index];
    }
    /**
     * 返回所有动作剪辑。<br/>
     * @return {ActionClip[]}
     */

  }, {
    key: "getClips",
    value: function getClips() {
      return this._m_Clips;
    }
    /**
     * 更新剪辑。<br/>
     * @param {Number}[time 当前时间]
     */

  }, {
    key: "update",
    value: function update(time) {
      // 混合剪辑
      this._m_Clips.forEach(function (clip) {
        clip.update(time);
      });
    }
  }]);

  return TrackMixer;
}();

exports["default"] = TrackMixer;

/***/ }),

/***/ 8649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Quaternion = _interopRequireDefault(__webpack_require__(453));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Joint = /*#__PURE__*/function () {
  function Joint(id, num) {
    _classCallCheck(this, Joint);

    // 持有骨架
    this._m_OwnerSkeleton = null; // 骨骼节点

    this._m_Bone = null;
    this._m_Refs = {}; // 关节Id

    this._m_Id = id; // 关节序号

    this._m_Num = num; // 相对矩阵

    this._m_RelMat4 = new _Matrix.default(); // 关节矩阵

    this._m_JointMat4 = new _Matrix.default(); // 活跃状态

    this._m_IsActive = false;
  }
  /**
   * 激活为活跃关节。<br/>
   */


  _createClass(Joint, [{
    key: "actived",
    value: function actived() {
      if (this._m_IsActive) {
        return;
      }

      this._m_IsActive = true;

      this._m_OwnerSkeleton.addActiveJoint(this);
    }
    /**
     * 关闭活跃状态。<br/>
     */

  }, {
    key: "disable",
    value: function disable() {
      this._m_IsActive = false;
    }
    /**
     * 添加一个Ref。<br/>
     * @param {String}[refId]
     * @param {WebGLUniformLocation}[ref]
     */

  }, {
    key: "addRef",
    value: function addRef(refId, ref) {
      if (this._m_Refs[refId]) {
        if (this._m_Refs[refId] != ref) {
          _Log.default.warn('ref不等于最新ref:' + ref);
        }

        return;
      }

      this._m_Refs[refId] = ref;
    }
    /**
     * 初始化关节。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[refId]
     */

  }, {
    key: "init",
    value: function init(gl, refId) {
      // 为后期一致缓存加载,现在仅是更新调度
      this.update(gl, refId);
    }
    /**
     * 返回关节ID。<br/>
     * @return {Number}
     */

  }, {
    key: "getId",
    value: function getId() {
      return this._m_Id;
    }
    /**
     * 返回关节编号。<br/>
     * @return {Number}
     */

  }, {
    key: "getNum",
    value: function getNum() {
      return this._m_Num;
    }
    /**
     * 设置持有骨架。<br/>
     * @param {Skeleton}[ownerSkeleton]
     */

  }, {
    key: "setOwnerSkeleton",
    value: function setOwnerSkeleton(ownerSkeleton) {
      this._m_OwnerSkeleton = ownerSkeleton;
    }
    /**
     * 链接到骨骼。<br/>
     * @param {Bone}[bone]
     */

  }, {
    key: "link",
    value: function link(bone) {
      if (bone == this._m_Bone) return;
      if (!bone) return;
      this._m_Bone = bone;

      this._m_Bone.bind(this);
    }
    /**
     * 设置关节空间。<br/>
     * @param {Number[]}[array]
     */

  }, {
    key: "setJointSpace",
    value: function setJointSpace(array) {
      this._m_RelMat4.setArray(array);
    }
    /**
     * 返回骨骼矩阵。<br/>
     * @return {Matrix44}
     */

  }, {
    key: "getJointMat4",
    value: function getJointMat4() {
      return this._m_JointMat4;
    }
    /**
     * 更新关节。<br/>
     */

  }, {
    key: "update",
    value: function update(gl, refId) {
      // 保守起见,这里还是检测一下吧(后续可以去掉)
      if (!this._m_Bone) {
        _Log.default.log('joint_' + this.getNum() + ";id:" + this.getId() + "未关联Bone!");

        return;
      }

      _Matrix.default.multiplyMM(this._m_JointMat4, 0, this._m_Bone.getWorldMatrix(), 0, this._m_RelMat4, 0);

      gl.uniformMatrix4fv(this._m_Refs[refId], false, this._m_JointMat4.getBufferData());
    }
  }]);

  return Joint;
}();

exports["default"] = Joint;

/***/ }),

/***/ 1608:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Skeleton = /*#__PURE__*/function () {
  function Skeleton(name) {
    _classCallCheck(this, Skeleton);

    this._m_Name = name;
    this._m_Joints = [];
    this._m_ActiveJoints = [];
    this._m_IsReady = false;
    this._m_Finished = true;
    this._m_OwnerShaders = {};
  }
  /**
   * 初始化骨架。<br/>
   * @param {WebGL}[gl]
   * @param {FrameContext}[frameContext]
   */


  _createClass(Skeleton, [{
    key: "init",
    value: function init(gl, frameContext) {
      if (this._m_IsReady) {
        return;
      }

      this._m_IsReady = true; // 初始化骨骼数据

      this._m_Joints.forEach(function (joint) {
        joint.setRef(frameContext.m_LastSubShader.getRef(gl, _ShaderSource.default.S_JOINTS_SRC + "[" + joint.getNum() + "]"));
        joint.init(gl);
      });
    }
    /**
     * 是否就绪。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isReady",
    value: function isReady() {
      return this._m_IsReady;
    }
    /**
     * 保持关节关联。<br/>
     * @param {WebGL}[gl]
     * @param {FrameContext}[frameContext]
     * @return {Boolean}
     */

  }, {
    key: "owner",
    value: function owner(gl, frameContext) {
      if (this._m_OwnerShaders[frameContext.m_LastSubShader.getSId()]) {
        return true;
      } // 初始化骨骼数据


      this._m_Joints.forEach(function (joint) {
        joint.addRef(frameContext.m_LastSubShader.getSId(), frameContext.m_LastSubShader.getRef(gl, _ShaderSource.default.S_JOINTS_SRC + "[" + joint.getNum() + "]"));
        joint.init(gl, frameContext.m_LastSubShader.getSId());
      });

      this._m_OwnerShaders[frameContext.m_LastSubShader.getSId()] = true;

      _Log.default.log('持有!');

      return true;
    }
    /**
     * 骨架是否完整性，在骨架不完整时将不会渲染与之关联的模型。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isFinished",
    value: function isFinished() {
      return this._m_Finished;
    }
    /**
     * 表示骨架已经完整。<br/>
     */

  }, {
    key: "finished",
    value: function finished() {
      this._m_Finished = true;
    }
    /**
     * 返回活跃关节。<br/>
     * @return {Joint[]}
     */

  }, {
    key: "getActiveJoints",
    value: function getActiveJoints() {
      return this._m_ActiveJoints;
    }
    /**
     * 添加活跃关节。<br/>
     * @param {Joint}[joint]
     */

  }, {
    key: "addActiveJoint",
    value: function addActiveJoint(joint) {
      this._m_ActiveJoints.push(joint);
    }
    /**
     * 设置关节数据。<br/>
     * @param {Joint[]}[joints]
     */

  }, {
    key: "setJoints",
    value: function setJoints(joints) {
      var _this = this;

      this._m_Joints.length = 0;
      joints.forEach(function (joint) {
        _this._m_Joints.push(joint);

        joint.setOwnerSkeleton(_this);
      });
    }
    /**
     * 返回所有关节。<br/>
     * @return {Joint[]}
     */

  }, {
    key: "getJoints",
    value: function getJoints() {
      return this._m_Joints;
    }
    /**
     * 添加一个关节到指定位置。<br/>
     * @param {Number}[index]
     * @param {Joint}[joint]
     */

  }, {
    key: "addJointAtIndex",
    value: function addJointAtIndex(index, joint) {
      this._m_Joints[index] = joint;
      joint.setOwnerSkeleton(this);
    }
    /**
     * 添加一个关节。<br/>
     * @param {Joint}[joint]
     */

  }, {
    key: "addJoint",
    value: function addJoint(joint) {
      this._m_Joints.push(joint);

      joint.setOwnerSkeleton(this);
    }
    /**
     * 更新关节数据。<br/>
     * @param {WebGL}[gl]
     * @param {FrameContext}[frameContext]
     */

  }, {
    key: "updateJoints",
    value: function updateJoints(gl, frameContext) {
      if (this._m_ActiveJoints.length > 0) {
        this._m_ActiveJoints.forEach(function (activeJoint) {
          activeJoint.update(gl, frameContext.m_LastSubShader.getSId());
          activeJoint.disable();
        });

        this._m_ActiveJoints.length = 0;
      }
    }
  }]);

  return Skeleton;
}();

exports["default"] = Skeleton;

/***/ }),

/***/ 6858:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * SkinGeometry。<br/>
 * 蒙皮动画中的皮肤几何定义，与Geometry相比，SkinGeometry定义了它的蒙皮骨骼部分。<br/>
 * @author Kkk
 * @date 2021年3月9日10点59分
 */
var SkinGeometry = /*#__PURE__*/function (_Geometry) {
  _inherits(SkinGeometry, _Geometry);

  var _super = _createSuper(SkinGeometry);

  function SkinGeometry(owner, cfg) {
    var _this;

    _classCallCheck(this, SkinGeometry);

    _this = _super.call(this, owner, cfg);
    _this._m_Skeleton = null;
    return _this;
  }

  _createClass(SkinGeometry, [{
    key: "setSkeleton",
    value: function setSkeleton(skeleton) {
      this._m_Skeleton = skeleton;
    }
  }, {
    key: "draw",
    value: function draw(frameContext) {
      var gl = this._m_Scene.getCanvas().getGLContext(); // 更新骨架


      if (this._m_Skeleton) {
        if (!this._m_Skeleton.isFinished()) {
          return;
        }

        if (!this._m_Skeleton.owner(gl, frameContext)) {
          _Log.default.log('错误持有!');
        }

        this._m_Skeleton.updateJoints(gl, frameContext);
      }

      var contextVars = frameContext.m_LastSubShader.getContextVars();
      var viewMatrix = null,
          projectMatrix = null;

      for (var vN in contextVars) {
        switch (vN) {
          case _ShaderSource.default.S_MODEL_MATRIX_SRC:
            // contextVars[vN].fun(contextVars[vN].loc, false, this.getWorldMatrix().getBufferData());
            gl[contextVars[vN].fun](contextVars[vN].loc, false, this.getWorldMatrix().getBufferData());
            break;

          case _ShaderSource.default.S_MV_SRC:
            viewMatrix = frameContext.getCalcContext(_ShaderSource.default.S_VIEW_MATRIX_SRC);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4, 0, viewMatrix, 0, this.getWorldMatrix(), 0);

            contextVars[vN].fun(contextVars[vN].loc, false, _TempVars.default.S_TEMP_MAT4.getBufferData());
            break;

          case _ShaderSource.default.S_MVP_SRC:
            viewMatrix = frameContext.getCalcContext(_ShaderSource.default.S_VIEW_MATRIX_SRC);
            projectMatrix = frameContext.getCalcContext(_ShaderSource.default.S_PROJECT_MATRIX_SRC);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4, 0, viewMatrix, 0, this.getWorldMatrix(), 0);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4_1, 0, projectMatrix, 0, viewMatrix, 0);

            gl[contextVars[vN].fun](contextVars[vN].loc, false, _TempVars.default.S_TEMP_MAT4_1.getBufferData());
            break;
        }
      }

      this._m_Mesh.draw(gl);
    }
  }]);

  return SkinGeometry;
}(_Geometry2.default);

exports["default"] = SkinGeometry;

/***/ }),

/***/ 9650:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Globals = _interopRequireDefault(__webpack_require__(8636));

var _Events = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 所有组件基类。<br/>
 * @author Kkk
 * @date 2021年2月1日16点03分
 */
var Component = /*#__PURE__*/function () {
  /**
   * 创建一个组件。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   */
  function Component(owner, cfg) {
    _classCallCheck(this, Component);

    cfg = cfg || {}; // 事件观察者

    this._mEvents = new _Events.default(); // 是否需要更新

    this._m_NeedUpdate = false;
    this._m_Id = cfg.id || _Globals.default.nextId(); // 保存附加组件

    this._m_Components = []; // 保存附加组件id,用于快速查找

    this._m_ComponentIDs = {}; // 场景

    this._m_Scene = null; // 表示当前组件的持有者,即当前组件附加到哪个对象上
    // scene不能附加到任何其他组件上

    this._m_Owner = owner; // 当前组件持有的组件

    this._m_OwnerAttachComponents = []; // 用于加速查询当前组件持有的组件

    this._m_OwnerAttachComponentIDs = {}; // 如果this是一个scene,则传入的scene参数为null

    if (this.getType() == "Scene") {
      this._m_Scene = this;
    } else {
      this._m_Scene = owner._m_Scene;
    }

    this._m_Scene.addComponentInScene(this);

    if (this._m_Owner) {
      this._m_Owner.attachComponent(this);
    }
  }
  /**
   * 注册观察者
   * @param {Object}[event 事件类型]
   * @param {Object}[callback 观察者]
   * @param {Object}[object 可选]
   */


  _createClass(Component, [{
    key: "getType",
    value: function getType() {
      return null;
    }
  }, {
    key: "on",
    value: function on(event, callback, object) {
      this._mEvents.register(event, callback, object);
    }
    /**
     * 移除一个观察者
     * @param {Object}[event 事件类型]
     * @param {Object}[callback 观察者]
     * @param {Object}[object 可选]
     */

  }, {
    key: "off",
    value: function off(event, callback, object) {
      this._mEvents.unregister(event, callback, object);
    }
    /**
     * 广播事件
     * @param {Object}[event 事件类型]
     * @param {Object}[eventArguments 事件参数列表]
     * @param {Object}[object 可选]
     */

  }, {
    key: "fire",
    value: function fire(event, eventArguments, object) {
      this._mEvents.trigger(event, eventArguments, object);
    }
    /**
     * 返回组件id
     * @returns {*}
     */

  }, {
    key: "getId",
    value: function getId() {
      return this._m_Id;
    }
    /**
     * 附加一个组件到当前组件中
     * @param {Component}[component]
     */

  }, {
    key: "attachComponent",
    value: function attachComponent(component) {
      if (component instanceof Component) {
        if (!this._m_OwnerAttachComponentIDs[component.getId()]) {
          this._m_OwnerAttachComponentIDs[component.getId()] = component;

          this._m_OwnerAttachComponents.push(component);
        }
      } else {
        console.error("component必须是一个组件!!");
      }
    }
    /**
     * 返回指定Id的组件。<br/>
     * @param {String}[id]
     * @return {Component}
     */

  }, {
    key: "getComponent",
    value: function getComponent(id) {
      if (this._m_OwnerAttachComponentIDs[id]) {
        return this._m_OwnerAttachComponentIDs[id];
      }

      return null;
    }
    /**
     * 返回指定索引的组件。<br/>
     * @param {Number}[index]
     * @return {Component}
     */

  }, {
    key: "getComponentAtIndex",
    value: function getComponentAtIndex(index) {
      if (index >= this._m_OwnerAttachComponents.length) {
        return null;
      }

      return this._m_OwnerAttachComponents[index];
    }
    /**
     * 返回指定类型的组件。<br/>
     * @param {String}[type]
     * @return {Component}
     */

  }, {
    key: "getComponentAtType",
    value: function getComponentAtType(type) {
      var count = this._m_OwnerAttachComponents.length;

      for (var i = 0; i < count; i++) {
        if (this._m_OwnerAttachComponents[i].getType() == type) {
          return this._m_OwnerAttachComponents[i];
        }
      }

      return null;
    }
    /**
     * 返回指定类型的组件列表。<br/>
     * @param {String}[type]
     * @return {Component[]}
     */

  }, {
    key: "getComponentAtTypes",
    value: function getComponentAtTypes(type) {
      var count = this._m_OwnerAttachComponents.length;
      var result = null;

      for (var i = 0; i < count; i++) {
        if (this._m_OwnerAttachComponents[i].getType() == type) {
          if (!result) {
            result = [];
          }

          result.push(this._m_OwnerAttachComponents[i]);
        }
      }

      return result;
    }
    /**
     * 返回所有组件。<br/>
     * @return {Component[]}
     */

  }, {
    key: "getComponents",
    value: function getComponents() {
      return this._m_OwnerAttachComponents;
    }
    /**
     * 从当前组件移除一个附加组件
     * @param {Component}[component]
     */

  }, {
    key: "detachComponent",
    value: function detachComponent(component) {
      if (component instanceof Component) {
        if (this._m_OwnerAttachComponentIDs[component.getId()]) {
          this._m_OwnerAttachComponentIDs[component.getId()] = null;

          var i = this._m_OwnerAttachComponents.indexOf(component);

          if (i > -1) {
            this._m_OwnerAttachComponents.splice(i, 1);
          }
        }
      }
    }
    /**
     * 所有组件继承这个函数,用于触发更新函数。<br/>
     * @private
     */

  }, {
    key: "_doUpdate",
    value: function _doUpdate(immediately) {
      // 设置为false,如果_update()重新将该值设置为true,则表明需要下一次更新
      this._m_NeedUpdate = false;

      if (immediately) {
        // Component注册
        // 在这之前做一些判断,比如是否立即调用update(),是在帧前,帧后进行的时间?
        if (this._update) {
          this._update();
        }
      } else {
        // 添加到更新队列中
        this._m_Scene.scheduleTask(this._update, this);
      }
    }
    /**
     * 所有组件实现这个方法,用于实现具体更新逻辑。<br/>
     * @private
     */

  }, {
    key: "_update",
    value: function _update() {}
  }]);

  return Component;
}();

exports["default"] = Component;

/***/ }),

/***/ 5109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Canvas = /*#__PURE__*/function (_Component) {
  _inherits(Canvas, _Component);

  var _super = _createSuper(Canvas);

  function Canvas(owner, cfg) {
    var _this;

    _classCallCheck(this, Canvas);

    _this = _super.call(this, owner, cfg);
    cfg.version = cfg.version || 'webgl2';
    _this._m_Canvas = cfg.canvas;

    if (_this._m_Canvas) {
      // 默认不需要alpha缓冲区,这个缓冲区的作用详见：https://www.khronos.org/registry/webgl/specs/latest/1.0/index.html#2.4
      // 关闭它可以在fragment中输出alpha<1时正确的不透明渲染,而不是混合html页面背景
      _this._m_GL = _this._m_Canvas.getContext(cfg.version, {
        antialias: !!cfg.antialias || true,
        depth: true,
        powerPreference: !!cfg.powerPreference || 'high-performance',
        alpha: !!cfg.alpha || false
      });

      if (!_this._m_GL) {
        _Log.default.error("浏览器不支持" + cfg.version + "!");
      } else {
        _this._m_GL.getExtension("OES_texture_float_linear");

        if (cfg.version == 'webgl2') {
          _this._m_GL.getExtension("EXT_color_buffer_float");
        } else {
          _this._m_GL.getExtension("OES_texture_float");

          _this._m_GL.getExtension("OES_texture_half_float");

          _this._m_GL.getExtension("OES_texture_half_float_linear");

          if (cfg.mobile) {
            _this._m_GL.getExtension("WEBGL_color_buffer_float");
          }

          var extDepth = _this._m_GL.getExtension("WEBGL_depth_texture");

          if (!extDepth) {
            console.log("Extension Depth texture is not working");
            alert(":( Sorry, Your browser doesn't support depth texture extension. Please browse to webglreport.com to see more information.");
            return _possibleConstructorReturn(_this);
          }
        }

        var extAni = _this._m_GL.getExtension('EXT_texture_filter_anisotropic');

        if (!extAni) {
          console.log('不支持各向异性拓展!');
        }

        if (extAni) {
          var maxAnisotropy = _this._m_GL.getParameter(extAni.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

          console.log('maxAnisotropy:' + maxAnisotropy); // this._m_GL.texParameterf(this._m_GL.TEXTURE_2D, extAni.TEXTURE_MAX_ANISOTROPY_EXT, 4);
        }

        _this._init();
      }

      _this._sizeCanvas(_this._m_Canvas.parentNode, _this._m_Canvas);
    }

    return _this;
  }
  /**
   * 监控canvas的大小
   * @param parent
   * @param canvas
   * @private
   */


  _createClass(Canvas, [{
    key: "_sizeCanvas",
    value: function _sizeCanvas(parent, canvas) {
      var self = this;

      var resetSize = function resetSize() {
        if (parent) {
          //调整为parent的大小
          canvas.width = parent.clientWidth;
          canvas.height = parent.clientHeight;
        } else {
          //调整为浏览器可见窗口大小
          canvas.width = document.documentElement.clientWidth;
          canvas.height = document.documentElement.clientHeight;
        }

        _Log.default.debug("改变大小:" + canvas.width + "," + canvas.height);

        self.fire('resize', [canvas.width, canvas.height]);
      }; // WindowManager.getInstance().addListener(WindowManager.S_ON_WINDOW_SIZE_CHANGE, );


      window.onresize = resetSize;
      resetSize();
    }
    /**
     * 返回canvas元素
     * @returns {Document}
     */

  }, {
    key: "getCanvasElement",
    value: function getCanvasElement() {
      return this._m_Canvas;
    }
  }, {
    key: "_init",
    value: function _init() {
      var gl = this._m_GL;
      gl.clearColor(.3, .3, .3, 1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
      gl.disable(gl.BLEND);
      gl.cullFace(gl.BACK); // <=

      gl.depthFunc(gl.LEQUAL);
    }
    /**
     * 设置ClearColor。<br/>
     * @param {Number}[r]
     * @param {Number}[g]
     * @param {Number}[b]
     * @param {Number}[a]
     */

  }, {
    key: "setClearColor",
    value: function setClearColor(r, g, b, a) {
      var gl = this._m_GL;
      gl.clearColor(r, g, b, a);
    }
    /**
     * 返回Canvas宽度。<br/>
     * @return {Number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this._m_Canvas.width;
    }
    /**
     * 返回Canvas高度。<br/>
     * @return {Number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this._m_Canvas.height;
    }
    /**
     * 返回GL上下文
     * @returns {CanvasRenderingContext2D | WebGLRenderingContext | *}
     */

  }, {
    key: "getGLContext",
    value: function getGLContext() {
      return this._m_GL;
    }
  }]);

  return Canvas;
}(_Component2.default);

exports["default"] = Canvas;

/***/ }),

/***/ 7120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Picture2 = _interopRequireDefault(__webpack_require__(7280));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Filter = /*#__PURE__*/function (_Component) {
  _inherits(Filter, _Component);

  var _super = _createSuper(Filter);

  function Filter(owner, cfg) {
    var _this;

    _classCallCheck(this, Filter);

    _this = _super.call(this, owner, cfg); // 由于js的缺陷,必须在这里实现继承,防止Component初始化导致无法访问继承的FilterFramePicture

    var FilterFramePicture = /*#__PURE__*/function (_Picture) {
      _inherits(FilterFramePicture, _Picture);

      var _super2 = _createSuper(FilterFramePicture);

      function FilterFramePicture(owner, cfg) {
        _classCallCheck(this, FilterFramePicture);

        return _super2.call(this, owner, cfg);
      }

      _createClass(FilterFramePicture, [{
        key: "getType",
        value: function getType() {
          return 'FramePicture';
        }
      }, {
        key: "isFramePicture",
        value: function isFramePicture() {
          return true;
        }
      }]);

      return FilterFramePicture;
    }(_Picture2.default);

    _this._m_Enable = true; // Js的执行顺序,导致这里无法new FramePicture,所以这里new Picture

    _this._m_FramePicture = new FilterFramePicture(owner, {
      id: _Tools.default.nextId()
    });
    _this._m_PreFrames = null;
    _this._m_PostFilters = null;
    return _this;
  }
  /**
   * 返回材质。<br/>
   * @return {Material}
   */


  _createClass(Filter, [{
    key: "getMaterial",
    value: function getMaterial() {
      return this._m_FramePicture.getMaterial();
    }
    /**
     * 准备就绪。<br/>
     */

  }, {
    key: "finish",
    value: function finish() {
      this._init();
    }
    /**
     * 初始化。<br/>
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      if (this._m_FramePicture.getMaterial().getCurrentTechnology().getSubPasss(Filter.S_PRE_FRAME_FILTER)) {
        this._m_PreFrames = {};
        this._m_PreFrames[this._m_FramePicture.getMaterial().getId()] = [];

        this._m_PreFrames[this._m_FramePicture.getMaterial().getId()].push(this._m_FramePicture);
      }

      if (this._m_FramePicture.getMaterial().getCurrentTechnology().getSubPasss(Filter.S_POST_FILTER)) {
        this._m_PostFilters = {};
        this._m_PostFilters[this._m_FramePicture.getMaterial().getId()] = [];

        this._m_PostFilters[this._m_FramePicture.getMaterial().getId()].push(this._m_FramePicture);
      }
    }
    /**
     * 执行preFrame阶段。<br/>
     * @param {RenderQueue}[renderQueue]
     */

  }, {
    key: "preFrame",
    value: function preFrame(renderQueue) {
      if (this._m_PreFrames) {// 启用物体材质渲染pass
        // ...
        // 或者使用PreFrame Post进行渲染
      }
    }
    /**
     * 执行postFilter阶段。<br/>
     */

  }, {
    key: "postFilter",
    value: function postFilter() {
      if (this._m_PostFilters) {
        var gl = this._m_Scene.getCanvas().getGLContext();

        this._m_Scene.getRender().draw(gl, Filter.S_POST_FILTER, this._m_PostFilters);
      }
    }
    /**
     * 使用给定的材质创建一个Filter。<br/>
     * @param {Component}[owner]
     * @param {Material}[material]
     * @return {Filter}
     */

  }, {
    key: "isEnable",
    value:
    /**
     * 是否激活该Filter。<br/>
     * @return {Boolean}
     */
    function isEnable() {
      return this._m_Enable;
    }
    /**
     * 激活该Filter。<br/>
     */

  }, {
    key: "enable",
    value: function enable() {
      this._m_Enable = true;
    }
    /**
     * 禁用该Filter。<br/>
     */

  }, {
    key: "disable",
    value: function disable() {
      this._m_Enable = false;
    }
  }], [{
    key: "newFilterFromMaterial",
    value: function newFilterFromMaterial(owner, material) {
      var filter = new Filter(owner, {
        id: _Tools.default.nextId()
      });

      filter._m_FramePicture.setMaterial(material);

      filter.finish();
      return filter;
    }
  }]);

  return Filter;
}(_Component2.default);

exports["default"] = Filter;

_defineProperty(Filter, "S_PRE_FRAME_FILTER", "PreFrame");

_defineProperty(Filter, "S_POST_FILTER", "PostFilter");

/***/ }),

/***/ 8636:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _GlobalsId = 0;

var Globals = /*#__PURE__*/function () {
  function Globals() {
    _classCallCheck(this, Globals);
  }

  _createClass(Globals, null, [{
    key: "nextId",
    value: function nextId() {
      return _GlobalsId--;
    }
  }]);

  return Globals;
}();

exports["default"] = Globals;

/***/ }),

/***/ 6984:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 一组Camera控制相关的状态机。<br/>
 * @author Kkk
 * @date 2021年6月22日10点58分
 */
var CameraIps = function CameraIps() {
  _classCallCheck(this, CameraIps);
};

exports["default"] = CameraIps;

_defineProperty(CameraIps, "CHASECAM_DOWN", "ChaseCamDown");

_defineProperty(CameraIps, "CHASECAM_UP", "ChaseCamUp");

_defineProperty(CameraIps, "CHASECAM_ZOOMIN", "ChaseCamZoomIn");

_defineProperty(CameraIps, "CHASECAM_ZOOMOUT", "ChaseCamZoomOut");

_defineProperty(CameraIps, "CHASECAM_MOVELEFT", "ChaseCamMoveLeft");

_defineProperty(CameraIps, "CHASECAM_MOVERIGHT", "ChaseCamMoveRight");

_defineProperty(CameraIps, "CHASECAM_TOGGLEROTATE", "ChaseCamToggleRotate");

_defineProperty(CameraIps, "CAMERA_MOVELEFT", "CameraMoveLeft");

_defineProperty(CameraIps, "CAMERA_MOVERIGHT", "CameraMoveRight");

_defineProperty(CameraIps, "CAMERA_MOVEFRONT", "CameraMoveFront");

_defineProperty(CameraIps, "CAMERA_MOVEBACK", "CameraMoveBack");

_defineProperty(CameraIps, "FLYCAM_LEFT", "FLYCAM_Left");

_defineProperty(CameraIps, "FLYCAM_RIGHT", "FLYCAM_Right");

_defineProperty(CameraIps, "FLYCAM_UP", "FLYCAM_Up");

_defineProperty(CameraIps, "FLYCAM_DOWN", "FLYCAM_Down");

_defineProperty(CameraIps, "FLYCAM_STRAFELEFT", "FLYCAM_StrafeLeft");

_defineProperty(CameraIps, "FLYCAM_STRAFERIGHT", "FLYCAM_StrafeRight");

_defineProperty(CameraIps, "FLYCAM_FORWARD", "FLYCAM_Forward");

_defineProperty(CameraIps, "FLYCAM_BACKWARD", "FLYCAM_Backward");

_defineProperty(CameraIps, "FLYCAM_ZOOMIN", "FLYCAM_ZoomIn");

_defineProperty(CameraIps, "FLYCAM_ZOOMOUT", "FLYCAM_ZoomOut");

_defineProperty(CameraIps, "FLYCAM_ROTATEDRAG", "FLYCAM_RotateDrag");

_defineProperty(CameraIps, "FLYCAM_RISE", "FLYCAM_Rise");

_defineProperty(CameraIps, "FLYCAM_LOWER", "FLYCAM_Lower");

_defineProperty(CameraIps, "FLYCAM_INVERTY", "FLYCAM_InvertY");

/***/ }),

/***/ 8878:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Input = _interopRequireDefault(__webpack_require__(4165));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FirstPersonController = /*#__PURE__*/function (_Component) {
  _inherits(FirstPersonController, _Component);

  var _super = _createSuper(FirstPersonController);

  function FirstPersonController(owner, cfg) {
    var _this;

    _classCallCheck(this, FirstPersonController);

    _this = _super.call(this, owner, cfg);
    _this._m_LastExTime = 0;
    _this._m_Camera = null;

    _this._m_CameraList = function (v, p, pv) {
      _this.refresh();
    };

    _this.setCamera(cfg.camera || _this._m_Scene.getMainCamera()); // 相机的一些属性


    _this._m_Position = new _Vector.default();
    cfg.position = cfg.position || _this._m_Camera.getEye();

    if (cfg.position) {
      _this._m_Position.setTo(cfg.position);
    }

    _this._m_Front = new _Vector.default(0, 0, -1);
    cfg.front = cfg.front || _this._m_Camera.getAt().subRetNew(cfg.position).normal();

    if (cfg.front) {
      _this._m_Front.setTo(cfg.front);
    }

    _this._m_Up = new _Vector.default();
    _this._m_Right = new _Vector.default();
    _this._m_WorldUp = new _Vector.default(0, 1, 0);

    if (cfg.up) {
      _this._m_WorldUp.setTo(cfg.up);
    } // 欧拉角


    _this._m_Yaw = cfg.yaw || FirstPersonController.YAW; // 抬起与抬下

    _this._m_Pitch = cfg.pitch || FirstPersonController.PITCH; // 左转与右转
    // 控制器速度

    _this._m_MovementSpeed = cfg.movementSpeed || FirstPersonController.SPEED; // 移动速率

    _this._m_MouseSensitivity = cfg.mouseSensitivity || FirstPersonController.SENSITIVITY; // 旋转速率

    _this._m_Zoom = cfg.zoom || FirstPersonController.ZOOM; // 缩放速率
    // 视图矩阵

    _this._m_ViewMatrix = new _Matrix.default();

    _this._m_ViewMatrix.identity(); // 同步欧拉角


    _this.synYawPitch(); // 计算视图矩阵三个向量


    _this.updateCameraVectors();

    _this._updateViewMatrix();

    var sceneInput = _Input.default.getInput(_this._m_Scene, {
      id: _this._m_Scene.getId()
    }); // 监听update事件


    _this._m_Scene.on('update', function (exTime) {
      _this._m_LastExTime = exTime;
      var needUpdateViewMatrix = false; // 旋转视点部分

      if (sceneInput.getMouseButtonDown(_Input.default.S_MOUSE_BUTTON0)) {
        // 在按住鼠标左键时,我们在进行旋转视点
        _this.processMouseMovement(sceneInput.getAmountX(), sceneInput.getAmountY(), true);

        _this.updateCameraVectors();

        needUpdateViewMatrix = true;
      } // 移动视点部分


      var direction = null;

      if (sceneInput.getKeyDown(_Input.default.S_KEY_W)) {
        direction = FirstPersonController.FORWARD;
      } else if (sceneInput.getKeyDown(_Input.default.S_KEY_S)) {
        direction = FirstPersonController.BACKWARD;
      }

      if (sceneInput.getKeyDown(_Input.default.S_KEY_A)) {
        direction = FirstPersonController.LEFT;
      } else if (sceneInput.getKeyDown(_Input.default.S_KEY_D)) {
        direction = FirstPersonController.RIGHT;
      }

      if (direction != null) {
        needUpdateViewMatrix = true;

        _this.processKeyboard(direction, _this._m_LastExTime);
      }

      if (needUpdateViewMatrix) {
        _this._doUpdate(true);
      }
    });

    sceneInput.on("mousewheel", function (offset) {
      // 滚动部分
      if (offset) {
        _this.processMouseScroll(offset);

        _this._m_Camera.scroll(_this._m_Zoom);
      }
    });
    return _this;
  }
  /**
   * 设置移动速率去。<br/>
   * @param {Number}[movementSpeed]
   */


  _createClass(FirstPersonController, [{
    key: "setMovementSpeed",
    value: function setMovementSpeed(movementSpeed) {
      this._m_MovementSpeed = movementSpeed;
    }
    /**
     * 设置鼠标旋转率。<br/>
     * @param {Number}[mouseSensitivity]
     */

  }, {
    key: "setMouseSensitivity",
    value: function setMouseSensitivity(mouseSensitivity) {
      this._m_MouseSensitivity = mouseSensitivity;
    }
    /**
     * 手动同步控制器与view的状态。<br/>
     */

  }, {
    key: "refresh",
    value: function refresh() {
      this._m_Position.setTo(this._m_Camera.getEye());

      this._m_Front.setTo(this._m_Camera.getAt().subRetNew(this._m_Position).normal());

      this.synYawPitch();
    }
    /**
     * 设置控制器关联的Camera。<br/>
     * @param {Camera}[cam]
     */

  }, {
    key: "setCamera",
    value: function setCamera(cam) {
      if (cam != null && this._m_Camera != cam) {
        if (this._m_Camera) {
          // 移除事件
          this._m_Camera.off(_Camera.default.S_CAMERA_UPDATE_EVENT, this._m_CameraList);
        }

        this._m_Camera = cam;

        this._m_Camera.on(_Camera.default.S_CAMERA_UPDATE_EVENT, this._m_CameraList);
      }
    }
    /**
     * 同步yaw,pitch欧拉角数据。<br/>
     * 当我们从主相机获得viewMatrix时,或者从其他地方更新了front,up,position等,我们需要反向计算出yaw,pitch欧拉角。<br/>
     * 以便控制器可以同步控制相机。<br/>
     */

  }, {
    key: "synYawPitch",
    value: function synYawPitch() {
      // 这里只计算当worldUp == (0, 1, 0)时的情况
      this._m_Pitch = _MoreMath.default.toAngle(Math.asin(this._m_Front._m_Y));
      var t = Math.cos(_MoreMath.default.toRadians(this._m_Pitch)); //this.mFront.z = Maths.sin(MoreMath.toRadians(this.mYaw)) * t;
      //let g = this.mFront.z / t;

      var g = this._m_Front._m_Z / t;

      if (g >= 1) {
        g = 1;
      } else if (g <= -1) {
        g = -1;
      }

      this._m_Yaw = _MoreMath.default.toAngle(Math.asin(g)); //确保yaw在正确的角度内

      var ts = Math.cos(_MoreMath.default.toRadians(this._m_Yaw)) * t;

      if (ts * this._m_Front._m_X < 0) {
        this._m_Yaw = 180 + -this._m_Yaw;
      }
    }
    /**
     * 处理从任何类似键盘的输入系统接收的输入。 接受摄像机定义的ENUM形式的输入参数（以从窗口系统中抽象出来）。<br/>
     * @param {Object}[direction 移动方向,相机移动枚举量之一]
     * @param {Number}[exTime 帧经过时间]
     */

  }, {
    key: "processKeyboard",
    value: function processKeyboard(direction, exTime) {
      // 计算速率
      var velocity = this._m_MovementSpeed * exTime;

      if (direction == FirstPersonController.FORWARD) {
        this._m_Front.multLength(velocity, _TempVars.default.S_TEMP_VEC3);

        this._m_Position.add(_TempVars.default.S_TEMP_VEC3);
      } else if (direction == FirstPersonController.BACKWARD) {
        this._m_Front.multLength(velocity * -1, _TempVars.default.S_TEMP_VEC3);

        this._m_Position.add(_TempVars.default.S_TEMP_VEC3);
      } else if (direction == FirstPersonController.LEFT) {
        this._m_Right.multLength(velocity * -1, _TempVars.default.S_TEMP_VEC3);

        this._m_Position.add(_TempVars.default.S_TEMP_VEC3);
      } else if (direction == FirstPersonController.RIGHT) {
        this._m_Right.multLength(velocity, _TempVars.default.S_TEMP_VEC3);

        this._m_Position.add(_TempVars.default.S_TEMP_VEC3);
      }
    }
    /**
     * 处理从鼠标输入系统接收到的输入。 预期在x和y方向上的偏移值。<br/>
     * @param {Number}[xamount 鼠标x方向的移动量,非累计移动量]
     * @param {Number}[yamount 鼠标y方向的移动量,非累计移动量]
     * @param {Boolean}[constrainPitch 是否约束相机,防止过度朝上或朝下导致屏幕翻转]
     */

  }, {
    key: "processMouseMovement",
    value: function processMouseMovement(xamount, yamount, constrainPitch) {
      constrainPitch = constrainPitch == undefined || constrainPitch == null ? true : constrainPitch;
      xamount *= this._m_MouseSensitivity;
      yamount *= this._m_MouseSensitivity; // 计算yaw,pitch欧拉角

      this._m_Yaw += xamount;
      this._m_Pitch += yamount; // 限制在90度朝上和朝下,避免翻转

      if (constrainPitch) {
        if (this._m_Pitch > 89.0) {
          this._m_Pitch = 89;
        } else if (this._m_Pitch < -89.0) {
          this._m_Pitch = -89;
        }
      }
    }
    /**
     * 处理从鼠标滚轮事件收到的输入。 只需要在垂直轮轴上输入。<br/>
     * @param {Number}[offset 滚动量,非累计量]
     */

  }, {
    key: "processMouseScroll",
    value: function processMouseScroll(offset) {
      this._m_Zoom -= offset;

      if (this._m_Zoom < 1.0) {
        this._m_Zoom = 1.0;
      }

      if (this._m_Zoom > 45.0) {
        this._m_Zoom = 45.0;
      }
    }
    /**
     * 更新视图矩阵。<br/>
     * @private
     */

  }, {
    key: "_updateViewMatrix",
    value: function _updateViewMatrix() {
      this._m_Position.add(this._m_Front, _TempVars.default.S_TEMP_VEC3);

      this._m_ViewMatrix.lookAt(this._m_Position, _TempVars.default.S_TEMP_VEC3, this._m_Up);
    }
    /**
     * 返回视图矩阵。<br/>
     * @returns {Matrix44}[视图矩阵]
     */

  }, {
    key: "getViewMatrix",
    value: function getViewMatrix() {
      return this._m_ViewMatrix;
    }
    /**
     * 返回视图矩阵数组。<br/>
     * @returns {Number[]}[16数组]
     */

  }, {
    key: "getViewMatrixArray",
    value: function getViewMatrixArray() {
      return this.getViewMatrix().m;
    }
    /**
     * 更新相交三个主要向量
     */

  }, {
    key: "updateCameraVectors",
    value: function updateCameraVectors() {
      // 计算当前朝向
      _TempVars.default.S_TEMP_VEC3._m_X = Math.cos(_MoreMath.default.toRadians(this._m_Yaw)) * Math.cos(_MoreMath.default.toRadians(this._m_Pitch));
      _TempVars.default.S_TEMP_VEC3._m_Y = Math.sin(_MoreMath.default.toRadians(this._m_Pitch));
      _TempVars.default.S_TEMP_VEC3._m_Z = Math.sin(_MoreMath.default.toRadians(this._m_Yaw)) * Math.cos(_MoreMath.default.toRadians(this._m_Pitch));

      this._m_Front.setTo(_TempVars.default.S_TEMP_VEC3);

      this._m_Front.normal(); // 计算视图矩阵当前right和up部分


      this._m_Front.cross(this._m_WorldUp, this._m_Right);

      this._m_Right.normal();

      this._m_Right.cross(this._m_Front, this._m_Up);

      this._m_Up.normal();
    }
  }, {
    key: "_update",
    value: function _update() {
      // 更新矩阵
      this._updateViewMatrix(); // 更新camera
      // 为了加速,尽量不使用直接setViewMatrix
      // this._m_Scene.getMainCamera().setViewMatrix(this._m_ViewMatrix);


      this._m_Camera.lookAt(this._m_Position, this._m_Position.add(this._m_Front, _TempVars.default.S_TEMP_VEC3), this._m_Up);
    }
  }]);

  return FirstPersonController;
}(_Component2.default);

exports["default"] = FirstPersonController;

_defineProperty(FirstPersonController, "FORWARD", 1);

_defineProperty(FirstPersonController, "BACKWARD", FirstPersonController.FORWARD << 1);

_defineProperty(FirstPersonController, "LEFT", FirstPersonController.BACKWARD << 1);

_defineProperty(FirstPersonController, "RIGHT", FirstPersonController.LEFT << 1);

_defineProperty(FirstPersonController, "YAW", -90.0);

_defineProperty(FirstPersonController, "PITCH", 0.0);

_defineProperty(FirstPersonController, "SPEED", 10.5);

_defineProperty(FirstPersonController, "SENSITIVITY", 0.1);

_defineProperty(FirstPersonController, "ZOOM", 45.0);

/***/ }),

/***/ 4165:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Input = /*#__PURE__*/function (_Component) {
  _inherits(Input, _Component);

  var _super = _createSuper(Input);

  function Input(owner, cfg) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this, owner, cfg); // 注册事件

    var canvas = _this._m_Scene.getCanvas();

    var canvasElement = canvas.getCanvasElement();
    _this._keys = {};
    _this._mouseButtons = {};
    _this._mouseCoords = null;
    _this._wheelDelta = 0;
    _this._amountX = 0, _this._amountY = 0;
    _this._mouseStartDownCoords = null;

    canvasElement.oncontextmenu = function () {
      return false;
    }; // 各种事件监听


    canvasElement.onkeydown = function (event) {
      _this._keys[Input.S_KEYS[event.key]] = true;

      _this.fire('keydown', [Input.S_KEYS[event.key]]);
    };

    canvasElement.onkeyup = function (event) {
      _this._keys[Input.S_KEYS[event.key]] = false;

      _this.fire('keyup', [Input.S_KEYS[event.key]]);
    };

    canvasElement.onkeypress = function (event) {
      _this.fire('keypress', [Input.S_KEYS[event.key]]);
    };

    var isMouseDown = false;

    canvasElement.onmousedown = function (event) {
      isMouseDown = true;
      _this._wheelDelta = 0;
      _this._amountX = 0;
      _this._amountY = 0;
      _this._mouseCoords = _this._getClickCoordsWithinElement(event);
      _this._mouseStartDownCoords = _this._mouseCoords;
      var mouseDownButton = null;

      switch (event.which || event.button + 1) {
        case 1:
          // Left button
          _this._mouseButtons[Input.S_MOUSE_BUTTON0] = true;
          mouseDownButton = Input.S_MOUSE_BUTTON0_DOWN;
          break;

        case 2:
          // Middle/both buttons
          _this._mouseButtons[Input.S_MOUSE_BUTTON1] = true;
          mouseDownButton = Input.S_MOUSE_BUTTON1_DOWN;
          break;

        case 3:
          // Right button
          _this._mouseButtons[Input.S_MOUSE_BUTTON2] = true;
          mouseDownButton = Input.S_MOUSE_BUTTON2_DOWN;
          break;

        default:
          break;
      }

      _this.fire('mousedown', [mouseDownButton]);
    };

    canvasElement.onmouseup = function (event) {
      isMouseDown = false;
      _this._wheelDelta = 0;
      _this._amountX = 0;
      _this._amountY = 0;
      _this._mouseCoords = _this._getClickCoordsWithinElement(event);
      _this._mouseStartDownCoords = _this._mouseCoords;
      var mouseUpButton = null;

      switch (event.which || event.button + 1) {
        case 1:
          // Left button
          _this._mouseButtons[Input.S_MOUSE_BUTTON0] = false;
          mouseUpButton = Input.S_MOUSE_BUTTON0_UP;
          break;

        case 2:
          // Middle/both buttons
          _this._mouseButtons[Input.S_MOUSE_BUTTON1] = false;
          mouseUpButton = Input.S_MOUSE_BUTTON1_UP;
          break;

        case 3:
          // Right button
          _this._mouseButtons[Input.S_MOUSE_BUTTON2] = false;
          mouseUpButton = Input.S_MOUSE_BUTTON2_UP;
          break;

        default:
          break;
      }

      _this.fire('mouseup', [mouseUpButton]);
    };

    var enter = false;

    canvasElement.onmouseenter = function (event) {
      _this._wheelDelta = 0;
      _this._amountX = 0;
      _this._amountY = 0;
      enter = true;
      _this._mouseCoords = _this._getClickCoordsWithinElement(event);
    };

    canvasElement.onmouseout = function (event) {
      _this._wheelDelta = 0;
      _this._amountX = 0;
      _this._amountY = 0;
      enter = false;
      _this._mouseCoords = _this._getClickCoordsWithinElement(event);
    }; // 记录移动的偏移量,已经当前鼠标位置


    canvasElement.onmousemove = function (event) {
      if (enter) {
        _this._wheelDelta = 0;
        _this._mouseCoords = _this._getClickCoordsWithinElement(event); // 计算按下鼠标后的偏移量

        if (isMouseDown) {
          _this._amountX = _this._mouseCoords[0] - _this._mouseStartDownCoords[0];
          _this._amountY = _this._mouseCoords[1] - _this._mouseStartDownCoords[1]; // 可以试试注释下面的代码查看FirstPersonController的效果

          _this._mouseStartDownCoords[0] = _this._mouseCoords[0];
          _this._mouseStartDownCoords[1] = _this._mouseCoords[1];
        }

        _this.fire('mousemove', [_this._mouseCoords]);
      }
    };

    canvasElement.onmousewheel = function (event) {
      _this._amountX = 0;
      _this._amountY = 0;
      _this._mouseCoords = _this._getClickCoordsWithinElement(event); // 获取滚动量

      if (event.wheelDelta) {
        //IE、chrome浏览器使用的是wheelDelta，并且值为“正负120”
        _this._wheelDelta = event.wheelDelta / 120;
        if (window.opera) _this._wheelDelta = -_this._wheelDelta; //因为IE、chrome等向下滚动是负值，FF是正值，为了处理一致性，在此取反处理
      } else if (event.detail) {
        //FF浏览器使用的是detail,其值为“正负3”
        _this._wheelDelta = -event.detail / 3;
      }

      _this.fire('mousewheel', [_this._wheelDelta]);
    };

    return _this;
  }
  /**
   * 返回指定鼠标按钮是否按下。<br/>
   * @param {Input.MOUSE_KEY}[mouseButtonKey 指定的鼠标按钮枚举]
   * @returns {Boolean}
   */


  _createClass(Input, [{
    key: "getMouseButtonDown",
    value: function getMouseButtonDown(mouseButtonKey) {
      return this._mouseButtons[mouseButtonKey];
    }
    /**
     * 返回指定按键是否按下
     * @param {Input.KEYS}[指定的按键]
     * @returns {Boolean}
     */

  }, {
    key: "getKeyDown",
    value: function getKeyDown(key) {
      return this._keys[key];
    }
    /**
     * 返回指定的按键是否抬起
     * @param {Input.KEYS}[指定的按键]
     * @returns {Boolean}
     */

  }, {
    key: "getKeyUp",
    value: function getKeyUp(key) {
      return !this._keys[key];
    }
    /**
     * 返回x方向的移动量
     * @returns {Number}[数值]
     */

  }, {
    key: "getAmountX",
    value: function getAmountX() {
      return this._amountX;
    }
    /**
     * 返回y方向的移动量
     * @returns {Number}[数值]
     */

  }, {
    key: "getAmountY",
    value: function getAmountY() {
      // 以左下角起点而不是左上角
      return -this._amountY;
    }
    /**
     * 返回最近的鼠标位置
     * @returns {Number[]}[[x,z]数组]
     */

  }, {
    key: "getMouseCoords",
    value: function getMouseCoords() {
      return this._mouseCoords;
    }
    /**
     * 返回最近的滚轮滚动值
     * @returns {Number}[数值]
     */

  }, {
    key: "getWheelDelta",
    value: function getWheelDelta() {
      return this._wheelDelta;
    }
    /**
     * 返回元素鼠标事件中鼠标相对于该元素的(x,y)
     * @param {Object}[event 元素鼠标事件]
     * @returns {number[]}[鼠标位置]
     * @private
     */

  }, {
    key: "_getClickCoordsWithinElement",
    value: function _getClickCoordsWithinElement(event) {
      var coords = [0, 0];

      if (!event) {
        event = window.event;
        coords.x = event.x;
        coords.y = event.y;
      } else {
        var element = event.target;
        var totalOffsetLeft = 0;
        var totalOffsetTop = 0;

        while (element.offsetParent) {
          totalOffsetLeft += element.offsetLeft;
          totalOffsetTop += element.offsetTop;
          element = element.offsetParent;
        }

        coords[0] = event.pageX - totalOffsetLeft;
        coords[1] = event.pageY - totalOffsetTop;
      }

      return coords;
    }
  }], [{
    key: "getInput",
    value: // keyCode
    function getInput(owner, cfg) {
      if (Input.S_INPUTS[cfg.id]) {
        return Input.S_INPUTS[cfg.id];
      } else {
        var input = new Input(owner, cfg);
        Input.S_INPUTS[cfg.id] = input;
        return input;
      }
    }
  }]);

  return Input;
}(_Component2.default);

exports["default"] = Input;

_defineProperty(Input, "s_Inputs", {});

_defineProperty(Input, "S_KEY_0", 0);

_defineProperty(Input, "S_KEY_1", 1);

_defineProperty(Input, "S_KEY_2", 2);

_defineProperty(Input, "S_KEY_3", 3);

_defineProperty(Input, "S_KEY_4", 4);

_defineProperty(Input, "S_KEY_5", 5);

_defineProperty(Input, "S_KEY_6", 6);

_defineProperty(Input, "S_KEY_7", 7);

_defineProperty(Input, "S_KEY_8", 8);

_defineProperty(Input, "S_KEY_9", 9);

_defineProperty(Input, "S_KEY_A", 10);

_defineProperty(Input, "S_KEY_B", 11);

_defineProperty(Input, "S_KEY_C", 12);

_defineProperty(Input, "S_KEY_D", 13);

_defineProperty(Input, "S_KEY_E", 14);

_defineProperty(Input, "S_KEY_F", 15);

_defineProperty(Input, "S_KEY_G", 16);

_defineProperty(Input, "S_KEY_H", 17);

_defineProperty(Input, "S_KEY_I", 18);

_defineProperty(Input, "S_KEY_J", 19);

_defineProperty(Input, "S_KEY_K", 20);

_defineProperty(Input, "S_KEY_L", 21);

_defineProperty(Input, "S_KEY_M", 22);

_defineProperty(Input, "S_KEY_N", 23);

_defineProperty(Input, "S_KEY_O", 24);

_defineProperty(Input, "S_KEY_P", 25);

_defineProperty(Input, "S_KEY_Q", 26);

_defineProperty(Input, "S_KEY_R", 27);

_defineProperty(Input, "S_KEY_S", 28);

_defineProperty(Input, "S_KEY_T", 29);

_defineProperty(Input, "S_KEY_U", 30);

_defineProperty(Input, "S_KEY_V", 31);

_defineProperty(Input, "S_KEY_W", 32);

_defineProperty(Input, "S_KEY_X", 33);

_defineProperty(Input, "S_KEY_Y", 34);

_defineProperty(Input, "S_KEY_Z", 35);

_defineProperty(Input, "S_KEYS", {
  '0': Input.S_KEY_0,
  '1': Input.S_KEY_1,
  '2': Input.S_KEY_2,
  '3': Input.S_KEY_3,
  '4': Input.S_KEY_4,
  '5': Input.S_KEY_5,
  '6': Input.S_KEY_6,
  '7': Input.S_KEY_7,
  '8': Input.S_KEY_8,
  '9': Input.S_KEY_9,
  'a': Input.S_KEY_A,
  'b': Input.S_KEY_B,
  'c': Input.S_KEY_C,
  'd': Input.S_KEY_D,
  'e': Input.S_KEY_E,
  'f': Input.S_KEY_F,
  'g': Input.S_KEY_G,
  'h': Input.S_KEY_H,
  'i': Input.S_KEY_I,
  'j': Input.S_KEY_J,
  'k': Input.S_KEY_K,
  'l': Input.S_KEY_L,
  'm': Input.S_KEY_M,
  'n': Input.S_KEY_N,
  'o': Input.S_KEY_O,
  'p': Input.S_KEY_P,
  'q': Input.S_KEY_Q,
  'r': Input.S_KEY_R,
  's': Input.S_KEY_S,
  't': Input.S_KEY_T,
  'u': Input.S_KEY_U,
  'v': Input.S_KEY_V,
  'w': Input.S_KEY_W,
  'x': Input.S_KEY_X,
  'y': Input.S_KEY_Y,
  'z': Input.S_KEY_Z
});

_defineProperty(Input, "S_MOUSE_BUTTON0_DOWN", 36);

_defineProperty(Input, "S_MOUSE_BUTTON1_DOWN", 37);

_defineProperty(Input, "S_MOUSE_BUTTON2_DOWN", 38);

_defineProperty(Input, "S_MOUSE_BUTTON0_UP", 39);

_defineProperty(Input, "S_MOUSE_BUTTON1_UP", 40);

_defineProperty(Input, "S_MOUSE_BUTTON2_UP", 41);

_defineProperty(Input, "S_MOUSE_BUTTON0", 42);

_defineProperty(Input, "S_MOUSE_BUTTON1", 43);

_defineProperty(Input, "S_MOUSE_BUTTON2", 44);

_defineProperty(Input, "S_INPUTS", {});

/***/ }),

/***/ 2028:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Input = _interopRequireDefault(__webpack_require__(4165));

var _CameraIps = _interopRequireDefault(__webpack_require__(6984));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SceneBrowsingController = /*#__PURE__*/function (_Component) {
  _inherits(SceneBrowsingController, _Component);

  var _super = _createSuper(SceneBrowsingController);

  function SceneBrowsingController(owner, cfg) {
    var _this;

    _classCallCheck(this, SceneBrowsingController);

    _this = _super.call(this, owner, cfg);

    _defineProperty(_assertThisInitialized(_this), "_m_Enabled", true);

    _defineProperty(_assertThisInitialized(_this), "_m_Rotating", true);

    _defineProperty(_assertThisInitialized(_this), "_m_VRotating", true);

    _defineProperty(_assertThisInitialized(_this), "_m_CanRotate", true);

    _defineProperty(_assertThisInitialized(_this), "_m_Rotation", 0.0);

    _defineProperty(_assertThisInitialized(_this), "_m_VRotation", Math.PI / 6.0);

    _defineProperty(_assertThisInitialized(_this), "_m_PreviousTargetRotation", 0.0);

    _defineProperty(_assertThisInitialized(_this), "_m_TargetRotation", _this._m_Rotation);

    _defineProperty(_assertThisInitialized(_this), "_m_TargetVRotation", _this._m_VRotation);

    _defineProperty(_assertThisInitialized(_this), "_m_RotationSpeed", 0.3);

    _defineProperty(_assertThisInitialized(_this), "_m_ZoomSensitivity", 2.0);

    _defineProperty(_assertThisInitialized(_this), "_m_ZoomSpeed", 1.0);

    _defineProperty(_assertThisInitialized(_this), "_m_VeryCloseRotation", true);

    _defineProperty(_assertThisInitialized(_this), "_m_MaxVerticalRotation", Math.PI / 2.0);

    _defineProperty(_assertThisInitialized(_this), "_m_MinVerticalRotation", -Math.PI / 2.0);

    _defineProperty(_assertThisInitialized(_this), "_m_Distance", 1);

    _defineProperty(_assertThisInitialized(_this), "_m_TargetDistance", _this._m_Distance);

    _defineProperty(_assertThisInitialized(_this), "_m_MinDistance", 1.0);

    _defineProperty(_assertThisInitialized(_this), "_m_MaxDistance", 10.0);

    _defineProperty(_assertThisInitialized(_this), "_m_Chasing", true);

    _defineProperty(_assertThisInitialized(_this), "_m_Zooming", true);

    _defineProperty(_assertThisInitialized(_this), "_m_Zoomin", false);

    _defineProperty(_assertThisInitialized(_this), "_m_TrailingRotationInertia", 0.05);

    _defineProperty(_assertThisInitialized(_this), "_m_DistanceLerpFactor", 0.0);

    _defineProperty(_assertThisInitialized(_this), "_m_TrailingLerpFactor", 0.0);

    _defineProperty(_assertThisInitialized(_this), "_m_TrailingSensitivity", 5.0);

    _defineProperty(_assertThisInitialized(_this), "_m_RotationSensitivity", 5.0);

    _defineProperty(_assertThisInitialized(_this), "_m_TrailingEnabled", true);

    _defineProperty(_assertThisInitialized(_this), "_m_SmoothMotion", true);

    _defineProperty(_assertThisInitialized(_this), "_m_TargetLocation", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_TargetDir", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_OffsetDistance", 0.002);

    _defineProperty(_assertThisInitialized(_this), "_m_Target", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_LookAtOffset", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_PrevPos", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "temp", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "temp2", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Pos", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_InitialUpVec", new _Vector.default().setTo(_Vector.default.S_UNIT_AXIS_Y));

    _defineProperty(_assertThisInitialized(_this), "_m_Cam", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_ChasingSensitivity", 5.0);

    _defineProperty(_assertThisInitialized(_this), "_m_Input", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_TargetMoves", false);

    _this._m_Cam = cfg.camera || _this._m_Scene.getMainCamera();
    _this._m_Input = _Input.default.getInput(_this._m_Scene, {
      id: _this._m_Scene.getId()
    }); // 监听update事件

    var lastTPF = 0;

    _this._m_Scene.on('update', function (exTime) {
      lastTPF = exTime;

      _this.updateCamera(exTime);
    });

    _this._m_Input.on("mousewheel", function (offset) {
      // 滚动部分
      if (offset) {
        _this.analog(offset > 0 ? _CameraIps.default.CHASECAM_ZOOMIN : _CameraIps.default.CHASECAM_ZOOMOUT, (offset > 0 ? offset : -offset) * _this._m_ZoomSpeed, lastTPF);
      }
    });

    return _this;
  }
  /**
   * 设置旋转速率。<br/>
   * @param {Number}[rotateSpeed]
   */


  _createClass(SceneBrowsingController, [{
    key: "setRotationSpeed",
    value: function setRotationSpeed(rotateSpeed) {
      this._m_RotationSpeed = rotateSpeed;
    }
    /**
     * 返回旋转速率。<br/>
     * @return {Number}
     */

  }, {
    key: "getRotationSpeed",
    value: function getRotationSpeed() {
      return this._m_RotationSpeed;
    }
    /**
     * 设置聚焦速率。<br/>
     * @param {Number}[zoomSpeed]
     */

  }, {
    key: "setZoomSpeed",
    value: function setZoomSpeed(zoomSpeed) {
      this._m_ZoomSpeed = zoomSpeed;
    }
    /**
     * 返回聚焦速率。<br/>
     * @return {Number}
     */

  }, {
    key: "getZoomSpeed",
    value: function getZoomSpeed() {
      return this._m_ZoomSpeed;
    }
    /**
     * 设置当前相机距离Target的距离。<br/>
     * @param {Number}[distance]
     */

  }, {
    key: "setTargetDistance",
    value: function setTargetDistance(distance) {
      this._m_TargetDistance = distance;
    }
    /**
     * 返回当前相机距离Target的距离。<br/>
     * @return {Number}
     */

  }, {
    key: "getDistance",
    value: function getDistance() {
      return this._m_Distance;
    }
    /**
     * 观察场景。<br/>
     * @param {Node}[scene]
     */

  }, {
    key: "lookScene",
    value: function lookScene(scene) {
      if (scene) {
        var aabb = scene.getBoundingVolume();
        var distanceX = aabb.getXHalf() * 2;
        var distanceY = aabb.getYHalf() * 2;
        var distanceZ = aabb.getZHalf() * 2;
        var diagonal = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2) + Math.pow(distanceZ, 2));
        var far = diagonal * 5; // 5是一个被猜测的常数，应该与最大缩小因子一致

        var near = far / 5000;
        var d = far - near;
        var maxDistance = Math.max(distanceX, distanceY, distanceZ) * 2;
        this.setTargetDistance((maxDistance - near) * 0.5 + near);
        this.setMaxDistance(maxDistance);
        this.setMinDistance(near);
        this.setZoomSpeed(d * 0.2);
        var v = new _Vector.default();
        aabb.getCenter(v);
        this.setTarget(v);
      }
    }
    /**
     * 设置追随目标。<br/>
     * @param {Vector3D}[target]
     */

  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this._m_Target.setTo(target);
    }
    /**
     * 同步状态为指定导航朝向。<br/>
     * @param {Number[]}[dir]
     * @param {boolean}[zoomMaxDis 聚焦于最大距离观察]
     */

  }, {
    key: "syncNavDir",
    value: function syncNavDir(dir, zoomMaxDis) {
      //目标方向的计算
      this._m_TargetDir.setToInXYZ(dir[0], dir[1], dir[2]);

      this._m_TargetDir.normal(); // 计算Elur


      this._m_TargetVRotation = Math.asin(this._m_TargetDir.y);
      var t = Math.cos(this._m_TargetVRotation);
      var g = this._m_TargetDir.z / t;

      if (g >= 1) {
        g = 1;
      } else if (g <= -1) {
        g = -1;
      }

      this._m_TargetRotation = Math.asin(g); //确保yaw在正确的角度内

      var ts = Math.cos(this._m_TargetRotation) * t;

      if (ts * this._m_TargetDir.x < 0) {
        this._m_TargetRotation = Math.PI + -this._m_TargetRotation;
      }

      this._m_Rotating = true;
      this._m_VRotating = true;

      if (zoomMaxDis) {
        this._m_Zooming = true;
        this.setTargetDistance(this._m_MaxDistance);
      }
    }
    /**
     * 旋转指定弧度。<br/>
     * @param h
     * @param v
     */

  }, {
    key: "rotate",
    value: function rotate(h, v) {
      var rs = this._m_RotationSpeed;
      this._m_RotationSpeed = Math.PI / 100;

      this._rotate1(h);

      this._rotate2(v);

      this._m_RotationSpeed = rs;
    }
    /**
     * 水平旋转相机。<br/>
     * @param {Number}[val]
     * @private
     */

  }, {
    key: "_rotate1",
    value: function _rotate1(val) {
      if (!this._m_CanRotate || !this._m_Enabled) {
        return;
      }

      this._m_Rotating = true;
      this._m_TargetRotation += val * this._m_RotationSpeed;
    }
    /**
     * 垂直旋转相机。<br/>
     * @param {Number}[val]
     * @private
     */

  }, {
    key: "_rotate2",
    value: function _rotate2(val) {
      if (!this._m_CanRotate || !this._m_Enabled) {
        return;
      }

      this._m_VRotating = true;
      var lastGoodRot = this._m_TargetVRotation;
      this._m_TargetVRotation += val * this._m_RotationSpeed;

      if (this._m_TargetVRotation > this._m_MaxVerticalRotation) {
        this._m_TargetVRotation = lastGoodRot;
      }

      if (this._m_VeryCloseRotation) {
        if (this._m_TargetVRotation < this._m_MinVerticalRotation && this._m_TargetDistance > this._m_MinDistance + 1.0) {
          this._m_TargetVRotation = this._m_MinVerticalRotation;
        } else if (this._m_TargetVRotation < -_MoreMath.default.S_DEG_TO_RAD * 90) {
          this._m_TargetVRotation = lastGoodRot;
        }
      } else {
        if (this._m_TargetVRotation < this._m_MinVerticalRotation) {
          this._m_TargetVRotation = lastGoodRot;
        }
      }
    }
    /**
     * 设置最小垂直旋转角度。<br/>
     * @param {Number}[minVerticalRotation 弧度，默认为-Math.PI/2.0]
     */

  }, {
    key: "setMinVerticalRotation",
    value: function setMinVerticalRotation(minVerticalRotation) {
      this._m_MinVerticalRotation = minVerticalRotation;
    }
    /**
     * 设置最大垂直旋转加偶。<br/>
     * @param {Number}[maxVerticalRotation 弧度，默认为Math.PI/2.0]
     */

  }, {
    key: "setMaxVerticalRotation",
    value: function setMaxVerticalRotation(maxVerticalRotation) {
      this._m_MaxVerticalRotation = maxVerticalRotation;
    }
    /**
     * 焦距相机。<br/>
     * @param {Number}[val]
     */

  }, {
    key: "_zoomCamera",
    value: function _zoomCamera(val) {
      if (!this._m_Enabled) {
        return;
      }

      this._m_Zooming = true;
      this._m_TargetDistance += val * this._m_ZoomSensitivity;

      if (this._m_TargetDistance > this._m_MaxDistance) {
        this._m_TargetDistance = this._m_MaxDistance;
      }

      if (this._m_TargetDistance < this._m_MinDistance) {
        this._m_TargetDistance = this._m_MinDistance;
      }

      if (this._m_VeryCloseRotation) {
        if (this._m_TargetVRotation < this._m_MinVerticalRotation && this._m_TargetDistance > this._m_MinDistance + 1.0) {
          this._m_TargetVRotation = this._m_MinVerticalRotation;
        }
      }
    }
    /**
     * 检查输入处理。<br/>
     * @param {Number}[tpf]
     * @private
     */

  }, {
    key: "_checkInput",
    value: function _checkInput(tpf) {
      if (this._m_Input.getMouseButtonDown(_Input.default.S_MOUSE_BUTTON0)) {
        var dx = this._m_Input.getAmountX();

        var dy = this._m_Input.getAmountY();

        if (dx != 0) {
          this.analog(dx > 0 ? _CameraIps.default.CHASECAM_MOVERIGHT : _CameraIps.default.CHASECAM_MOVELEFT, dx > 0 ? dx : -dx, tpf);
        }

        if (dy != 0) {
          this.analog(dy > 0 ? _CameraIps.default.CHASECAM_DOWN : _CameraIps.default.CHASECAM_UP, dy > 0 ? dy : -dy, tpf);
        }
      }
    }
    /**
     * 更新相机，外部调用。<br/>
     * @param {Number}[tpf]
     */

  }, {
    key: "updateCamera",
    value: function updateCamera(tpf) {
      if (this._m_Enabled) {
        this._checkInput(tpf);

        this._updateCamera(tpf);
      }
    }
    /**
     * 更新相机，内部调用。<br/>
     * @param {Number}[tpf]
     * @private
     */

  }, {
    key: "_updateCamera",
    value: function _updateCamera(tpf) {
      if (this._m_Enabled) {
        this._m_TargetLocation.setTo(this._m_Target).add(this._m_LookAtOffset);

        var update = false;

        if (this._m_SmoothMotion) {
          //目标方向的计算
          this._m_TargetDir.setTo(this._m_TargetLocation).sub(this._m_PrevPos);

          var dist = this._m_TargetDir.length(); //启用物理时，对目标位置进行低通滤波以避免晃动。


          if (this._m_OffsetDistance < dist) {
            //目标移动，开始追逐。
            this._m_Chasing = true; //目标移动，如果必须，开始跟踪。

            if (this._m_TrailingEnabled) {
              this._m_Trailing = true;
            } //目标移动...


            this._m_TargetMoves = true;
          } else {
            //如果目标在动，我计算的轻微旋转偏移，以避免cam的粗糙停止
            //如果玩家正在旋转cam，这里便不会执行
            if (this._m_TargetMoves && !this._m_CanRotate) {
              if (this._m_TargetRotation - this._m_Rotation > this._m_TrailingRotationInertia) {
                this._m_TargetRotation = this._m_Rotation + this._m_TrailingRotationInertia;
              } else if (this._m_TargetRotation - this._m_Rotation < -this._m_TrailingRotationInertia) {
                this._m_TargetRotation = this._m_Rotation - this._m_TrailingRotationInertia;
              }
            } //目标停止


            this._m_TargetMoves = false;
          } //用户通过拖动鼠标来旋转cam


          if (this._m_CanRotate) {
            //重置尾随 lerp 因子
            this._m_TrailingLerpFactor = 0; //停止追踪用户拥有控制权

            this._m_Trailing = false;
          }

          if (this._m_TrailingEnabled && this._m_Trailing) {
            if (this._m_TargetMoves) {
              //计算目标方向是否反转
              var a = this._m_TargetDir.negate().normal(); //x 单位向量


              var b = _Vector.default.S_UNIT_AXIS_X; //2d就够了

              a.y = 0; //计算 x 轴和轨迹之间的旋转角度

              if (this._m_TargetDir.z > 0) {
                this._m_TargetRotation = _MoreMath.default.S_TWO_PI - Math.acos(a.dot(b));
              } else {
                this._m_TargetRotation = Math.acos(a.dot(b));
              }

              if (this._m_TargetRotation - this._m_Rotation > Math.PI || this._m_TargetRotation - this._m_Rotation < -Math.PI) {
                this._m_TargetRotation -= _MoreMath.default.S_TWO_PI;
              } //如果在跟踪 lerp 因子的重置过程中方向发生重要变化以避免跳动


              if (this._m_TargetRotation != this._m_PreviousTargetRotation && Math.abs(this._m_TargetRotation - this._m_PreviousTargetRotation) > Math.PI / 8) {
                this._m_TrailingLerpFactor = 0;
              }

              this._m_PreviousTargetRotation = this._m_TargetRotation;
            } //计算 lerp 因子


            this._m_TrailingLerpFactor = Math.min(this._m_TrailingLerpFactor + tpf * tpf * this._m_TrailingSensitivity, 1); //通过线性插值计算旋转

            this._m_Rotation = _MoreMath.default.interpolateLinear(this._m_TrailingLerpFactor, this._m_Rotation, this._m_TargetRotation); //如果旋转接近目标旋转，那就结束了

            if (this._m_TargetRotation + 0.01 >= this._m_Rotation && this._m_TargetRotation - 0.01 <= this._m_Rotation) {
              this._m_Trailing = false;
              this._m_TrailingLerpFactor = 0;
            }
          } //追逐时距离的线性插值


          if (this._m_Chasing) {
            this.temp2.setTo(this._m_Cam.getEye());
            this._m_Distance = this.temp.setTo(this._m_TargetLocation).sub(this.temp2).length();
            this._m_DistanceLerpFactor = Math.min(this._m_DistanceLerpFactor + tpf * tpf * this._m_ChasingSensitivity * 0.05, 1);
            this._m_Distance = _MoreMath.default.interpolateLinear(this._m_DistanceLerpFactor, this._m_Distance, this._m_TargetDistance);

            if (this._m_TargetDistance + 0.01 >= this._m_Distance && this._m_TargetDistance - 0.01 <= this._m_Distance) {
              this._m_DistanceLerpFactor = 0;
              this._m_Chasing = false;
            }
          } //缩放时距离的线性插值


          if (this._m_Zooming) {
            this._m_DistanceLerpFactor = Math.min(this._m_DistanceLerpFactor + tpf * tpf * this._m_ZoomSensitivity, 1);
            this._m_Distance = _MoreMath.default.interpolateLinear(this._m_DistanceLerpFactor, this._m_Distance, this._m_TargetDistance);

            if (this._m_TargetDistance + 0.1 >= this._m_Distance && this._m_TargetDistance - 0.1 <= this._m_Distance) {
              this._m_Zooming = false;
              this._m_DistanceLerpFactor = 0;
            }
          } //水平旋转时旋转的线性插值


          if (this._m_Rotating) {
            this._m_RotationLerpFactor = Math.min(this._m_RotationLerpFactor + tpf * tpf * this._m_RotationSensitivity, 1);
            this._m_Rotation = _MoreMath.default.interpolateLinear(this._m_RotationLerpFactor, this._m_Rotation, this._m_TargetRotation);

            if (this._m_TargetRotation + 0.01 >= this._m_Rotation && this._m_TargetRotation - 0.01 <= this._m_Rotation) {
              this._m_Rotating = false;
              this._m_RotationLerpFactor = 0;
            }
          } //垂直旋转时旋转的线性插值


          if (this._m_VRotating) {
            this._m_VRotationLerpFactor = Math.min(this._m_VRotationLerpFactor + tpf * tpf * this._m_RotationSensitivity, 1);
            this._m_VRotation = _MoreMath.default.interpolateLinear(this._m_VRotationLerpFactor, this._m_VRotation, this._m_TargetVRotation);

            if (this._m_TargetVRotation + 0.01 >= this._m_VRotation && this._m_TargetVRotation - 0.01 <= this._m_VRotation) {
              this._m_VRotating = false;
              this._m_VRotationLerpFactor = 0;
            }
          } //计算pos


          this.computePosition(); //设置当前pos

          this._m_Pos.add(this._m_LookAtOffset);

          update = true;
        } else {
          //容易没有平滑的运动
          this._m_VRotation = this._m_TargetVRotation;
          this._m_Rotation = this._m_TargetRotation;
          this._m_Distance = this._m_TargetDistance;
          this.computePosition();

          this._m_Pos.add(this._m_LookAtOffset);

          update = true;
        } //跟踪目标的先前位置


        this._m_PrevPos.setTo(this._m_TargetLocation); //cam朝向目标


        this._m_Cam.lookAt(this._m_Pos, this._m_TargetLocation, this._m_InitialUpVec);
      }
    }
  }, {
    key: "computePosition",
    value: function computePosition() {
      var hDistance = this._m_Distance * Math.sin(Math.PI / 2 - this._m_VRotation);

      this._m_Pos.setToInXYZ(hDistance * Math.cos(this._m_Rotation), this._m_Distance * Math.sin(this._m_VRotation), hDistance * Math.sin(this._m_Rotation));

      this._m_Pos.add(this._m_Target);
    }
    /**
     * 信号处理。<br/>
     * @param {string}[name]
     * @param {number}[val]
     * @param {number}[tpf]
     */

  }, {
    key: "analog",
    value: function analog(name, val, tpf) {
      if (name == _CameraIps.default.CHASECAM_MOVELEFT) {
        this._rotate1(-val * tpf);
      } else if (name == _CameraIps.default.CHASECAM_MOVERIGHT) {
        this._rotate1(val * tpf);
      } else if (name == _CameraIps.default.CHASECAM_UP) {
        this._rotate2(val * tpf);
      } else if (name == _CameraIps.default.CHASECAM_DOWN) {
        this._rotate2(-val * tpf);
      } else if (name == _CameraIps.default.CHASECAM_ZOOMIN) {
        this._zoomCamera(-val * tpf);

        if (this._m_Zoomin == false) {
          this._m_DistanceLerpFactor = 0;
        }

        this._m_Zoomin = true;
      } else if (name == _CameraIps.default.CHASECAM_ZOOMOUT) {
        this._zoomCamera(+val * tpf);

        if (this._m_Zoomin == true) {
          this._m_DistanceLerpFactor = 0;
        }

        this._m_Zoomin = false;
      }
    }
    /**
     * 返回控制器激活与否状态。<br/>
     * @return {boolean}
     */

  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._m_Enabled;
    }
    /**
     * 设置控制器激活状态。<br/>
     * @param {boolean}[enabled]
     */

  }, {
    key: "setEnabled",
    value: function setEnabled(enabled) {
      this._m_Enabled = enabled;
      this._m_CanRotate = enabled;
    }
    /**
     * 返回最大焦距，默认40。<br/>
     * @return {number}
     */

  }, {
    key: "getMaxDistance",
    value: function getMaxDistance() {
      return this._m_MaxDistance;
    }
    /**
     * 设置最大焦距，默认40。<br/>
     * @param {Number}[md]
     */

  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(md) {
      this._m_MaxDistance = md;

      if (md < this._m_Distance) {
        this._zoomCamera(md - this._m_Distance);
      }
    }
    /**
     * 返回最小焦距，默认1。<br/>
     * @return {number}
     */

  }, {
    key: "getMinDistance",
    value: function getMinDistance() {
      return this._m_MinDistance;
    }
    /**
     * 设置最小焦距，默认1。<br/>
     * @param {Number}[md]
     */

  }, {
    key: "setMinDistance",
    value: function setMinDistance(md) {
      this._m_MinDistance = md;

      if (md > this._m_Distance) {
        this._zoomCamera(this._m_Distance - md);
      }
    }
  }]);

  return SceneBrowsingController;
}(_Component2.default);

exports["default"] = SceneBrowsingController;

/***/ }),

/***/ 7539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Light2 = _interopRequireDefault(__webpack_require__(513));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _DirectionalLightShadowProcess = _interopRequireDefault(__webpack_require__(6177));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DirectionalLight = /*#__PURE__*/function (_Light) {
  _inherits(DirectionalLight, _Light);

  var _super = _createSuper(DirectionalLight);

  function DirectionalLight(owner, cfg) {
    var _this;

    _classCallCheck(this, DirectionalLight);

    _this = _super.call(this, owner, cfg); // 方向

    _this._m_Direction = new _Vector.default();
    return _this;
  }

  _createClass(DirectionalLight, [{
    key: "getType",
    value: // 尽量不依赖外部类枚举，所以在这里声明合适类型
    // 半过渡类型表示分区随着等级而衰减一半大小的shadowMap(也是默认模式)
    // 固定shadowMap分辨率,表示所有分区shadowMap分辨率一致
    function getType() {
      return 'DirectionalLight';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 0;
    }
  }, {
    key: "_genShadow",
    value: function _genShadow() {
      // 创建用于DirectionalLight的阴影
      this._m_ShadowCfg.id = this._m_Id + "_shadow";
      this._m_ShadowCfg.nbSplits = this._m_ShadowCfg.nbSplits || 2;
      this._m_Shadow = new _DirectionalLightShadowProcess.default(this._m_Scene, this._m_ShadowCfg);
    }
    /**
     * 设置阴影分区数目，最大为4，最小为1，默认为2。<br/>
     * @param {Number}[splitNum]
     */

  }, {
    key: "setShadowSplitNum",
    value: function setShadowSplitNum(splitNum) {
      if (splitNum < 1 || splitNum > 4) {
        _Log.default.error('错误的分区数目:' + splitNum);
      }

      this._m_ShadowCfg.nbSplits = splitNum || 2;
    }
    /**
     * 设置分区模式，只能在第一次调用proShadow之前生效。<br/>
     * @param {Number}[type 必须是DirectionalLight的枚举之一]
     */

  }, {
    key: "setShadowSplitType",
    value: function setShadowSplitType(type) {
      this._m_ShadowCfg.shadowSplitType = type;
    }
    /**
     * 设置方向。<br/>
     * @param {Vector3}[dir]
     */

  }, {
    key: "setDirection",
    value: function setDirection(dir) {
      this._m_Direction.setTo(dir);
    }
    /**
     * 返回方向。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getDirection",
    value: function getDirection() {
      return this._m_Direction;
    }
    /**
     * 设置方向。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setDirectionXYZ",
    value: function setDirectionXYZ(x, y, z) {
      this._m_Direction.setToInXYZ(x, y, z);

      this._m_Direction.normal();
    }
    /**
     * 返回DirectionalLight的AABBBoundary。<br/>
     * 这里直接返回null,表示一直可见。<br/>
     * @return {null}
     */

  }, {
    key: "getBoundingVolume",
    value: function getBoundingVolume() {
      return null;
    }
  }]);

  return DirectionalLight;
}(_Light2.default);

exports["default"] = DirectionalLight;

_defineProperty(DirectionalLight, "S_SHADER_SPLIT_TYPE_HALF_TRANSITION", 0x001);

_defineProperty(DirectionalLight, "S_SHADER_SPLIT_TYPE_FIXED", 0x002);

/***/ }),

/***/ 2815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Probe2 = _interopRequireDefault(__webpack_require__(6967));

var _BoundingSphere = _interopRequireDefault(__webpack_require__(1846));

var _UniformBuffer = _interopRequireDefault(__webpack_require__(1446));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * GIProbe。<br/>
 * GI探头，用于全局光照的探头捕捉器，以便能够在险隘空间为物体提供更加精确的全局光。<br/>
 * GI探头需要设置位置，范围（目前仅实现球形探头，后续再考虑拓展到边界探头），目前未实现探头混合（但预留了符号名，以便后续完善）。<br/>
 * @author Kkk
 * @date 2021年3月20日13点07分
 */
var GIProbe = /*#__PURE__*/function (_Probe) {
  _inherits(GIProbe, _Probe);

  var _super = _createSuper(GIProbe);

  function GIProbe(owner, cfg) {
    var _this;

    _classCallCheck(this, GIProbe);

    _this = _super.call(this, owner, cfg);
    _this._m_ShCoeffs = null;
    _this._m_ShCoeffsBufferData = null;
    _this._m_PrefilterEnvMap = null;
    _this._m_PrefilterMipmap = 0;
    _this._m_Bounding = new _BoundingSphere.default();
    return _this;
  }
  /**
   * 设置PrefilterMipmap级别数量。<br/>
   * @param {Number}[pfmm]
   */


  _createClass(GIProbe, [{
    key: "getType",
    value: function getType() {
      return 'GIProbe';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 4;
    }
  }, {
    key: "setPrefilterMipmap",
    value: function setPrefilterMipmap(pfmm) {
      this._m_PrefilterMipmap = pfmm;
    }
    /**
     * 返回PrefilterMipmap级别数量。<br/>
     * @return {Number}
     */

  }, {
    key: "getPrefilterMipmap",
    value: function getPrefilterMipmap() {
      return this._m_PrefilterMipmap;
    }
    /**
     * 设置半径范围。<br/>
     * @param {Number}[radius]
     */

  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this._m_Bounding.setRaiuds(radius);
    }
    /**
     * 返回半径。<br/>
     * @return {Number}
     */

  }, {
    key: "getRadius",
    value: function getRadius() {
      return this._m_Bounding.getRadius();
    }
    /**
     * 设置球谐系数。<br/>
     * @param {Vector3[]}[shCoeffs 9个球谐系数]
     */

  }, {
    key: "setShCoeffs",
    value: function setShCoeffs(shCoeffs) {
      this._m_ShCoeffs = shCoeffs;
      this._m_ShCoeffsBufferData = new _UniformBuffer.default(9 * 3);

      var array = this._m_ShCoeffsBufferData.getArray();

      for (var i = 0, t = 0; i < shCoeffs.length; i++) {
        array[t++] = shCoeffs[i]._m_X;
        array[t++] = shCoeffs[i]._m_Y;
        array[t++] = shCoeffs[i]._m_Z;
      }
    }
    /**
     * 返回球谐系数。<br/>
     * @return {Vector3[]}
     */

  }, {
    key: "getShCoeffs",
    value: function getShCoeffs() {
      return this._m_ShCoeffs;
    }
  }, {
    key: "getShCoeffsBufferData",
    value: function getShCoeffsBufferData() {
      return this._m_ShCoeffsBufferData;
    }
    /**
     * 设置预过滤环境纹理。<br/>
     * @param {TextureCubeVars}[prefilterEnvMap]
     */

  }, {
    key: "setPrefilterEnvMap",
    value: function setPrefilterEnvMap(prefilterEnvMap) {
      this._m_PrefilterEnvMap = prefilterEnvMap;
    }
    /**
     * 返回预过滤环境纹理。<br/>
     * @return {TextureCubeVars}
     */

  }, {
    key: "getPrefilterEnvMap",
    value: function getPrefilterEnvMap() {
      return this._m_PrefilterEnvMap;
    }
  }]);

  return GIProbe;
}(_Probe2.default);

exports["default"] = GIProbe;

/***/ }),

/***/ 513:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Node2 = _interopRequireDefault(__webpack_require__(2949));

var _Vector = _interopRequireDefault(__webpack_require__(7141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Light = /*#__PURE__*/function (_Node) {
  _inherits(Light, _Node);

  var _super = _createSuper(Light);

  function Light(owner, cfg) {
    var _this;

    _classCallCheck(this, Light);

    _this = _super.call(this, owner, cfg); // 灯光可以附加在任何节点中

    _this._m_Color = new _Vector.default();
    _this._m_Enable = true;

    _this._m_Scene.enableLight(_assertThisInitialized(_this));

    _this._m_ProShadow = false;
    _this._m_ResetProShadow = _this._m_ProShadow;
    _this._m_Shadow = null;
    _this._m_ShadowCfg = {
      shadowMapSize: 512,
      backfaceShadows: false,
      debug: false
    };
    _this._m_Mark = 0;

    _this._init();

    return _this;
  }
  /**
   * 初始化。<br/>
   * @private
   */


  _createClass(Light, [{
    key: "getType",
    value: function getType() {
      return 'Light';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return -1;
    }
  }, {
    key: "_init",
    value: function _init() {
      this._m_Mark |= Light.S_VISIBLE_LIGHT;
      this._m_Mark |= Light.S_DYNAMIC;
    }
    /**
     * 激活该灯光。<br/>
     */

  }, {
    key: "enable",
    value: function enable() {
      if (this._m_Enable) return;
      this._m_Enable = true;

      this._m_Scene.enableLight(this);

      if (this._m_ResetProShadow) {
        this._m_ResetProShadow = false;
        this.proShadow(true);
      }
    }
    /**
     * 返回阴影。<br/>
     * @return {Object}
     */

  }, {
    key: "getShadow",
    value: function getShadow() {
      return this._m_Shadow;
    }
    /**
     * 设置阴影贴图分辨率，只能在第一次调用proShadow时生效。<br/>
     * @param {Number}[shadowMapSize]
     */

  }, {
    key: "setShadowMapSize",
    value: function setShadowMapSize(shadowMapSize) {
      this._m_ShadowCfg.shadowMapSize = shadowMapSize;
    }
    /**
     * debug，只能在第一次调用proShadow时生效。<br/>
     */

  }, {
    key: "debugShadowMap",
    value: function debugShadowMap() {
      this._m_ShadowCfg.debug = true;
    }
    /**
     * 是否投射阴影。<br/>
     * @param {Boolean}[proShadow]
     */

  }, {
    key: "proShadow",
    value: function proShadow(_proShadow) {
      this._m_ProShadow = _proShadow;

      if (this._m_ProShadow && !this._m_Shadow) {
        this._genShadow();

        if (this._m_Shadow) {
          this._m_Shadow.setLight(this);
        }
      }

      if (this._m_Shadow) {
        this._m_Shadow.enable(_proShadow);
      }
    }
    /**
     * 是否投射阴影。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isProShadow",
    value: function isProShadow() {
      return this._m_ProShadow;
    }
    /**
     * 创建阴影。<br/>
     * @private
     */

  }, {
    key: "_genShadow",
    value: function _genShadow() {// 由子类实现
    }
    /**
     * 禁用该灯光。<br/>
     */

  }, {
    key: "disable",
    value: function disable() {
      if (this._m_Enable) {
        this._m_Enable = false;

        this._m_Scene.disableLight(this);

        if (this._m_ProShadow) {
          this._m_ResetProShadow = this._m_ProShadow;
          this.proShadow(false);
        }
      }
    }
    /**
     * 判断该灯是否激活。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isEnable",
    value: function isEnable() {
      return this._m_Enable;
    }
    /**
     * 设置颜色。<br/>
     * @param {Vector4}[color]
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._m_Color.setTo(color);
    }
    /**
     * 返回颜色。<br/>
     * @return {Vector4}
     */

  }, {
    key: "getColor",
    value: function getColor() {
      return this._m_Color;
    }
    /**
     * 设置颜色rgba。<br/>
     * @param {Number}[r 介于0-1]
     * @param {Number}[g 介于0-1]
     * @param {Number}[b 介于0-1]
     * @param {Number}[a 介于0-1]
     */

  }, {
    key: "setColorRGBA",
    value: function setColorRGBA(r, g, b, a) {
      this._m_Color.setToInXYZW(r, g, b, a);
    }
    /**
     * 强制更新包围体。<br/>
     */

  }, {
    key: "updateBounding",
    value: function updateBounding() {
      this._updateBounding();
    }
  }]);

  return Light;
}(_Node2.default);

exports["default"] = Light;

_defineProperty(Light, "S_VISIBLE_LIGHT", 0x001);

_defineProperty(Light, "S_STATIC_LIGHT", 0x002);

_defineProperty(Light, "S_DYNAMIC", 0x003);

/***/ }),

/***/ 6807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Light2 = _interopRequireDefault(__webpack_require__(513));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _BoundingSphere = _interopRequireDefault(__webpack_require__(1846));

var _PointLightShadowProcess = _interopRequireDefault(__webpack_require__(4867));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * 点光源。<br/>
 * 通过指定点光源位置和半径可以实现范围光照。<br/>
 * @author Kkk
 * @date 2021年2月17日14点37分
 */
var PointLight = /*#__PURE__*/function (_Light) {
  _inherits(PointLight, _Light);

  var _super = _createSuper(PointLight);

  function PointLight(owner, cfg) {
    var _this;

    _classCallCheck(this, PointLight);

    _this = _super.call(this, owner, cfg); // 位置

    _this._m_Position = new _Vector.default(); // 灯光半径

    _this._m_Radius = -1; // 光源裁剪渐变范围

    _this._m_StepClip = 0.2; // 半径倒数(加速计算)

    _this._m_InvRadius = 1.0 / _this._m_Radius; // 与其在裁剪范围进行扩大，不如直接减少半径，但是这可能带来一个问题是SpotLight和PointLight半径范围变小
    // 因为使用了1.0/r,所以会与光锥裁剪时的r有误差,只能在这里进行误差缩小

    _this._m_InvRadius2 = 1.0 / (_this._m_Radius - _this._m_StepClip);
    return _this;
  }

  _createClass(PointLight, [{
    key: "getType",
    value: function getType() {
      return 'PointLight';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 1;
    }
  }, {
    key: "_genShadow",
    value: function _genShadow() {
      // 创建用于PointLight的阴影
      this._m_ShadowCfg.id = this._m_Id + "_shadow";
      this._m_Shadow = new _PointLightShadowProcess.default(this._m_Scene, this._m_ShadowCfg);
    }
    /**
     * 设置光源裁剪渐变范围。<br/>
     * @param {Number}[stepClip]
     */

  }, {
    key: "setStepClip",
    value: function setStepClip(stepClip) {
      if (stepClip < 0) {
        stepClip = 1.0;
      }

      this._m_StepClip = stepClip;
      this._m_InvRadius2 = 1.0 / (this._m_Radius - this._m_StepClip);
    }
    /**
     * 返回光源裁剪渐变范围。<br/>
     * @return {Number}
     */

  }, {
    key: "getStepClip",
    value: function getStepClip() {
      return this._m_StepClip;
    }
    /**
     * 设置灯光位置。<br/>
     * @param {Vector3}[pos]
     */

  }, {
    key: "setPosition",
    value: function setPosition(pos) {
      this._m_Position.setTo(pos);

      this._updateBounding();
    }
    /**
     * 返回灯光位置。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this._m_Position;
    }
    /**
     * 设置灯光位置。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setPositionXYZ",
    value: function setPositionXYZ(x, y, z) {
      this._m_Position.setToInXYZ(x, y, z);

      this._updateBounding();
    }
    /**
     * 设置灯光半径。<br/>
     * -1表示无限远。<br/>
     * @param {Number}[radius 默认为-1]
     */

  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this._m_Radius = radius;
      this._m_InvRadius = 1.0 / radius;

      this._updateBounding();
    }
    /**
     * 返回当前点光源半径。<br/>
     * @return {Number}[默认为-1]
     */

  }, {
    key: "getRadius",
    value: function getRadius() {
      return this._m_Radius;
    }
    /**
     * 返回半径倒数。<br/>
     * @return {number|*}
     */

  }, {
    key: "getInRadius",
    value: function getInRadius() {
      return this._m_InvRadius;
    }
    /**
     * 返回光源裁剪后的半径的倒数。<br/>
     * @return {number|*}
     */

  }, {
    key: "getInRadius2",
    value: function getInRadius2() {
      return this._m_InvRadius2;
    }
  }, {
    key: "getBoundingVolume",
    value: function getBoundingVolume() {
      if (this._m_UpdateBoundingVolume) {
        if (!this._m_BoudingVolume) {
          // 对于PointLight,创建包围球
          this._m_BoudingVolume = new _BoundingSphere.default();
        }

        this._m_BoudingVolume.setCenter(this._m_Position);

        this._m_BoudingVolume.setRaiuds(this._m_Radius);

        this._m_UpdateBoundingVolume = false;
      }

      return this._m_BoudingVolume;
    }
  }]);

  return PointLight;
}(_Light2.default);

exports["default"] = PointLight;

/***/ }),

/***/ 6967:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Light2 = _interopRequireDefault(__webpack_require__(513));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Probe。<br/>
 * 反射探头和GI探头从该类派生。<br/>
 * @author Kkk
 * @date 2021年3月22日17点14分
 */
var Probe = /*#__PURE__*/function (_Light) {
  _inherits(Probe, _Light);

  var _super = _createSuper(Probe);

  function Probe(owner, cfg) {
    var _this;

    _classCallCheck(this, Probe);

    _this = _super.call(this, owner, cfg);
    _this._m_Position = new _Vector.default();
    return _this;
  }
  /**
   * 设置光探头位置。<br/>
   * @param {Number}[x]
   * @param {Number}[y]
   * @param {Number}[z]
   */


  _createClass(Probe, [{
    key: "getType",
    value: function getType() {
      return 'Probe';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 100;
    }
  }, {
    key: "setPositionFromXYZ",
    value: function setPositionFromXYZ(x, y, z) {
      this._m_Position.setToInXYZ(x, y, z);
    }
    /**
     * 返回光探头位置。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this._m_Position;
    }
  }]);

  return Probe;
}(_Light2.default);

exports["default"] = Probe;

/***/ }),

/***/ 3330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Probe2 = _interopRequireDefault(__webpack_require__(6967));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * RefProbe。<br/>
 * 反射探头用于反射环境光，典型的用法是用于模拟菲涅尔效应。<br/>
 * @author Kkk
 * @date 2021年3月22日17点17分
 */
var RefProbe = /*#__PURE__*/function (_Probe) {
  _inherits(RefProbe, _Probe);

  var _super = _createSuper(RefProbe);

  function RefProbe(owner, cfg) {
    _classCallCheck(this, RefProbe);

    return _super.call(this, owner, cfg);
  }

  _createClass(RefProbe, [{
    key: "getType",
    value: function getType() {
      return 'RefProbe';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 5;
    }
  }]);

  return RefProbe;
}(_Probe2.default);

exports["default"] = RefProbe;

/***/ }),

/***/ 9098:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Light2 = _interopRequireDefault(__webpack_require__(513));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _BoundingSphere = _interopRequireDefault(__webpack_require__(1846));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _SpotLightShadowProcess = _interopRequireDefault(__webpack_require__(948));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * 聚光灯。<br/>
 * 包含位置,朝向,内外角等信息。<br/>
 * @author Kkk
 * @date 2021年2月17日14点41分
 */
var SpotLight = /*#__PURE__*/function (_Light) {
  _inherits(SpotLight, _Light);

  var _super = _createSuper(SpotLight);

  function SpotLight(owner, cfg) {
    var _this;

    _classCallCheck(this, SpotLight);

    _this = _super.call(this, owner, cfg); // 方向

    _this._m_Direction = new _Vector.default(); // 位置

    _this._m_Position = new _Vector.default(); // 内角

    _this._m_InnerAngle = _MoreMath.default.toRadians(30);
    _this._m_InnerCorner = Math.cos(_this._m_InnerAngle); // 外角

    _this._m_OuterAngle = _MoreMath.default.toRadians(45);
    _this._m_OuterCorner = Math.cos(_this._m_OuterAngle); // 最远能够照射多远(为0表示可以无限远)

    _this._m_SpotRange = 100; // 光源裁剪渐变范围

    _this._m_StepClip = 4.0; // 最远照射范围倒数(用于加速计算)

    _this._m_InvSpotRange = 1.0 / _this._m_SpotRange; // 内外角余弦差

    _this._m_InnerMinusOuter = _this._m_InnerCorner - _this._m_OuterCorner; // 打包内外角到一个变量中

    _this._m_PackedAngleCos = 0;

    _this.computeAngleParameters();

    return _this;
  }

  _createClass(SpotLight, [{
    key: "getType",
    value: function getType() {
      return 'SpotLight';
    }
  }, {
    key: "getTypeId",
    value: function getTypeId() {
      return 2;
    }
  }, {
    key: "_genShadow",
    value: function _genShadow() {
      // 创建用于SpotLight的阴影
      this._m_ShadowCfg.id = this._m_Id + "_shadow";
      this._m_Shadow = new _SpotLightShadowProcess.default(this._m_Scene, this._m_ShadowCfg);
    }
    /**
     * 设置光源裁剪渐变范围。<br/>
     * @param {Number}[stepClip]
     */

  }, {
    key: "setStepClip",
    value: function setStepClip(stepClip) {
      if (stepClip < 0) {
        stepClip = 1.0;
      }

      this._m_StepClip = stepClip;
    }
    /**
     * 返回光源裁剪渐变范围。<br/>
     * @return {Number}
     */

  }, {
    key: "getStepClip",
    value: function getStepClip() {
      return this._m_StepClip;
    }
    /**
     * 返回打包的内外角信息。<br/>
     * @return {Number}
     */

  }, {
    key: "getPackedAngleCos",
    value: function getPackedAngleCos() {
      return this._m_PackedAngleCos;
    }
    /**
     * 计算角度信息，打包内外角到一个变量中。<br/>
     */

  }, {
    key: "computeAngleParameters",
    value: function computeAngleParameters() {
      // 将内角放在1000之后的字节中
      // 将外角放在1000之内的字节中
      this._m_PackedAngleCos = Math.floor(this._m_InnerCorner * 1000); // 为了避免位数据不够
      // 这里的情况是,假设InnerCorner和OutCorner都是1.0,则此时是没有小数部分的
      // 为了能够将OuterCorner编码到小数部分,一种做法是对OuterCorner进行缩放0.1
      // 或者,在这里对其进行-0.001

      if (this._m_PackedAngleCos == Math.floor(this._m_OuterCorner * 1000)) {
        this._m_OuterCorner -= 0.001;
      }

      this._m_PackedAngleCos += this._m_OuterCorner * 1.0;
    }
    /**
     * 返回内外角余弦差。<br/>
     * @return {Number}
     */

  }, {
    key: "getInnerMinusOuter",
    value: function getInnerMinusOuter() {
      return this._m_InnerMinusOuter;
    }
    /**
     * 设置照射距离(0表示无限远)。<br/>
     * @param {Number}[spotRange]
     */

  }, {
    key: "setSpotRange",
    value: function setSpotRange(spotRange) {
      if (spotRange <= 0) {
        this._m_SpotRange = 0;
        this._m_InvSpotRange = 0;
      } else {
        this._m_SpotRange = spotRange;
        this._m_InvSpotRange = 1.0 / this._m_SpotRange;
      }
    }
    /**
     * 返回最远照射范围。<br/>
     * @return {Number}
     */

  }, {
    key: "getSpotRange",
    value: function getSpotRange() {
      return this._m_SpotRange;
    }
    /**
     * 返回最远照射范围倒数,用于加速计算。<br/>
     * @return {Number}
     */

  }, {
    key: "getInvSpotRange",
    value: function getInvSpotRange() {
      return this._m_InvSpotRange;
    }
    /**
     * 设置内角。<br/>
     * @param {Number}[innerAngle 弧度值]
     */

  }, {
    key: "setInnerAngle",
    value: function setInnerAngle(innerAngle) {
      this._m_InnerAngle = innerAngle;
      this._m_InnerCorner = Math.cos(this._m_InnerAngle);
      this._m_InnerMinusOuter = this._m_InnerCorner - this._m_OuterCorner;
      this.computeAngleParameters();
    }
    /**
     * 返回外角。<br/>
     * @return {Number|*}
     */

  }, {
    key: "getInnerAngle",
    value: function getInnerAngle() {
      return this._m_InnerAngle;
    }
    /**
     * 设置外角。<br/>
     * @param {Number}[outerAngle 弧度值]
     */

  }, {
    key: "setOuterAngle",
    value: function setOuterAngle(outerAngle) {
      this._m_OuterAngle = outerAngle;
      this._m_OuterCorner = Math.cos(this._m_OuterAngle);
      this._m_InnerMinusOuter = this._m_InnerCorner - this._m_OuterCorner;
      this.computeAngleParameters();
    }
    /**
     * 返回外角。<br/>
     * @return {Number|*}
     */

  }, {
    key: "getOuterAngle",
    value: function getOuterAngle() {
      return this._m_OuterAngle;
    }
    /**
     * 设置位置。<br/>
     * @param {Vector3}[position]
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this._m_Position.setTo(position);
    }
    /**
     * 设置位置。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setPositionXYZ",
    value: function setPositionXYZ(x, y, z) {
      this._m_Position.setToInXYZ(x, y, z);
    }
    /**
     * 返回位置。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getPosition",
    value:
    /**
     * 返回位置。<br/>
     * @return {Vector3}
     */
    function getPosition() {
      return this._m_Position;
    }
    /**
     * 设置方向。<br/>
     * @param {Vector3}[direction]
     */

  }, {
    key: "setDirection",
    value: function setDirection(direction) {
      this._m_Direction.setTo(direction); // 提前normal,以便shader减少normal操作


      this._m_Direction.normal();
    }
    /**
     * 设置方向。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setDirectionXYZ",
    value: function setDirectionXYZ(x, y, z) {
      this._m_Direction.setToInXYZ(x, y, z).normal();
    }
    /**
     * 返回方向。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getDirection",
    value: function getDirection() {
      return this._m_Direction;
    }
  }, {
    key: "getBoundingVolume",
    value: function getBoundingVolume() {
      // 因为这一阶段只是快速剔除，如果使用OBB计算光锥剔除，则显得有点浪费
      // 对于无限远的聚光,直接渲染,无需剔除
      if (this._m_SpotRange == 0) return null; // 对于有限聚光灯,使用球体包围盒快速剔除

      if (this._m_UpdateBoundingVolume) {
        if (!this._m_BoudingVolume) {
          // 对于PointLight,创建包围球
          this._m_BoudingVolume = new _BoundingSphere.default();
        }

        var lr = this._m_SpotRange * 0.5;
        var center = _TempVars.default.S_TEMP_VEC3_2;

        this._m_Direction.multLength(this._m_SpotRange * 0.5, center).add(this._m_Position);

        var lr2 = this._m_SpotRange * Math.tan(this._m_OuterCorner);

        this._m_BoudingVolume.setCenter(center);

        this._m_BoudingVolume.setRaiuds(Math.max(lr, lr2));

        this._m_UpdateBoundingVolume = false;
      }

      return this._m_BoudingVolume;
    }
  }]);

  return SpotLight;
}(_Light2.default);

exports["default"] = SpotLight;

/***/ }),

/***/ 4008:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _SubShader = _interopRequireDefault(__webpack_require__(2603));

var _Technology = _interopRequireDefault(__webpack_require__(2768));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _FrameBuffer = _interopRequireDefault(__webpack_require__(7341));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * 材质定义，材质定义定义了相关物体渲染时的着色材质属性，通过MaterialShaderSource完成对材质的实现。<br/>
 * @author Kkk
 * @date 2020年12月25日8点25分
 * @lastdata 2021年3月17日15点27分
 */
var Material = /*#__PURE__*/function (_Component) {
  _inherits(Material, _Component);

  var _super = _createSuper(Material);

  /**
   * 创建一个材质实例。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   * @param {MaterialDef}[cfg.materialDef]
   */
  function Material(owner, cfg) {
    var _this;

    _classCallCheck(this, Material);

    _this = _super.call(this, owner, cfg); // // 根据当前材质类型获取对应的着色器源码定义，并生成对应的着色器程序
    // this._m_MaterialSource = new SubShaderSource(cfg.materialSourceDef);
    // // 根据materialShaderSource,创建着色器程序,然后根据材质定义,获取着色器变量
    // this._m_ShaderProgram = new ShaderProgram(this._m_Scene.getCanvas().getGLContext(), this._m_MaterialSource.getShaderSource());
    // 材质参数

    _this._m_Params = {}; // 参数值列表

    _this._m_ParamValues = {}; // 可定义材质参数

    _this._m_CanDefineParams = {}; // 已定义材质参数

    _this._m_AleadyDefinedParams = {}; // 发生变化的材质参数值

    _this._m_ChangeParams = [];

    _this._init(); // 记录当前激活的subShader


    _this._m_CurrentSubShader = null; // 记录不同路径中的Shader
    // key:TechnologyName,value:Technology

    _this._m_RenderTechnologys = {}; // 当前实用的技术

    _this._m_CurrentTechnology = null; // 解析材质定义

    if (cfg.materialDef) {
      (function () {
        var gl = _this._m_Scene.getCanvas().getGLContext(); // 获取技术块


        var materialDef = cfg.materialDef; // 开始解析

        var mp = materialDef.getParams();

        for (var p in mp) {
          // 默认所有参数值为null
          _this._m_ParamValues[mp[p].getName()] = null;
          _this._m_Params[mp[p].getName()] = true;
          _this._m_CanDefineParams[mp[p].getName()] = true;
        }

        var subShaderDefs = materialDef.getSubShaderDefs();
        var subShaders = {};

        for (var sS in subShaderDefs) {
          _this._initGlobals(materialDef, subShaderDefs[sS]);

          subShaders[subShaderDefs[sS].getName()] = new _SubShader.default(gl, cfg.frameContext || _this._m_Scene.getRender().getFrameContext(), subShaderDefs[sS]);
        }

        var technologyDefs = materialDef.getTechnologyDefs();
        var technologyDef = null;
        var rpSubPass = null;
        var subPass = null;

        for (var tE in technologyDefs) {
          technologyDef = technologyDefs[tE];
          _this._m_RenderTechnologys[technologyDef.getName()] = new _Technology.default(technologyDef.getName());
          rpSubPass = technologyDef.getSubPass();

          var _loop = function _loop(renderPath) {
            subPass = rpSubPass[renderPath];
            subPass.forEach(function (sub) {
              sub.getPass().forEach(function (pass) {
                // 这里,原本的思路是直接建立renderPath->subShader[]
                // 但是为了完整性,这里使用了renderPath->subPass(包含一个subShader[])
                // 其中每个subShader可以指定使用的FB
                _this._m_RenderTechnologys[technologyDef.getName()].addSubPass(renderPath, subShaders[pass.pass.getName()], pass.renderState);
              }); // this._m_RenderTechnologys[technologyDef.getName()].addSubShader(renderPath, subShaders[sub.pass.getName()]);
            });
          };

          for (var renderPath in rpSubPass) {
            _loop(renderPath);
          }
        } // 设置默认技术


        _this.selectTechnology(_this._m_Scene.getRender().getPriorityTechnology());
      })();
    } else {
      // 错误
      console.log("找不到materialDef...");
    }

    return _this;
  }
  /**
   * 创建指定附件。<br/>
   * @param {WebGL}[gl]
   * @param {FrameBuffer}[gfb]
   * @param {String}[type]
   * @param {String}[name]
   * @param {Number}[loc]
   * @private
   */


  _createClass(Material, [{
    key: "getType",
    value: function getType() {
      return "Material";
    }
  }, {
    key: "_newAtc",
    value: function _newAtc(gl, gfb, type, name, loc) {
      // 暂时只处理这两种
      if (type == 'color') {
        gfb.addTexture(gl, name, gl.RGBA, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.COLOR_ATTACHMENT0 + Number(loc), true);
      } else if (type == 'depth24_stencil8') {
        gfb.addBuffer(gl, name, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
      }
    }
    /**
     * 初始化全局变量,以便在整个渲染上下文中共享可访问的块。<br/>
     * @param {MaterialDef}[materialDef]
     * @private
     */

  }, {
    key: "_initGlobals",
    value: function _initGlobals(materialDef) {
      var frameContext = this._m_Scene.getRender().getFrameContext();

      var globals = materialDef.getGlobals();

      var gl = this._m_Scene.getCanvas().getGLContext();

      var loc = null,
          fun = null;

      var w = this._m_Scene.getCanvas().getWidth();

      var h = this._m_Scene.getCanvas().getHeight();

      for (var global in globals) {
        if (!frameContext.getFrameBuffer(global)) {
          var gf = globals[global];
          var gfb = new _FrameBuffer.default(gl, global, w, h);
          frameContext.addFrameBuffer(global, gfb);

          if (gf) {
            for (var atc in gf) {
              gf[atc][0].type;

              if (gf[atc].length > 1) {
                this._newAtc(gl, gfb, gf[atc][1].type, gf[atc][1].name, gf[atc][1].loc);
              } else if (gf[atc].length > 0) {
                this._newAtc(gl, gfb, gf[atc][0].type, gf[atc][0].name);
              } else {
                _Log.default.log('错误的atc!');
              }
            }

            gfb.finish(gl, this._m_Scene, true);
          }

          _Log.default.log('create global ' + global);
        }
      }
    }
    /**
     * 返回指定的渲染技术。<br/>
     * @param {String}[renderPathType]
     * @return {Technology}
     */

  }, {
    key: "getRenderTechnology",
    value: function getRenderTechnology(renderPathType) {
      return this._m_RenderTechnologys.get(renderPathType);
    }
    /**
     * 添加一个技术。<br/>
     * @param {String}[technologyName 技术名称]
     * @param {String}[technology 技术]
     */

  }, {
    key: "addTechnology",
    value: function addTechnology(technologyName, technology) {
      this._m_RenderTechnologys[technologyName] = technology;
    }
    /**
     * 选中指定技术作为该材质渲染。<br/>
     * @param {String}[technologyName Technology名称]
     */

  }, {
    key: "selectTechnology",
    value: function selectTechnology(technologyName) {
      var _this2 = this;

      if (this._m_CurrentTechnology != null && this._m_RenderTechnologys[technologyName] == this._m_CurrentTechnology) return;
      var lastTechnology = this._m_CurrentTechnology;
      var p = this._m_CurrentTechnology != null;
      this._m_CurrentTechnology = this._m_RenderTechnologys[technologyName];

      if (this._m_CurrentTechnology == null) {
        this._m_CurrentTechnology = lastTechnology != null ? lastTechnology : this._m_RenderTechnologys[''];
      } // 如果是第一次创建Technology,则不需要进行参数定义重设
      // 否则,在切换技术时,需要检测是否需要参数定义重设
      // 另外，不需要保存每个technology是否重设过参数定义，因为AleadyDefinedParams随时可能发生变更，会导致已经定义的technology仍然可能缺少最新的参数定义，所以
      // 只要切换technology，并且不是该Material的首个Technology，就执行一次参数定义重设检测
      // 不必担心重复定义，因为subShader.addDefine()内部会进行剔除


      if (p) {
        var subPass = null;

        var _loop2 = function _loop2(paramName) {
          for (var _p in _this2._m_CurrentTechnology.getSubPassList()) {
            subPass = _this2._m_CurrentTechnology.getSubPasss(_p);
            subPass.getSubShaders().forEach(function (sb) {
              sb.subShader.addDefine(paramName);
            });
          }
        };

        for (var paramName in this._m_AleadyDefinedParams) {
          _loop2(paramName);
        }
      }
    }
    /**
     * 返回当前选中的技术。<br/>
     * @return {Technology}
     */

  }, {
    key: "getCurrentTechnology",
    value: function getCurrentTechnology() {
      return this._m_CurrentTechnology;
    }
    /**
     * 预加载材质。<br/>
     */

  }, {
    key: "preload",
    value: function preload() {
      var _this3 = this;

      var subPassList = this.getCurrentTechnology().getSubPassList();

      if (subPassList) {
        (function () {
          var subPasss = null;
          var currentSubShader = null;

          var gl = _this3._m_Scene.getCanvas().getGLContext();

          var frameContext = _this3._m_Scene.getRender().getFrameContext();

          for (var path in subPassList) {
            subPasss = subPassList[path];
            subPasss.getSubShaders().forEach(function (subPass) {
              if (subPass.subShader.needCompile()) {
                subPass.subShader._compile(gl, frameContext); // 然后提交参数

              }
            });
          }
        })();
      }
    }
    /**
     * 使用指定subShader进行材质着色。<br/>
     * @param {SubShader}[subShader]
     */

  }, {
    key: "_selectSubShader",
    value: function _selectSubShader(subShader) {
      var _this4 = this;

      var change = false;
      this._m_CurrentSubShader = subShader;

      var gl = this._m_Scene.getCanvas().getGLContext();

      var frameContext = this._m_Scene.getRender().getFrameContext(); // 检测是否需要重新编译subShader


      if (this._m_CurrentSubShader.needCompile()) {
        this._m_CurrentSubShader._compile(gl, frameContext);
      } // 1.先检测是否需要切换subShader(根据shader种类)(这里检测可能与理论不一样，打印出id来调试...)


      if (frameContext.m_LastSubShaderId != subShader.getDefId()) {
        // 切换
        subShader.use(gl);
        frameContext.m_LastSubShaderId = subShader.getDefId();
        frameContext.m_LastMaterial = this;
        frameContext.m_SM++;
        change = true;
      } // 2.检测是否需要更新参数到subShader中(同种类型subShaderId,但存在不同具体实力化subShader对象,所以参数不同需要更新)


      if (frameContext.m_LastSubShader != subShader) {
        frameContext.m_LastSubShader = subShader;
        frameContext.m_SS++; // Log.log('切换!');
        // 先检查材质值

        for (var n in this._m_ParamValues) {
          // 有些参数值为null
          if (this._m_ParamValues[n]) {
            // 提交参数
            this._m_CurrentSubShader.uploadParam(gl, n, this._m_ParamValues[n]);
          }
        }
      } // 检查最新数据值


      if (this._m_ChangeParams.length > 0) {
        this._m_ChangeParams.forEach(function (param) {
          // 检测是否需要更新该参数
          if (_this4._m_ParamValues[param.paramName]) {
            // 如果值相同就跳过
            if (!_this4._m_ParamValues[param.paramName].compare(param.value)) {
              // 提交参数并保存参数
              _this4._m_CurrentSubShader.uploadParam(gl, param.paramName, param.value);

              _this4._m_ParamValues[param.paramName] = param.value;
            }
          } else {
            // 提交参数并保存参数
            _this4._m_CurrentSubShader.uploadParam(gl, param.paramName, param.value);

            _this4._m_ParamValues[param.paramName] = param.value;
          }
        });

        this._m_ChangeParams.length = 0;
      }

      return change;
    }
    /**
     * 初始化。<br/>
     * 这个函数暂时作废。<br/>
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {// let gl = this._m_Scene.getCanvas().getGLContext();
      // this.use();
      // let mI = gl.getUniformLocation(this._m_ShaderProgram.getProgram(), "modelMatrix");
      // gl.uniformMatrix4fv(mI, false, new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
      // let ubi = gl.getUniformBlockIndex(this._m_ShaderProgram.getProgram(), "VP");
      // gl.uniformBlockBinding(this._m_ShaderProgram.getProgram(), ubi, 0x001);
      // gl.useProgram(null);
    }
    /**
     * 设置参数。<br/>
     * @param {String}[paramName 参数名]
     * @param {Vars}[value 参数值]
     */

  }, {
    key: "setParam",
    value: function setParam(paramName, value) {
      var _this5 = this;

      // 检测是否有效参数
      if (this._m_Params[paramName]) {
        // 检测是否已经定义
        var update = false;

        if (!this._m_AleadyDefinedParams[paramName]) {
          update = true;
          this._m_AleadyDefinedParams[paramName] = true;
        }

        if (update) {
          // 定义该参数
          // 重新构建当前技术所有SubShader块
          var subPass = null;

          var _loop3 = function _loop3(_paramName) {
            for (var p in _this5._m_CurrentTechnology.getSubPassList()) {
              subPass = _this5._m_CurrentTechnology.getSubPasss(p);
              subPass.getSubShaders().forEach(function (sb) {
                sb.subShader.addDefine(_paramName);
              });
            }
          };

          for (var _paramName in this._m_AleadyDefinedParams) {
            _loop3(_paramName);
          }
        } // 检测是否存在已有参数(这里直接使用遍历,后续可改进,不过因为实时渲染阶段很少大规模调整参数,所以即使遍历也仅仅影响预加载阶段)


        var needAdd = true;

        if (this._m_ChangeParams.length > 0) {
          var p = null;

          for (var i = 0; i < this._m_ChangeParams.length; i++) {
            if (this._m_ChangeParams[i].paramName == paramName) {
              this._m_ChangeParams[i].value = value;
              needAdd = false;
              break;
            }
          }
        } // 将其加入参数列表


        value.owner(this, paramName);

        if (needAdd) {
          this._m_ChangeParams.push({
            paramName: paramName,
            value: value
          });
        }
      }
    }
    /**
     * 清楚一个参数。<br/>
     * @param {String}[paramName]
     */

  }, {
    key: "clearParams",
    value: function clearParams(paramName, value) {
      // 待实现
      // 检测是否有效参数
      if (this._m_Params[paramName]) {
        // 检测是否已经定义
        var update = false;

        if (this._m_AleadyDefinedParams[paramName]) {
          update = true; // this._m_AleadyDefinedParams[paramName] = false;

          delete this._m_AleadyDefinedParams[paramName];
        }

        if (update) {
          // 清除该参数
          // 重新构建当前技术所有SubShader块
          var subPass = null;

          for (var p in this._m_CurrentTechnology.getSubPassList()) {
            subPass = this._m_CurrentTechnology.getSubPasss(p);
            subPass.getSubShaders().forEach(function (sb) {
              sb.subShader.clearDefine(paramName);
            });
          }
        } // 将其移除参数列表


        this._m_ParamValues[paramName].unowner(this);
      }
    }
    /**
     * 添加一个定义。<br/>
     * @param {String}[name]
     * @param {Boolean}[globalRefresh]
     */

  }, {
    key: "addDefine",
    value: function addDefine(name, globalRefresh) {
      var _this6 = this;

      var update = false;

      if (!this._m_AleadyDefinedParams[name]) {
        update = true;
        this._m_AleadyDefinedParams[name] = true;
      }

      if (update) {
        // 定义该参数
        // 重新构建当前技术所有SubShader块
        var subPass = null;

        var _loop4 = function _loop4(paramName) {
          for (var p in _this6._m_CurrentTechnology.getSubPassList()) {
            subPass = _this6._m_CurrentTechnology.getSubPasss(p);
            subPass.getSubShaders().forEach(function (sb) {
              sb.subShader.addDefine(paramName, name == paramName && _ShaderSource.default.Context_Data[name] != null, globalRefresh);
            });
          }
        };

        for (var paramName in this._m_AleadyDefinedParams) {
          _loop4(paramName);
        }
      }
    }
    /**
     * 清除一个定义。<br/>
     * @param {String}[name]
     * @param {Boolean}[globalRefresh]
     */

  }, {
    key: "clearDefine",
    value: function clearDefine(name, globalRefresh) {
      var _this7 = this;

      // 待实现
      var update = false;

      if (this._m_AleadyDefinedParams[name]) {
        update = true;
        this._m_AleadyDefinedParams[name] = false;
      }

      if (update) {
        // 定义该参数
        // 重新构建当前技术所有SubShader块
        var subPass = null;

        var _loop5 = function _loop5(paramName) {
          for (var p in _this7._m_CurrentTechnology.getSubPassList()) {
            subPass = _this7._m_CurrentTechnology.getSubPasss(p);
            subPass.getSubShaders().forEach(function (sb) {
              if (name == paramName) {
                sb.subShader.clearDefine(paramName, name == paramName && _ShaderSource.default.Context_Data[name] != null, globalRefresh);
              }
            });
          }
        };

        for (var paramName in this._m_AleadyDefinedParams) {
          _loop5(paramName);
        }
      }
    }
  }]);

  return Material;
}(_Component2.default);

exports["default"] = Material;

/***/ }),

/***/ 8113:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(9650));

var _AssetLoader = _interopRequireDefault(__webpack_require__(1193));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _SubShaderDef = _interopRequireDefault(__webpack_require__(4974));

var _TechnologyDef = _interopRequireDefault(__webpack_require__(8173));

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Block = /*#__PURE__*/function () {
  /**
   * 块数据包含。
   * @param {String}[type 块类型]
   * @param {String}[id 块id]
   * @param {String[]}[data 字符串串数组]
   * @param {Number}[start 块开始索引]
   * @param {Number}[end 块结束索引]
   */
  function Block(type, id, data, start, end) {
    _classCallCheck(this, Block);

    this.m_Type = type;
    this.m_Id = id;
    this.m_Data = data;
    this.m_Start = start;
    this.m_End = end;
    this.m_SubBlock = [];
  }

  _createClass(Block, [{
    key: "getName",
    value: function getName() {
      return this.m_Id;
    }
  }, {
    key: "getType",
    value: function getType() {
      return this.m_Type;
    }
  }, {
    key: "addSubBlock",
    value: function addSubBlock(subBlock) {
      this.m_SubBlock.push(subBlock);
    }
  }, {
    key: "getSubBlock",
    value: function getSubBlock() {
      return this.m_SubBlock;
    }
  }, {
    key: "setStart",
    value: function setStart(start) {
      this.m_Start = start;
    }
  }, {
    key: "getStart",
    value: function getStart() {
      return this.m_Start;
    }
  }, {
    key: "setEnd",
    value: function setEnd(end) {
      this.m_End = end;
    }
  }, {
    key: "getEnd",
    value: function getEnd() {
      return this.m_End;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.m_Data;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "type:" + this.m_Type + "\n" + "" + "id:" + this.m_Id + "\n" + "data:\n" + this.m_Data + "\n";
    }
  }]);

  return Block;
}();

var Param = /*#__PURE__*/function () {
  function Param() {
    _classCallCheck(this, Param);

    this.m_Name = null;
    this.m_Type = null;
    this.m_DefaultValue = null;
    this.m_Pattern = null;
    this.m_Pattern2 = null;
    this.m_TagPattern = null;
    this.m_DefType = null;
  }

  _createClass(Param, [{
    key: "creator",
    value: function creator() {
      this.m_Pattern = eval("/Params." + this.m_Name + "/");
      this.m_Pattern2 = eval("/Params." + this.m_Name + "[\\s+-;.,\\*\\\\]{1,}/");
      this.m_TagPattern = eval("/Params." + this.m_Name + "/g");
      this.m_DefType = "" + this.m_Name;
    }
  }, {
    key: "getDefType",
    value: function getDefType() {
      return this.m_DefType;
    }
  }, {
    key: "getPattern",
    value: function getPattern() {
      return this.m_Pattern;
    }
  }, {
    key: "getPattern2",
    value: function getPattern2() {
      return this.m_Pattern2;
    }
  }, {
    key: "getTagPattern",
    value: function getTagPattern() {
      return this.m_TagPattern;
    }
  }, {
    key: "setName",
    value: function setName(name) {
      this.m_Name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.m_Name;
    }
  }, {
    key: "setType",
    value: function setType(type) {
      this.m_Type = type;
    }
  }, {
    key: "getType",
    value: function getType() {
      return this.m_Type;
    }
  }, {
    key: "setDefaultValue",
    value: function setDefaultValue(defaultValue) {
      this.m_DefaultValue = defaultValue;
    }
  }, {
    key: "getDefaultVaule",
    value: function getDefaultVaule() {
      return this.m_DefaultValue;
    }
  }]);

  return Param;
}();

var SubTechnology = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {
  function SubTechnology() {
    _classCallCheck(this, SubTechnology);

    this.m_Name = null;
    this.m_Shaders = {};
  }

  _createClass(SubTechnology, [{
    key: "setName",
    value: function setName(name) {
      this.m_Name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.m_Name;
    }
  }, {
    key: "addShader",
    value: function addShader(type, shader) {
      this.m_Shaders[type] = shader;
    }
  }, {
    key: "getShaders",
    value: function getShaders() {
      return this.m_Shaders;
    }
  }]);

  return SubTechnology;
}()));

var SubPassDef = /*#__PURE__*/function () {
  function SubPassDef(path) {
    _classCallCheck(this, SubPassDef);

    this.m_RenderPath = path; // {name:passName,renderState:{}}

    this.m_Pass = []; // 设置该SubShaderDef来自哪个MaterialDef

    this._m_FromMaterialDef = null;
  }

  _createClass(SubPassDef, [{
    key: "addPass",
    value: function addPass(pass, renderState) {
      this.m_Pass.push({
        pass: pass,
        renderState: renderState
      });
    }
  }, {
    key: "getPass",
    value: function getPass() {
      return this.m_Pass;
    }
    /**
     * 设置该SubShaderDef来自哪个MaterialDef。<br/>
     * @param {MaterialDef}[materialDef]
     */

  }, {
    key: "setFromMaterialDef",
    value: function setFromMaterialDef(materialDef) {
      this._m_FromMaterialDef = materialDef;
    }
    /**
     * 返回当前所属得MaterialDef。<br/>
     * @returns {MaterialDef}[materialDef]
     */

  }, {
    key: "getFromMaterialDef",
    value: function getFromMaterialDef() {
      return this._m_FromMaterialDef;
    }
  }]);

  return SubPassDef;
}();
/**
 * 材质定义。<br/>
 * 将材质解析并生成实际材质定义的主体逻辑。<br/>
 * @author Kkk
 * @date 2021年1月12日10点26分
 * @lastdate 2021年3月16日13点57分
 */


var MaterialDef = /*#__PURE__*/function () {
  function MaterialDef(name) {
    _classCallCheck(this, MaterialDef);

    // 解析
    // 材质名称
    this._m_Name = name; // 全局参数

    this._m_Globals = {}; // 材质参数(元素类型Param)

    this._m_Params = {}; // subShaderDefs

    this._m_SubShaderDefs = {}; // technology

    this._m_TechnologyDefs = {}; // 当前引用的所有fb
    // key:fbId,value:fbDef(在创建Material时,才真正创建fb)

    this._m_FBs = {};
  }

  _createClass(MaterialDef, [{
    key: "addSubShaderDef",
    value: function addSubShaderDef(name, subShaderDef) {
      this._m_SubShaderDefs[name] = subShaderDef;
      subShaderDef.setFromMaterialDef(this);
    }
  }, {
    key: "getSubShaderDef",
    value: function getSubShaderDef(name) {
      return this._m_SubShaderDefs[name];
    }
  }, {
    key: "getSubShaderDefs",
    value: function getSubShaderDefs() {
      return this._m_SubShaderDefs;
    }
  }, {
    key: "addTechnologyDef",
    value: function addTechnologyDef(name, technologyDef) {
      this._m_TechnologyDefs[name] = technologyDef;
      technologyDef.setFromMaterialDef(this);
    }
  }, {
    key: "getTechnologyDef",
    value: function getTechnologyDef(name) {
      return this._m_TechnologyDefs[name];
    }
  }, {
    key: "getTechnologyDefs",
    value: function getTechnologyDefs() {
      return this._m_TechnologyDefs;
    }
  }, {
    key: "addParam",
    value: function addParam(param) {
      this._m_Params[param.getName()] = param;
    }
  }, {
    key: "getParams",
    value: function getParams() {
      return this._m_Params;
    }
  }, {
    key: "getGlobalInner",
    value: function getGlobalInner(type) {
      if (type.indexOf('color') > -1) {
        return 'color';
      } else if (type.indexOf('depth24_stencil8') > -1) {
        return 'depth24_stencil8';
      } else if (type.indexOf('depth') > -1) {
        return 'depth';
      } else if (type.indexOf('stencil') > -1) {
        return 'stencil';
      }
    }
  }, {
    key: "addGlobal",
    value: function addGlobal(name, type, dataType, varName) {
      // 布局如下:
      // name->
      //      varName->
      //              type
      if (!this._m_Globals[name]) {
        this._m_Globals[name] = {};
      }

      var pName = varName;
      varName = "_" + name + varName;
      this._m_Globals[name][varName] = [];
      var innerType = this.getGlobalInner(type);
      var t = type.indexOf('color');

      if (t > -1) {
        // in部分
        this._m_Globals[name][varName].push({
          type: innerType,
          dataType: 'uniform sampler2D',
          refName: name,
          name: varName,
          pattern: eval("/Globals" + name + ".In" + pName + "/"),
          pattern2: eval("/Globals" + name + ".In" + pName + "[\\s+-;.,\\*\\\\]{1,}/"),
          tagPattern: eval("/Globals" + name + ".In" + pName + "/g")
        });

        var loc = type.substring(t + 5, type.length);

        _Log.default.log('loc:' + loc); // 获取附件计数
        // out部分


        this._m_Globals[name][varName].push({
          type: innerType,
          dataType: dataType,
          loc: loc,
          refName: name,
          name: varName,
          pattern: eval("/Globals" + name + ".Out" + pName + "/"),
          pattern2: eval("/Globals" + name + ".Out" + pName + "[\\s+-;.,\\*\\\\]{1,}/"),
          tagPattern: eval("/Globals" + name + ".Out" + pName + "/g")
        });
      } else {
        this._m_Globals[name][varName].push({
          type: innerType,
          dataType: dataType,
          refName: name,
          name: varName,
          pattern: eval("/Globals" + name + ".In" + pName + "/"),
          pattern2: eval("/Globals" + name + ".In" + pName + "[\\s+-;.,\\*\\\\]{1,}/"),
          tagPattern: eval("/Globals" + name + ".In" + pName + "/g")
        });
      }
    }
  }, {
    key: "getGlobals",
    value: function getGlobals() {
      return this._m_Globals;
    }
  }, {
    key: "setName",
    value: function setName(name) {
      this._m_Name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
  }], [{
    key: "load",
    value: function load(src) {
      return MaterialDef.parse(_AssetLoader.default.loadMaterialSourceDef(src));
    }
  }, {
    key: "trim",
    value: function trim(str) {
      return str.replace(/(^\s*)|(\s*$)/g, "");
    }
  }, {
    key: "parseGlobals",
    value: function parseGlobals(matDef, blockDef) {
      var name = blockDef.getName(); // Log.log('name = ' + name);

      var data = blockDef.getData();
      var line = null;
      var attach = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i];
        line = _Tools.default.trim(line);
        line = line.substring(0, line.length - 1).split(" ");
        matDef.addGlobal(name, line[0], line[1], line[2]); // if(!ShaderSource.Context_RenderDataRefFBs[line[0]]){
        //     ShaderSource.Context_RenderDataRefFBs[line[0]] = name;
        // }
        // else if(ShaderSource.Context_RenderDataRefFBs[line[0]] != name){
        //     Log.error("错误的匹配[[" + ShaderSource.Context_RenderDataRefFBs[line[0]] + "]]与[[" + name + "]]");
        // }
      }
    }
    /**
     * 解析材质参数块。<br/>
     * @param {MaterialDef}[matDef 结果材质定义]
     * @param {Block}[blockDef 定义块]
     */

  }, {
    key: "parseParams",
    value: function parseParams(matDef, blockDef) {
      // 解析材质参数
      var data = blockDef.getData();
      var line = null;
      var param = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i]; // 按空格分割(去掉最后的;号)

        line = _Tools.default.trim(line);
        if (line.startsWith("//")) continue;
        line = line.substring(0, line.length - 1).split(" ");
        param = new Param();
        param.setName(line[1]);
        param.setType(line[0]);
        param.creator();

        if (line.length > 2) {
          // 默认值
          param.setDefaultValue(line[3]);
        }

        matDef.addParam(param);
      }
    }
    /**
     * 解析SubTechnology。<br/>
     * @param {SubShaderDef}[subShaderDef 结果材质定义]
     * @param {Block}[blockDef 定义块]
     */

  }, {
    key: "parseSubTechnology",
    value: function parseSubTechnology(subShaderDef, blockDef) {
      // 解析SubTechnology的vars部分
      var data = blockDef.data;
      var line = null; // blockDef.getSubBlock().forEach(subBlockDef=>{
      //     MaterialDef.parseBlockDef(subShaderDef, subBlockDef);
      // });
    }
  }, {
    key: "parseShader",
    value: function parseShader(subShaderDef, blockDef) {
      // 检测vsShader的所有块定义
      blockDef.getSubBlock().forEach(function (subBlock) {
        // 解析子块
        MaterialDef.parseBlockDef(subShaderDef, subBlock);
      });
    }
  }, {
    key: "parseShaderVars",
    value: function parseShaderVars(subShaderDef, blockDef) {
      var data = blockDef.getData();
      var line = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i];
        line = _Tools.default.trim(line);
        if (line.startsWith("//")) continue;
        line = line.substring(0, line.length - 1);
        line = line.split(" ");
        subShaderDef.addVar(line[0], line[1]);
      }
    }
  }, {
    key: "parseAdvanced",
    value: function parseAdvanced(subShaderDef, blockDef) {
      var data = blockDef.getData();
      var line = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i];
        line = _Tools.default.trim(line);
        if (line.startsWith("//")) continue;
        line = line.substring(0, line.length - 1);
        line = line.split(" "); // 指定渲染程序

        if (line[0].startsWith("RenderProgram")) {
          subShaderDef.setRenderProgramType(line[1]);
        }
      }
    }
  }, {
    key: "parseVsShader",
    value: function parseVsShader(subShaderDef, blockDef) {
      var data = blockDef.getData();
      var line = null;
      var shader = "";
      var useContexts = [];
      var useVars = [];
      var varTable = subShaderDef.getVarTable();
      var params = subShaderDef.getFromMaterialDef().getParams();
      var param = null;
      var useParam = false;
      var useParams = [];
      var conParams = {};
      var conContexts = {};
      var conVars = {};

      var _loop = function _loop(i) {
        line = _Tools.default.trim(data[i]);
        if (line.startsWith("//")) return "continue";
        var p = null;
        var pr = -1;
        var pr2 = -1;
        var prsult = null; // 检测变量列表

        varTable.forEach(function (vars) {
          pr = _Tools.default.find2(line, vars.pattern);

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, vars.pattern2);

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].name.length < vars.name.length) {
                prsult[pr] = vars;
              }
            } else {
              prsult[pr] = vars;
            }
          }
        });

        if (prsult) {
          for (var _pr in prsult) {
            p = prsult[_pr];

            if (!conVars[p.name]) {
              conVars[p.name] = true;
              useVars.push(p);
            }
          }
        }

        p = null;
        pr = -1;
        pr2 = -1;
        prsult = null;

        for (var _k in params) {
          param = params[_k]; // Tools.find()匹配有bug
          // 为了确保完全匹配最长的那个,暂时先这么处理

          pr = _Tools.default.find2(line, param.getPattern());

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, param.getPattern2());

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].getName().length < param.getName().length) {
                prsult[pr] = param;
              }
            } else {
              prsult[pr] = param;
            }
          }
        }

        if (prsult) {
          for (var _pr2 in prsult) {
            p = prsult[_pr2];

            if (!conParams[p.getName()]) {
              // 记录使用的材质参数
              useParams.push(p);
              conParams[p.getName()] = true;
            } // 设置材质参数


            line = _Tools.default.repSrc(line, p.getPattern(), p.getTagPattern(), p.getName());
            useParam = true;
          }
        } // 检测上下文列表


        var context = null;
        prsult = null;

        for (var _k2 in _ShaderSource.default.Context_Data) {
          context = _ShaderSource.default.Context_Data[_k2];
          if (context.pattern == null) continue;
          pr = _Tools.default.find2(line, context.pattern);

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, context.pattern2);

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].src.length < context.src.length) {
                prsult[pr] = context;
              }
            } else {
              prsult[pr] = context;
            }
          }

          if (prsult) {
            for (var _pr3 in prsult) {
              context = prsult[_pr3]; // 记录该vsShader使用的context

              if (!conContexts[context.src]) {
                if (context.isFlagVariable) {
                  subShaderDef.addContextDefine(_ShaderSource.default.VERTEX_SHADER, context.src);
                } else {
                  conContexts[context.src] = true;
                  useContexts.push(context);
                }
              } // 替换指定上下文


              line = _Tools.default.repSrc(line, context.pattern, context.tagPattern, context.tag);
            }
          }
        }

        shader += _Tools.default.trim(line) + '\n';
      };

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      } // 添加材质参数


      if (useParam) {
        subShaderDef.addUseParams(_ShaderSource.default.VERTEX_SHADER, useParams);
        var inParams = "\n";

        for (var k in useParams) {
          param = useParams[k]; // 添加参数
          // inParams += "#ifdef " + param.getDefType() + "\n";

          inParams += "uniform " + param.getType() + " " + param.getName() + ";\n"; // inParams += "#endif\n";
        }

        shader = inParams + shader;
      } // 检测shader是否需要添加变量


      if (useVars.length > 0) {
        // 加入变量块
        var outVars = "\n";
        useVars.forEach(function (vars) {
          outVars += "out " + vars.type + " " + vars.name + ";\n";
        });
        shader = outVars + shader;
      } // 检查context是否包含需要的几何属性


      if (useContexts.length > 0) {
        var BLOCKS = {};
        var useBlocks = [];
        subShaderDef.addUseContexts(useContexts);
        var vertIn = "\n";
        useContexts.forEach(function (context) {
          if (context.loc != null || context.loc != undefined) {
            vertIn += "layout (location=" + context.loc + ") in " + context.type + " " + context.src + ";\n";
          } else if (context.def) {
            if (!BLOCKS[context.def]) {
              useBlocks.push(context.def);
            } // 块定义


            BLOCKS[context.def] = context.def;
          } else if (context.utype) {
            vertIn += context.utype + " " + context.src;

            if (context.modifier) {
              vertIn += context.modifier;
            }

            vertIn += ";\n";
          } else if (context.type) {
            vertIn += context.type + " " + context.src + ";\n";
          }
        });
        subShaderDef.addUseBlocks(useBlocks); // 检测块部分

        for (var b in BLOCKS) {
          // 定义块
          vertIn = vertIn + _ShaderSource.default.BLOCKS[b].blockDef;
        }

        shader = vertIn + shader;
      }

      shader = '#version 300 es\n' + shader; // 添加shader

      subShaderDef.addShaderSource(_ShaderSource.default.VERTEX_SHADER, shader);
    }
  }, {
    key: "parseVsShaderFun",
    value: function parseVsShaderFun(subShaderDef, blockDef) {// 解析VsShader的其他函数
      // 单独定义parseFsShaderFun和parseVsShaderFun的目的在于,Fs和Vs对于某些变量的插入定义是不同的,所以最好单独进行
      // 比如对layout变量,vs是in而fs是out
    }
  }, {
    key: "parseVsShaderMain",
    value: function parseVsShaderMain(subShaderDef, blockDef) {
      var data = blockDef.getData();
      var line = null;
      var shader = "void main(){\n";
      var useContexts = [];
      var useVars = [];
      var varTable = subShaderDef.getVarTable();
      var params = subShaderDef.getFromMaterialDef().getParams();
      var param = null;
      var useParam = false;
      var useParams = [];
      var conParams = {};
      var conContexts = {};
      var conVars = {};

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = _Tools.default.trim(data[i]);
        if (line.startsWith("//")) continue; // 检测变量列表

        varTable.forEach(function (vars) {
          if (_Tools.default.find(line, vars.pattern)) {
            if (!conVars[vars.name]) {
              conVars[vars.name] = true;
              useVars.push(vars);
            }
          }
        }); // 检测材质参数列表

        for (var k in params) {
          param = params[k];

          if (_Tools.default.find(line, param.getPattern())) {
            if (!conParams[param.getName()]) {
              // 记录使用的材质参数
              useParams.push(param);
              conParams[param.getName()] = true;
            } // 设置材质参数


            line = _Tools.default.repSrc(line, param.getPattern(), param.getTagPattern(), param.getName());
            useParam = true;
          }
        } // 检测上下文列表


        var context = null;

        for (var _k3 in _ShaderSource.default.Context_Data) {
          context = _ShaderSource.default.Context_Data[_k3];

          if (_Tools.default.find(line, context.pattern)) {
            // 记录该vsShader使用的context
            if (!conContexts[context.src]) {
              conContexts[context.src] = true;
              useContexts.push(context);
            } // 替换指定上下文


            line = _Tools.default.repSrc(line, context.pattern, context.tagPattern, context.tag);
          }
        }

        shader += _Tools.default.trim(line) + '\n';
      }

      shader += "}\n"; // 添加材质参数

      if (useParam) {
        subShaderDef.addUseParams(useParams);
        var inParams = "\n";

        for (var _k4 in useParams) {
          param = useParams[_k4]; // 添加参数
          // inParams += "#ifdef " + param.getDefType() + "\n";

          inParams += "uniform " + param.getType() + " " + param.getName() + ";\n"; // inParams += "#endif\n";
        }

        shader = inParams + shader;
      } // 检测shader是否需要添加变量


      if (useVars.length > 0) {
        // 加入变量块
        var outVars = "\n";
        useVars.forEach(function (vars) {
          outVars += "out " + vars.type + " " + vars.name + ";\n";
        });
        shader = outVars + shader;
      } // 检查context是否包含需要的几何属性


      if (useContexts.length > 0) {
        var BLOCKS = {};
        var useBlocks = [];
        subShaderDef.addUseContexts(useContexts);
        var vertIn = "\n";
        useContexts.forEach(function (context) {
          if (context.loc != null || context.loc != undefined) {
            vertIn += "layout (location=" + context.loc + ") in " + context.type + " " + context.src + ";\n";
          } else if (context.def) {
            if (!BLOCKS[context.def]) {
              useBlocks.push(context.def);
            } // 块定义


            BLOCKS[context.def] = context.def;
          } else if (context.utype) {
            vertIn += context.utype + " " + context.src;

            if (context.modifier) {
              vertIn += context.modifier;
            }

            vertIn += ";\n";
          } else if (context.type) {
            vertIn += context.type + " " + context.src + ";\n";
          }
        });
        subShaderDef.addUseBlocks(useBlocks); // 检测块部分

        for (var b in BLOCKS) {
          // 定义块
          vertIn = vertIn + _ShaderSource.default.BLOCKS[b].blockDef;
        }

        shader = vertIn + shader;
      }

      shader = '#version 300 es\n' + shader; // 添加shader
      // subShaderDef.addShaderSource(ShaderSource.VERTEX_SHADER, shader);
      // 这里,需要在subShader中记录需要更新数据的uniform变量的loc,以及uniform blocks等.以便在真正创建Material对象时,保证渲染时可以根据实际不同的MatDef提交数据到shader中。
      // 在创建Material时,还需要统计整个引擎需要计算哪些上下文变量(比如ViewMatrix,ProjectMatrix...),这样可以避免不必要的变量计算,同时保证所有shader可以正常运行。
      // 每次创建一个Material时,都通过解析subShader来统计待计算的上下文变量。

      return shader;
    }
  }, {
    key: "parseFsShader",
    value: function parseFsShader(subShaderDef, blockDef) {
      // let shaderSource = "";
      // blockDef.getSubBlock().forEach(subBlockDef=>{
      //     switch (subBlockDef.getType()) {
      //         case 'Fs_Shader_Main':
      //             shaderSource += MaterialDef.parseFsShaderMain(subShaderDef, subBlockDef);
      //             break;
      //         default:
      //             // 追加为当前着色器源码的其他部分(因为shader不仅仅包含main函数,还有很多自定义函数体)
      //             shaderSource += MaterialDef.parseFsShaderFun(subShaderDef, subBlockDef);
      //             break;
      //     }
      // });
      // console.log("shaderSource:",shaderSource);
      // subShaderDef.addShaderSource(ShaderSource.FRAGMENT_SHADER, shaderSource);
      var data = blockDef.getData();
      var line = null;
      var shader = "";
      var useContexts = [];
      var useVars = [];
      var varTable = subShaderDef.getVarTable();
      var globals = subShaderDef.getFromMaterialDef().getGlobals();
      var global = null;
      var params = subShaderDef.getFromMaterialDef().getParams();
      var param = null;
      var useParam = false;
      var useParams = [];
      var useGlobal = false;
      var conParams = {};
      var conContexts = {};
      var conVars = {};
      var conGlobals = {}; // 全局变量(一般是全局纹理,即自定义frameBuffer或内置延迟着色路径的frameBuffer的纹理数据块,需要使用一种其他解析注入方式)

      var useGlobals = [];
      var useFBId = null;

      var _loop2 = function _loop2(i) {
        line = _Tools.default.trim(data[i]);
        if (line.startsWith("//")) return "continue";
        var p = null;
        var pr = -1;
        var pr2 = -1;
        var prsult = null; // 检测变量列表

        varTable.forEach(function (vars) {
          pr = _Tools.default.find2(line, vars.pattern);

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, vars.pattern2);

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].name.length < vars.name.length) {
                prsult[pr] = vars;
              }
            } else {
              prsult[pr] = vars;
            }
          }
        });

        if (prsult) {
          for (var _pr4 in prsult) {
            p = prsult[_pr4];

            if (!conVars[p.name]) {
              conVars[p.name] = true;
              useVars.push(p);
            }
          }
        } // 检测全局变量


        p = null;
        pr = -1;
        pr2 = -1;
        prsult = null;
        var ginout = null;

        for (var _k6 in globals) {
          global = globals[_k6];

          for (var _g in global) {
            for (var _i = 0; _i < global[_g].length; _i++) {
              ginout = global[_g][_i];
              pr = _Tools.default.find2(line, ginout.pattern);

              if (pr != -1) {
                pr2 = _Tools.default.find2(line, ginout.pattern2);

                if (pr2 != null && pr2 != pr) {
                  pr = pr2;
                }

                if (!prsult) {
                  prsult = {};
                }

                if (prsult[pr] != null) {
                  if (prsult[pr].name.length < param.name.length) {
                    prsult[pr] = ginout;
                  }
                } else {
                  prsult[pr] = ginout;
                }
              }
            }
          }
        }

        if (prsult) {
          for (var _pr5 in prsult) {
            p = prsult[_pr5];

            if (!conGlobals[p.name]) {
              // 记录使用的材质参数
              useGlobals.push(p);
              conGlobals[p.name] = true;
            } // 设置材质参数


            line = _Tools.default.repSrc(line, p.pattern, p.tagPattern, p.name);
            useGlobal = true;
          }
        } // 检测材质参数列表


        p = null;
        pr = -1;
        pr2 = -1;
        prsult = null;

        for (var _k7 in params) {
          param = params[_k7]; // Tools.find()匹配有bug
          // 为了确保完全匹配最长的那个,暂时先这么处理

          pr = _Tools.default.find2(line, param.getPattern());

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, param.getPattern2());

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].getName().length < param.getName().length) {
                prsult[pr] = param;
              }
            } else {
              prsult[pr] = param;
            }
          }
        }

        if (prsult) {
          for (var _pr6 in prsult) {
            p = prsult[_pr6];

            if (!conParams[p.getName()]) {
              // 记录使用的材质参数
              useParams.push(p);
              conParams[p.getName()] = true;
            } // 设置材质参数


            line = _Tools.default.repSrc(line, p.getPattern(), p.getTagPattern(), p.getName());
            useParam = true;
          }
        } // 检测上下文列表


        var context = null;
        prsult = null;

        for (var _k8 in _ShaderSource.default.Context_Data) {
          context = _ShaderSource.default.Context_Data[_k8];
          if (context.pattern == null) continue;
          pr = _Tools.default.find2(line, context.pattern);

          if (pr != -1) {
            // 为了正确匹配一行的重复,再这里二次匹配并判断
            pr2 = _Tools.default.find2(line, context.pattern2);

            if (pr2 != null && pr2 != pr) {
              pr = pr2;
            }

            if (!prsult) {
              prsult = {};
            }

            if (prsult[pr] != null) {
              if (prsult[pr].src.length < context.src.length) {
                prsult[pr] = context;
              }
            } else {
              prsult[pr] = context;
            }
          }

          if (prsult) {
            for (var _pr7 in prsult) {
              context = prsult[_pr7]; // 记录该vsShader使用的context

              if (!conContexts[context.src]) {
                if (context.isFlagVariable) {
                  subShaderDef.addContextDefine(_ShaderSource.default.FRAGMENT_SHADER, context.src);
                } else {
                  conContexts[context.src] = true;
                  useContexts.push(context);
                }
              } // 替换指定上下文


              line = _Tools.default.repSrc(line, context.pattern, context.tagPattern, context.tag);
            }
          }
        }

        shader += _Tools.default.trim(line) + '\n';
      };

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        var _ret2 = _loop2(i);

        if (_ret2 === "continue") continue;
      } // 检测是否引用了GlobalTextures,以便找出需要关联的输出frameBuffer
      // 添加材质参数


      if (useParam) {
        subShaderDef.addUseParams(_ShaderSource.default.FRAGMENT_SHADER, useParams);
        var inParams = "\n";

        for (var k in useParams) {
          param = useParams[k]; // 添加参数
          // inParams += "#ifdef " + param.getDefType() + "\n";

          inParams += "uniform " + param.getType() + " " + param.getName() + ";\n"; // inParams += "#endif\n";
        }

        shader = inParams + shader;
      } // 添加全局变量


      if (useGlobal) {
        subShaderDef.addUseGlobals(useGlobals);
        var inGlobals = "\n";
        var g = null;

        for (var _k5 in useGlobals) {
          g = useGlobals[_k5]; // 添加参数
          // inParams += "#ifdef " + param.getDefType() + "\n";

          if (g.loc != null || g.loc != undefined) {
            // 后续从matDef解析类型
            // out部分
            inGlobals += "layout (location=" + g.loc + ") out " + g.dataType + " " + g.name + ";\n";
          } else {
            // in部分
            inGlobals += g.dataType + " " + g.name + ";\n";
          } // inParams += "#endif\n";

        }

        shader = inGlobals + shader;
      } // 检测shader是否需要添加变量


      if (useVars.length > 0) {
        // 加入变量块
        var inVars = "\n";
        useVars.forEach(function (vars) {
          inVars += "in " + vars.type + " " + vars.name + ";\n";
        });
        shader = inVars + shader;
      } // 检查context是否包含需要的几何属性


      if (useContexts.length > 0) {
        var BLOCKS = {};
        var useBlocks = [];
        subShaderDef.addUseContexts(useContexts);
        var vertIn = "\n";
        useContexts.forEach(function (context) {
          if (context.loc != null || context.loc != undefined) {
            // 说明当前需要引用输出frameBuffer
            // Context_Textures列表,以便找到关联的输出frameBuffer
            useFBId = _ShaderSource.default.Context_RenderDataRefFBs[context.src];
            vertIn += "layout (location=" + context.loc + ") out " + context.type + " " + context.src + ";\n";
          } else if (context.def) {
            if (!BLOCKS[context.def]) {
              useBlocks.push(context.def);
            } // 块定义


            BLOCKS[context.def] = context.def;
          } else if (context.utype) {
            vertIn += context.utype + " " + context.src;

            if (context.modifier) {
              vertIn += context.modifier;
            }

            vertIn += ";\n";
          } else if (context.type) {
            vertIn += context.type + " " + context.src + ";\n";
          }
        });
        subShaderDef.addUseBlocks(useBlocks); // 检测块部分

        for (var b in BLOCKS) {
          // 定义块
          vertIn = vertIn + _ShaderSource.default.BLOCKS[b].blockDef;
        }

        shader = vertIn + shader;
      }

      shader = '#version 300 es\n' + 'precision mediump float;\n' + shader; // 添加shader

      subShaderDef.addShaderSource(_ShaderSource.default.FRAGMENT_SHADER, shader);
      subShaderDef.setFBId(useFBId);
    }
  }, {
    key: "parseFsShaderFun",
    value: function parseFsShaderFun(subShaderDef, blockDef) {// 解析FsShader的其他函数
      // 单独定义parseFsShaderFun和parseVsShaderFun的目的在于,Fs和Vs对于某些变量的插入定义是不同的,所以最好单独进行
      // 比如对layout变量,vs是in而fs是out
    }
  }, {
    key: "parseFsShaderMain",
    value: function parseFsShaderMain(subShaderDef, blockDef) {
      var data = blockDef.getData();
      var line = null;
      var shader = "void main(){\n";
      var useContexts = [];
      var useVars = [];
      var varTable = subShaderDef.getVarTable();
      var params = subShaderDef.getFromMaterialDef().getParams();
      var param = null;
      var useParam = false;
      var useParams = [];
      var useGlobalTextures = [];
      var conParams = {};
      var conContexts = {};
      var conVars = {}; // 全局变量(一般是全局纹理,即自定义frameBuffer或内置延迟着色路径的frameBuffer的纹理数据块,需要使用一种其他解析注入方式)

      var useGlobals = [];
      var useFBId = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = _Tools.default.trim(data[i]);
        if (line.startsWith("//")) continue; // 检测变量列表

        varTable.forEach(function (vars) {
          if (_Tools.default.find(line, vars.pattern)) {
            if (!conVars[vars.name]) {
              conVars[vars.name] = true;
              useVars.push(vars);
            }
          }
        }); // 检测材质参数列表

        for (var k in params) {
          param = params[k];

          if (_Tools.default.find(line, param.getPattern())) {
            if (!conParams[param.getName()]) {
              // 记录使用的材质参数
              useParams.push(param);
              conParams[param.getName()] = true;
            } // 设置材质参数


            line = _Tools.default.repSrc(line, param.getPattern(), param.getTagPattern(), param.getName());
            useParam = true;
          }
        } // 检测上下文列表


        var context = null;

        for (var _k9 in _ShaderSource.default.Context_Data) {
          context = _ShaderSource.default.Context_Data[_k9];

          if (_Tools.default.find(line, context.pattern)) {
            // 记录该fsShader使用的context
            if (!conContexts[context.src]) {
              conContexts[context.src] = true;
              useContexts.push(context);
            } // 替换指定上下文


            line = _Tools.default.repSrc(line, context.pattern, context.tagPattern, context.tag);
          }
        }

        shader += _Tools.default.trim(line) + '\n';
      }

      shader += "}\n"; // 检测是否引用了GlobalTextures,以便找出需要关联的输出frameBuffer
      // 添加材质参数

      if (useParam) {
        subShaderDef.addUseParams(useParams);
        var inParams = "\n";

        for (var _k10 in useParams) {
          param = useParams[_k10]; // 添加参数
          // inParams += "#ifdef " + param.getDefType() + "\n";

          inParams += "uniform " + param.getType() + " " + param.getName() + ";\n"; // inParams += "#endif\n";
        }

        shader = inParams + shader;
      } // 检测shader是否需要添加变量


      if (useVars.length > 0) {
        // 加入变量块
        var inVars = "\n";
        useVars.forEach(function (vars) {
          inVars += "in " + vars.type + " " + vars.name + ";\n";
        });
        shader = inVars + shader;
      } // 检查context是否包含需要的几何属性


      if (useContexts.length > 0) {
        subShaderDef.addUseContexts(useContexts);
        var vertIn = "\n";
        useContexts.forEach(function (context) {
          if (context.loc != null || context.loc != undefined) {
            // 说明当前需要引用输出frameBuffer
            // Context_Textures列表,以便找到关联的输出frameBuffer
            useFBId = _ShaderSource.default.Context_RenderDataRefFBs[context.src];
            vertIn += "layout (location=" + context.loc + ") out " + context.type + " " + context.src + ";\n";
          } else if (context.utype) {
            vertIn += context.utype + " " + context.src + ";\n";
          } else if (context.type) {
            vertIn += context.type + " " + context.src + ";\n";
          }
        });
        shader = vertIn + shader;
      }

      shader = '#version 300 es\n' + 'precision mediump float;\n' + shader; // 添加shader
      // subShaderDef.addShaderSource(ShaderSource.FRAGMENT_SHADER, shader);

      subShaderDef.setFBId(useFBId); // 这里,需要在subShader中记录需要更新数据的uniform变量的loc,以及uniform blocks等.以便在真正创建Material对象时,保证渲染时可以根据实际不同的MatDef提交数据到shader中。
      // 在创建Material时,还需要统计整个引擎需要计算哪些上下文变量(比如ViewMatrix,ProjectMatrix...),这样可以避免不必要的变量计算,同时保证所有shader可以正常运行。
      // 每次创建一个Material时,都通过解析subShader来统计待计算的上下文变量。

      return shader;
    }
  }, {
    key: "parseSubPass",
    value: function parseSubPass(blockObj, blockDef) {
      var path = blockDef.getName();

      if (path == null || path == "") {
        path = _Render.default.FORWARD;
      }

      var data = blockDef.getData();
      var line = null;

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i];
        line = _Tools.default.trim(line);
        if (line.startsWith("//")) continue;
        line = line.substring(0, line.length - 1);
        blockObj.addSubPass(path, blockObj.getFromMaterialDef().getSubShaderDef(line));
      }
    }
  }, {
    key: "parsePass",
    value: function parsePass(blockObj, blockDef) {
      var data = blockDef.getData();
      var line = null; // RenderState

      var renderState = {};

      for (var i = blockDef.getStart() + 1; i < blockDef.getEnd(); i++) {
        line = data[i];
        line = _Tools.default.trim(line);
        if (line.startsWith("//")) continue;
        if (line.length == 0) continue;
        line = line.substring(0, line.length - 1);
        line = line.split(' ');

        if (line.length > 2) {
          var arr = [];

          for (var _i2 = 1; _i2 < line.length; _i2++) {
            arr.push(line[_i2]);
          }

          renderState["" + line[0] + ""] = arr;
        } else {
          renderState["" + line[0] + ""] = "" + line[1];
        }
      } // console.log("renderState:",renderState);


      blockObj.addPass(blockObj.getFromMaterialDef().getSubShaderDef(blockDef.getName()), renderState);
    }
  }, {
    key: "parseBlockDef",
    value: function parseBlockDef(blockObj, blockDef) {
      if (blockDef) {
        switch (blockDef.getType()) {
          case "Def":
            // 创建一个材质定义
            blockObj.setName(blockDef.getName());
            break;

          case "Globals":
            MaterialDef.parseGlobals(blockObj, blockDef);
            break;

          case "Params":
            // 材质参数
            // 解析材质参数列表
            MaterialDef.parseParams(blockObj, blockDef);
            break;

          case "SubTechnology":
            // 子技术块
            var subShaderDef = new _SubShaderDef.default(blockDef.getName());
            blockObj.addSubShaderDef(subShaderDef.getName(), subShaderDef); // 设置subBlockDef的blockObj

            blockObj = subShaderDef;
            break;

          case "Vs_Shader":
            // vs
            MaterialDef.parseVsShader(blockObj, blockDef);
            return;

          case "Fs_Shader":
            // fs
            MaterialDef.parseFsShader(blockObj, blockDef);
            return;

          case "Vars":
            MaterialDef.parseShaderVars(blockObj, blockDef);
            break;

          case "Advanced":
            MaterialDef.parseAdvanced(blockObj, blockDef);
            break;

          case "Vs_Shader_Main":
            // MaterialDef.parseVsShaderMain(blockObj, blockDef);
            break;

          case "Fs_Shader_Main":
            // MaterialDef.parseFsShaderMain(blockObj, blockDef);
            break;

          case "Technology":
            // 技术块
            var technologyDef = new _TechnologyDef.default(blockDef.getName());
            blockObj.addTechnologyDef(blockDef.getName(), technologyDef);
            blockObj = technologyDef;
            break;

          case "Sub_Pass":
            var path = blockDef.getName();

            if (path == null || path == "") {
              path = _Render.default.FORWARD;
            }

            var subPass = new SubPassDef(path); // MaterialDef.parseSubPass(blockObj, blockDef);

            blockObj.addSubPass(path, subPass);
            blockObj = subPass;
            break;

          case "Pass":
            MaterialDef.parsePass(blockObj, blockDef);
            break;
        }

        blockDef.getSubBlock().forEach(function (subBlockDef) {
          MaterialDef.parseBlockDef(blockObj, subBlockDef);
        });
      }
    }
    /**
     * 获取块定义
     * @param {Block}[blockDef 块定义,结果将报错到这里]
     * @param {String}[data Def文件内容]
     * @param {Number}[startOffset 块定义起始偏移量]
     */

  }, {
    key: "getBlockDef",
    value: function getBlockDef(blockDef, data, startOffset) {
      var start = 1;
      var line = null;

      for (var i = startOffset + 1; i < data.length; i++) {
        line = MaterialDef.trim(data[i]);

        if (!line.startsWith("//")) {
          if (line.endsWith("{")) {
            // 增加了一个块
            start++;
            var block = line.substring(0, line.indexOf("{")); // 块类型解析

            var bsa = block.split(" ");
            var blockType = bsa[0];

            if (blockType == "void") {
              blockType = blockDef.getType() + "_Main";
            }

            var blockId = "";

            if (bsa.length > 1) {
              blockId = bsa[bsa.length - 1];
            } // 开始一个块


            var subBlockDef = new Block(blockType, blockId, data, i);

            if (start == 2) {
              // 只添加直接子块
              blockDef.addSubBlock(subBlockDef);
            } // 查找该子块定义


            this.getBlockDef(subBlockDef, data, i);
          } else if (line.endsWith("}")) {
            start--;
          }

          if (start == 0) {
            // 找到块定义
            blockDef.setEnd(i);
            break;
          }
        }
      }
    }
  }, {
    key: "parse",
    value: function parse(data) {
      // 解析每一行
      var startBlocks = {};
      var endBlocks = {};

      if (data) {
        // 分割每一行
        data = data.split("\n"); // console.log("data:\n",data);

        for (var i = 0; i < data.length; i++) {
          var _line = MaterialDef.trim(data[i]);

          if (!_line.startsWith("//")) {
            if (_line.endsWith("{")) {
              var block = _line.substring(0, _line.indexOf("{")); // 块类型解析


              var bsa = block.split(" ");
              var blockType = bsa[0];

              if (blockType != "void") {
                var blockId = "";

                if (bsa.length > 1) {
                  blockId = bsa[bsa.length - 1];
                } // 开始一个块


                var blockDef = new Block(blockType, blockId, data, i);
                MaterialDef.getBlockDef(blockDef, data, i); // 开始解析块定义

                var matDef = new MaterialDef(blockDef.getName());
                MaterialDef.parseBlockDef(matDef, blockDef);
                return matDef; // console.log("matDef:",matDef);

                break;
              }
            }
          }
        }
      }

      return null;
    }
  }]);

  return MaterialDef;
}();

exports["default"] = MaterialDef;

/***/ }),

/***/ 5449:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * SubPass描述每个渲染阶段,其中可包含多个具体Pass。<br/>
 * @author Kkk
 * @date 2021年2月13日15点36分
 */
var SubPass = /*#__PURE__*/function () {
  function SubPass(renderPath) {
    _classCallCheck(this, SubPass);

    // 渲染路径
    this._m_RenderPath = renderPath; // 当前subPass指定的subShaders
    // 注意,添加的对象是{subShader,renderState}

    this._m_SubShaders = []; // key:subShaderName,value:{subShader,renderState}

    this._m_SubShaderMaps = {}; // 当前SubPass使用的FrameBuffer(每个SubPass都可以使用自己的FrameBuffer,为null时使用默认的FrameBuffer)

    this._m_FBId = null;
    this._m_PassId = 0;
  }
  /**
   * 设置当前SubPass使用的FrameBuffer。<br/>
   * @param {String}[fbId]
   */


  _createClass(SubPass, [{
    key: "setFBId",
    value: function setFBId(fbId) {
      this._m_FBId = fbId;
    }
    /**
     * 返回当前SubPass使用的frameBufferId。<br/>
     * @return {String}
     */

  }, {
    key: "getFBId",
    value: function getFBId() {
      return this._m_FBId;
    }
    /**
     * 返回当前subPass指定的渲染路径。<br/>
     * @return {String}
     */

  }, {
    key: "getRenderPath",
    value: function getRenderPath() {
      return this._m_RenderPath;
    }
    /**
     * 添加一个subShader。<br/>
     * @param {SubShader}[subShader]
     */

  }, {
    key: "addSubShader",
    value: function addSubShader(subShader) {
      this._m_SubShaders.push(subShader);

      this._m_SubShaderMaps[subShader.subShader.getName()] = subShader;
      this._m_SubShaderMaps[this._m_PassId++] = subShader;
    }
    /**
     * 返回所有subShader。
     * @return {SubShader[]}
     */

  }, {
    key: "getSubShaders",
    value: function getSubShaders() {
      return this._m_SubShaders;
    }
  }, {
    key: "getSubShaderMaps",
    value: function getSubShaderMaps() {
      return this._m_SubShaderMaps;
    }
  }]);

  return SubPass;
}();

exports["default"] = SubPass;

/***/ }),

/***/ 2603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _ShaderProgram = _interopRequireDefault(__webpack_require__(9836));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * SubShader,被Technology包含,一个Technology包含多个SubShader,用于实现高级着色中的多pass。<br/>
 * 一个SubShader就是一个具体的GLSL着色器程序。<br/>
 * @author Kkk
 * @date 2021年2月5日18点14分
 */
var SubShader = /*#__PURE__*/function () {
  function SubShader(gl, frameContext, subShaderDef) {
    _classCallCheck(this, SubShader);

    this._m_Def = subShaderDef; // SubShader对象Id

    this._m_ObjId = _Tools.default.nextId(); // 根据shader本身创建编码id
    // 以便所有同种类型的shader只被切换使用一次

    this._m_DefId = subShaderDef.getDefId();
    this._m_Name = subShaderDef.getName(); // 当前该SubShader使用的所有参数(包含params和contextVars以及renderDatas)

    this._m_MatParams = {}; // 渲染材质参数
    // 可定义参数

    this._m_CanDefineParams = {}; // 已定义参数

    this._m_AleadyDefinedParams = {}; // 参数列表

    this._m_Params = {}; // 参数值列表

    this._m_ParamValues = {}; // 宏定义列表

    this._m_Defines = null; // 密钥定义

    this._m_KeyDefs = null; // 需要重新加载Shader缓存

    this._m_NeedLoadShaderCaches = false; // 上下文变量
    // name:varName,loc:glLoc,fun:glFunc
    // 这里有一个优化是根据不同类型上下文变量提前分为不同的列表保存
    // 比如geometry的上下文变量(在geometry中提交modelMatrix和骨骼变换之类的变量)
    // 比如光照的上下文变量(在renderProgram中提交对应变量)

    this._m_ContextVars = {}; // 保存特殊纹理数据

    this._m_RenderDatas = {}; // 该pass使用的frameBuffer(默认为null)
    // 当前subShader使用的FrameBuffer,为null使用默认的frameBuffer

    this._m_FBId = subShaderDef.getFBId(); // 当前subShader引用的fb(renderDatas数据可能来自多个不同的fb)

    this._m_RefRenderDataFBs = null; // 渲染程序类型

    this._m_RenderProgramType = subShaderDef.getRenderProgramType(); // 解析参数定义

    this._loadParams(); // 创建默认着色程序


    this._newShaderProgram(gl, frameContext);
  }
  /**
   * 返回着色器Id。<br/>
   * @return {Number|*}
   */


  _createClass(SubShader, [{
    key: "getSId",
    value: function getSId() {
      return this._m_DefId;
    }
    /**
     * 加载所有可用参数定义。<br/>
     */

  }, {
    key: "_loadParams",
    value: function _loadParams() {
      var _this = this;

      var useParams = this._m_Def.getUseParams();

      if (useParams && useParams.length > 0) {
        useParams.forEach(function (param) {
          _this._m_CanDefineParams[param.getName()] = "#define " + param.getDefType() + " " + param.getDefType();
          _this._m_Params[param.getName()] = true;
        });
      }
    }
    /**
     * 上载参数。<br/>
     * @param {WebGL}[gl]
     * @param {String}[paramName]
     * @param {Vars}[value]
     */

  }, {
    key: "uploadParam",
    value: function uploadParam(gl, paramName, value) {
      if (this._m_MatParams[paramName]) {
        if (this._m_ParamValues[paramName]) {
          // 检查是否需要上载
          if (this._m_ParamValues[paramName].compare(value)) {
            return;
          }
        }

        value._upload(gl, this._m_MatParams[paramName].loc, null);

        this._m_ParamValues[paramName] = value;
      }
    }
    /**
     * 判断是否需要编译。<br/>
     * @return {*}
     */

  }, {
    key: "needCompile",
    value: function needCompile() {
      return this._m_NeedLoadShaderCaches || this._m_Defines != null || this._m_ShaderProgram.needCompile();
    }
    /**
     * 编译SubShader。<br/>
     * @param {WebGL}[g]
     * @param {FrameContext}[frameContext]
     * @private
     */

  }, {
    key: "_compile",
    value: function _compile(gl, frameContext) {
      if (this._m_Defines) {
        this._newShaderProgram(gl, frameContext);
      } // 并非一定需要编译,因为可能该ShaderProgram来自引擎其他地方


      if (this._m_ShaderProgram.needCompile()) {
        this._m_ShaderProgram._compile(gl); // 清空渲染数据


        this._m_RenderDatas = {};

        _Log.default.log("编译!");
      }

      this._loadShaderCaches(gl, frameContext);
    }
    /**
     * 加载Shader缓存数据块。<br/>
     * @param {WebGL}[gl]
     * @param {FrameContext}[frameContext]
     * @private
     */

  }, {
    key: "_loadShaderCaches",
    value: function _loadShaderCaches(gl, frameContext) {
      var _this2 = this;

      // 重置
      this._m_MatParams = [];
      this._m_NeedLoadShaderCaches = false; // 计算缓存变量

      this.use(gl); // 获取program变量信息

      var useParams = this._m_Def.getUseParams();

      var useGlobals = this._m_Def.getUseGlobals();

      var useContexts = this._m_Def.getUseContexts();

      var texId = 0;

      if (useParams && useParams.length > 0) {
        // 解析材质参数
        useParams.forEach(function (param) {
          var loc = gl.getUniformLocation(_this2._m_ShaderProgram.getProgram(), param.getName());

          if (loc) {
            var fun = null;

            switch (param.getType()) {
              case "vec4":
                fun = 'uniform4f';
                break;

              case "sampler2D":
                gl.uniform1i(loc, texId); // 使用texId作为loc

                fun = null;
                loc = texId++;
                break;

              case "samplerCube":
                gl.uniform1i(loc, texId); // 使用texId作为loc

                fun = null;
                loc = texId++;
                break;
            }

            _this2._m_MatParams[param.getName()] = {
              type: param.getType(),
              loc: loc,
              fun: fun
            };
          }
        });
      }

      if (useGlobals && useGlobals.length > 0) {
        var loc = null,
            fun = null;
        useGlobals.forEach(function (global) {
          if (global.loc == null || global.loc == undefined) {
            // in部分
            // 初始化全局变量
            if (!_this2._m_RenderDatas[global.name]) {
              loc = gl.getUniformLocation(_this2._m_ShaderProgram.getProgram(), global.name);
              gl.uniform1i(loc, texId); // 使用texId作为loc

              fun = null;
              loc = texId++;
              _this2._m_RenderDatas[global.name] = {
                type: global.type,
                loc: loc,
                fun: fun,
                refId: global.refName,
                dataId: global.name
              };
            }
          } else {
            // 激活指定fb
            _this2._m_FBId = global.refName;
          }
        });
      }

      if (useContexts && useContexts.length > 0) {
        useContexts.forEach(function (context) {
          // 过滤掉layout in和layout out(即包含loc的变量)
          if (context.loc == null || context.loc == undefined) {
            var _loc = gl.getUniformLocation(_this2._m_ShaderProgram.getProgram(), context.src);

            if (_loc) {
              var _fun = null;

              switch (context.type) {
                case "mat4":
                  _fun = 'uniformMatrix4fv';
                  break;

                case "samplerCube":
                case "sampler2D":
                  // 2D纹理
                  gl.uniform1i(_loc, texId); // 使用texId作为loc

                  _fun = null;
                  _loc = texId++; // 对于subShader,有两种类别sampler2D
                  // 一种是普通sampler2D,其数据来自MatValue(即用户的纹理输入)
                  // 另一种是frameBuffer的缓冲区(包括Context.Inxxx之类的纹理,以及自定义Globals_FrameBuffer.Inxxx之类的纹理)
                  // 对于第二种情况,存在一个标识context.flag='renderData'

                  if (context.flag == 'renderData') {
                    // 添加到frameBuffer.textures
                    // refId表示当前subShader的纹理数据来自哪个frameBuffer
                    // dataId表示当前subShader的纹理数据来自frameBuffer的哪个texture
                    // 对于Global_Textures,也做同样的处理逻辑
                    _this2._m_RenderDatas[context.src] = {
                      type: context.type,
                      loc: _loc,
                      fun: _fun,
                      refId: _ShaderSource.default.Context_RenderDataRefFBs[context.src],
                      dataId: context.src
                    };
                  }

                  break;
              }

              _this2._m_ContextVars[context.src] = {
                type: context.type,
                loc: _loc,
                fun: _fun
              };
              _this2._m_MatParams[context.src] = {
                type: context.type,
                loc: _loc,
                fun: _fun
              };
            }

            frameContext.addContext(context.src);
          }
        });
      } // BLOCKS


      var useBlocks = this._m_Def.getUseBlocks();

      if (useBlocks && useBlocks.length > 0) {
        useBlocks.forEach(function (block) {
          gl.uniformBlockBinding(_this2._m_ShaderProgram.getProgram(), gl.getUniformBlockIndex(_this2._m_ShaderProgram.getProgram(), block), _ShaderSource.default.BLOCKS[block].blockIndex);
        });
      } // let ubi = gl.getUniformBlockIndex(this._m_ShaderProgram.getProgram(), "VP");
      // gl.uniformBlockBinding(this._m_ShaderProgram.getProgram(), ubi, 0x001);


      if (frameContext.m_LastSubShader) {
        frameContext.m_LastSubShader.use(gl);
      }
    }
    /**
     * 返回渲染程序类型。<br/>
     * null表示使用默认渲染程序。<br/>
     * @return {null}
     */

  }, {
    key: "getRenderProgramType",
    value: function getRenderProgramType() {
      return this._m_RenderProgramType;
    }
    /**
     * 返回当前SubShader名称。<br/>
     * @return {*|String}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
    /**
     * 返回当前SubShader定义Id。<br/>
     * 只有完全一致的着色源码定义，材质同一种类型的SubShader。<br/>
     * 一旦存在不同宏定义导致源码不一致，则也是不同DefId。<br/>
     * 目前使用用MaterDef+SubShaderName+宏定义编码计算该DefId。<br/>
     * @return {Number}
     */

  }, {
    key: "getDefId",
    value: function getDefId() {
      return this._m_DefId;
    }
    /**
     * 设置使用的fbid。<br/>
     * @param {String}[fbId]
     */

  }, {
    key: "setFBId",
    value: function setFBId(fbId) {
      this._m_FBId = fbId;
    }
    /**
     * 返回指定的fbid。<br/>
     * @return {String}
     */

  }, {
    key: "getFBId",
    value: function getFBId() {
      return this._m_FBId;
    }
    /**
     * 使用该SubShader。<br/>
     * @param {GL}
     */

  }, {
    key: "use",
    value: function use(gl) {
      this._m_ShaderProgram.use(gl);
    }
  }, {
    key: "getContextVars",
    value: function getContextVars() {
      return this._m_ContextVars;
    }
  }, {
    key: "getRenderDatas",
    value: function getRenderDatas() {
      return this._m_RenderDatas;
    }
  }, {
    key: "getRefRenderDataFBs",
    value: function getRefRenderDataFBs() {
      return this._m_RefRenderDataFBs;
    }
    /**
     * 清除参数定义。<br/>
     * @param {String}[dparam 参数名]
     * @param {Boolean}[isContextDefine 表明是否为上下文定义]
     * @param {Boolean}[globalRefresh 表明刷新同类subShader]
     */

  }, {
    key: "clearDefine",
    value: function clearDefine(dparam, isContextDefine, globalRefresh) {
      var _new = false;

      if (this._m_AleadyDefinedParams[dparam]) {
        if (this._m_CanDefineParams[dparam] || isContextDefine) {
          _new = true; // this._m_AleadyDefinedParams[dparam] = false;

          delete this._m_AleadyDefinedParams[dparam];
        }
      }

      if (_new) {
        this._m_Defines = null;
        this._m_KeyDefs = null;

        for (var param in this._m_AleadyDefinedParams) {
          if (!this._m_Defines) {
            this._m_Defines = {};
          } // 定义参数


          var shaderParams = this._m_Def.getShaderParams();

          var shaderContextDefines = this._m_Def.getShaderContextDefines();

          if (shaderParams[_ShaderSource.default.VERTEX_SHADER] && shaderParams[_ShaderSource.default.VERTEX_SHADER][param] || shaderContextDefines[_ShaderSource.default.VERTEX_SHADER] && shaderContextDefines[_ShaderSource.default.VERTEX_SHADER][param]) {
            // 加入顶点着色器
            if (!this._m_Defines[_ShaderSource.default.VERTEX_SHADER]) {
              this._m_Defines[_ShaderSource.default.VERTEX_SHADER] = "";
            }

            if (isContextDefine && param == dparam) {
              this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
            } else {
              // 先判断该参数是否属于contextDefine(因为dparam!=param,但param仍有可能属于contextDefine
              if (_ShaderSource.default.Context_Data[param] != null) {
                this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
              } else {
                // 属于材质参数定义
                this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += this._m_CanDefineParams[param] + "\n";
              }
            }

            if (!this._m_KeyDefs) {
              this._m_KeyDefs = "";
            }

            this._m_KeyDefs += param + ",";
          } else if (shaderParams[_ShaderSource.default.FRAGMENT_SHADER] && shaderParams[_ShaderSource.default.FRAGMENT_SHADER][param] || shaderContextDefines[_ShaderSource.default.FRAGMENT_SHADER] && shaderContextDefines[_ShaderSource.default.FRAGMENT_SHADER][param]) {
            // 加入片段着色器
            if (!this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER]) {
              this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] = "";
            }

            if (isContextDefine && param == dparam) {
              this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
            } else {
              // 先判断该参数是否属于contextDefine(因为dparam!=param,但param仍有可能属于contextDefine
              if (_ShaderSource.default.Context_Data[param] != null) {
                this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
              } else {
                // 属于材质参数定义
                this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += this._m_CanDefineParams[param] + "\n";
              }
            }

            if (!this._m_KeyDefs) {
              this._m_KeyDefs = "";
            }

            this._m_KeyDefs += param + ",";
          }
        } // 当删除最后一个定义时,此时this._m_Defines为空,为了能够重新编译,这里不让它为空


        if (!this._m_Defines) {
          this._m_Defines = {};
          this._m_KeyDefs = ",";
        }

        if (this._m_Defines != null && globalRefresh) {
          var holds = this._m_ShaderProgram._m_Holds;

          for (var objId in holds) {
            if (holds[objId] != this && holds[objId]) {
              // 其他所有引用同一个shaderProgram的subShader都应该添加这个defines
              // 不必担心重复编译,因为一旦其中一个被编译过,其他subShader都会自动引用
              holds[objId]._m_KeyDefs = this._m_KeyDefs;
              holds[objId]._m_Defines = this._m_Defines;
            }
          }
        }
      }
    }
    /**
     * 添加参数定义。<br/>
     * @param {String}[dparam 参数名]
     * @param {Boolean}[isContextDefine 表明是否为上下文定义]
     * @param {Boolean}[globalRefresh 表明刷新同类subShader]
     */

  }, {
    key: "addDefine",
    value: function addDefine(dparam, isContextDefine, globalRefresh) {
      var _new = false;

      if (!this._m_AleadyDefinedParams[dparam]) {
        if (this._m_CanDefineParams[dparam] || isContextDefine) {
          _new = true;
          this._m_AleadyDefinedParams[dparam] = true;
        }
      }

      if (_new) {
        this._m_Defines = null;
        this._m_KeyDefs = null;

        for (var param in this._m_AleadyDefinedParams) {
          if (!this._m_Defines) {
            this._m_Defines = {};
          } // 定义参数


          var shaderParams = this._m_Def.getShaderParams();

          var shaderContextDefines = this._m_Def.getShaderContextDefines();

          if (shaderParams[_ShaderSource.default.VERTEX_SHADER] && shaderParams[_ShaderSource.default.VERTEX_SHADER][param] || shaderContextDefines[_ShaderSource.default.VERTEX_SHADER] && shaderContextDefines[_ShaderSource.default.VERTEX_SHADER][param]) {
            // 加入顶点着色器
            if (!this._m_Defines[_ShaderSource.default.VERTEX_SHADER]) {
              this._m_Defines[_ShaderSource.default.VERTEX_SHADER] = "";
            }

            if (isContextDefine && param == dparam) {
              this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
            } else {
              // 先判断该参数是否属于contextDefine(因为dparam!=param,但param仍有可能属于contextDefine
              if (_ShaderSource.default.Context_Data[param] != null) {
                this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
              } else {
                // 属于材质参数定义
                this._m_Defines[_ShaderSource.default.VERTEX_SHADER] += this._m_CanDefineParams[param] + "\n";
              }
            }

            if (!this._m_KeyDefs) {
              this._m_KeyDefs = "";
            }

            this._m_KeyDefs += param + ",";
          } else if (shaderParams[_ShaderSource.default.FRAGMENT_SHADER] && shaderParams[_ShaderSource.default.FRAGMENT_SHADER][param] || shaderContextDefines[_ShaderSource.default.FRAGMENT_SHADER] && shaderContextDefines[_ShaderSource.default.FRAGMENT_SHADER][param]) {
            // 加入片段着色器
            if (!this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER]) {
              this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] = "";
            }

            if (isContextDefine && param == dparam) {
              this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
            } else {
              // 先判断该参数是否属于contextDefine(因为dparam!=param,但param仍有可能属于contextDefine
              if (_ShaderSource.default.Context_Data[param] != null) {
                this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += _ShaderSource.default.Context_Data[param] + "\n";
              } else {
                // 属于材质参数定义
                this._m_Defines[_ShaderSource.default.FRAGMENT_SHADER] += this._m_CanDefineParams[param] + "\n";
              }
            }

            if (!this._m_KeyDefs) {
              this._m_KeyDefs = "";
            }

            this._m_KeyDefs += param + ",";
          }
        }

        if (this._m_Defines != null && globalRefresh) {
          var holds = this._m_ShaderProgram._m_Holds;

          for (var objId in holds) {
            if (holds[objId] != this && holds[objId]) {
              // 其他所有引用同一个shaderProgram的subShader都应该添加这个defines
              // 不必担心重复编译,因为一旦其中一个被编译过,其他subShader都会自动引用
              holds[objId]._m_KeyDefs = this._m_KeyDefs;
              holds[objId]._m_Defines = this._m_Defines;
            }
          }
        }
      }
    }
    /**
     * 重建shaderProgram。<br/>
     * @param {FrameContext}[frameContext]
     */

  }, {
    key: "_newShaderProgram",
    value: function _newShaderProgram(gl, frameContext) {
      if (this._m_Defines) {
        var key = this._m_KeyDefs;

        if (key && key.length > 0) {
          key = key.substr(0, key.length - 1); // 重新计算DefId

          this._m_DefId = this._m_Def.computeSignatureDefId(key);
        }
      }

      if (!frameContext.m_Shaders[this._m_DefId]) {
        if (this._m_ShaderProgram) {
          this._m_ShaderProgram.deleteHold(this);

          if (this._m_ShaderProgram.canDestroy()) {
            // 删除
            this._m_ShaderProgram.destroy(gl, frameContext);
          }
        }

        this._m_ShaderProgram = new _ShaderProgram.default(gl, this._m_DefId, this._m_Def.getShaderSource(), this._m_Defines, true);
        frameContext.m_Shaders[this._m_DefId] = this._m_ShaderProgram;

        this._m_ShaderProgram.addHold(this); // 清空


        this._m_Defines = null;
      } else {
        if (this._m_ShaderProgram) {
          this._m_ShaderProgram.deleteHold(this);

          if (this._m_ShaderProgram.canDestroy()) {
            // 删除
            this._m_ShaderProgram.destroy(gl, frameContext);
          }
        }

        this._m_ShaderProgram = frameContext.m_Shaders[this._m_DefId];

        this._m_ShaderProgram.addHold(this); // 清空


        this._m_Defines = null;
      }

      this._m_NeedLoadShaderCaches = true;
    }
    /**
     * 返回指定参数的Ref。<br/>
     * @param {WebGL}[gl]
     * @param {String}[name]
     * @return {WebGLUniformLocation}
     */

  }, {
    key: "getRef",
    value: function getRef(gl, name) {
      return gl.getUniformLocation(this._m_ShaderProgram.getProgram(), name);
    }
  }]);

  return SubShader;
}();

exports["default"] = SubShader;

/***/ }),

/***/ 4974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * SubShader,被Technology包含,一个Technology包含多个SubShader,用于实现高级着色中的多pass。<br/>
 * 一个SubShader就是一个具体的GLSL着色器程序。<br/>
 * @author Kkk
 * @date 2021年2月5日18点14分
 */
var SubShaderDef = /*#__PURE__*/function () {
  function SubShaderDef(name) {
    _classCallCheck(this, SubShaderDef);

    this._m_Name = name; // 用于判断是否属于同一类别shaderDef
    // 使用_m_Signature生成的定义id

    this._m_DefId = null; // 签名(每个subShader都是唯一签名的)

    this._m_Signature = null;
    this._m_ShaderSource = new _ShaderSource.default(); // 设置该SubShaderDef来自哪个MaterialDef

    this._m_FromMaterialDef = null; // 变量列表

    this._m_Var_Table = []; // 使用的context变量

    this._m_UseContexts = []; // 使用的材质参数变量

    this._m_UseParams = []; // 使用的材质全局变量

    this._m_UseGlobals = []; // 着色器使用的参数变量

    this._m_ShaderParams = {}; // 着色器使用的上下文宏定义

    this._m_ShaderContextDefines = {}; // 使用的块定义

    this._m_UseBlocks = []; // 该subShader使用的fb,null表示使用默认

    this._m_FBId = null; // 当前subShader使用的特殊

    this._m_RefFBs = null; // 设置指定的渲染程序类型(默认为null)

    this._m_RenderProgramType = null;
  }
  /**
   * 设置渲染程序类型。<br/>
   * @param {renderProgramType}[String]
   */


  _createClass(SubShaderDef, [{
    key: "setRenderProgramType",
    value: function setRenderProgramType(renderProgramType) {
      this._m_RenderProgramType = renderProgramType;
    }
    /**
     * 返回渲染程序类型。<br/>
     * @return {null}
     */

  }, {
    key: "getRenderProgramType",
    value: function getRenderProgramType() {
      return this._m_RenderProgramType;
    }
    /**
     * 设置使用的fb。<br/>
     * @param {String}[fbId]
     */

  }, {
    key: "setFBId",
    value: function setFBId(fbId) {
      this._m_FBId = fbId;
    }
    /**
     * 返回使用的fb。<br/>
     * @return {String}
     */

  }, {
    key: "getFBId",
    value: function getFBId() {
      return this._m_FBId;
    }
    /**
     * 计算定义id。<br/>
     * @param {String}[key 可选的密钥]
     */

  }, {
    key: "computeSignatureDefId",
    value: function computeSignatureDefId(key) {
      if (key) {
        // 排序key
        var arr = key.split(',');
        var newArr = arr.sort(function (a, b) {
          return a.localeCompare(b);
        });
        key = '';
        newArr.forEach(function (k) {
          key += k + ',';
        });
        key = key.substr(0, key.length - 1); // this._m_DefId = Tools.uniqueId(this._m_Signature + key);

        return _Tools.default.uniqueId(this._m_Signature + key); // console.log("key:" + key + ";defId:" + this._m_DefId);
      } else {
        this._m_DefId = _Tools.default.uniqueId(this._m_Signature);
      }

      return this._m_DefId;
    }
    /**
     * 返回定义Id。<br/>
     * @return {String}
     */

  }, {
    key: "getDefId",
    value: function getDefId() {
      return this._m_DefId;
    }
  }, {
    key: "addUseContexts",
    value: function addUseContexts(useContexts) {
      var _this = this;

      useContexts.forEach(function (context) {
        _this._m_UseContexts.push(context);
      });
    }
  }, {
    key: "getUseContexts",
    value: function getUseContexts() {
      return this._m_UseContexts;
    }
  }, {
    key: "addUseGlobals",
    value: function addUseGlobals(useGlobals) {
      var _this2 = this;

      useGlobals.forEach(function (global) {
        _this2._m_UseGlobals.push(global);
      });
    }
  }, {
    key: "getUseGlobals",
    value: function getUseGlobals() {
      return this._m_UseGlobals;
    }
  }, {
    key: "addUseParams",
    value: function addUseParams(shaderType, useParams) {
      var _this3 = this;

      useParams.forEach(function (param) {
        _this3._m_UseParams.push(param);

        if (shaderType == _ShaderSource.default.VERTEX_SHADER) {
          if (!_this3._m_ShaderParams[_ShaderSource.default.VERTEX_SHADER]) {
            _this3._m_ShaderParams[_ShaderSource.default.VERTEX_SHADER] = {};
          }

          _this3._m_ShaderParams[_ShaderSource.default.VERTEX_SHADER][param.getName()] = true;
        } else if (shaderType == _ShaderSource.default.FRAGMENT_SHADER) {
          if (!_this3._m_ShaderParams[_ShaderSource.default.FRAGMENT_SHADER]) {
            _this3._m_ShaderParams[_ShaderSource.default.FRAGMENT_SHADER] = {};
          }

          _this3._m_ShaderParams[_ShaderSource.default.FRAGMENT_SHADER][param.getName()] = true;
        }
      });
    }
  }, {
    key: "addContextDefine",
    value: function addContextDefine(shaderType, define) {
      if (!this._m_ShaderContextDefines[shaderType]) {
        this._m_ShaderContextDefines[shaderType] = {};
      }

      this._m_ShaderContextDefines[shaderType][define] = true;
    }
  }, {
    key: "getShaderParams",
    value: function getShaderParams() {
      return this._m_ShaderParams;
    }
  }, {
    key: "getShaderContextDefines",
    value: function getShaderContextDefines() {
      return this._m_ShaderContextDefines;
    }
  }, {
    key: "getUseParams",
    value: function getUseParams() {
      return this._m_UseParams;
    }
  }, {
    key: "addUseBlocks",
    value: function addUseBlocks(useBlocks) {
      var _this4 = this;

      useBlocks.forEach(function (block) {
        _this4._m_UseBlocks.push(block);
      });
    }
  }, {
    key: "getUseBlocks",
    value: function getUseBlocks() {
      return this._m_UseBlocks;
    }
    /**
     * 设置该SubShaderDef来自哪个MaterialDef。<br/>
     * @param {MaterialDef}[materialDef]
     */

  }, {
    key: "setFromMaterialDef",
    value: function setFromMaterialDef(materialDef) {
      this._m_FromMaterialDef = materialDef; // 计算shaderId

      this._m_Signature = materialDef.getName() + this.getName();
      this.computeSignatureDefId();
    }
    /**
     * 返回当前所属得MaterialDef。<br/>
     * @returns {MaterialDef}[materialDef]
     */

  }, {
    key: "getFromMaterialDef",
    value: function getFromMaterialDef() {
      return this._m_FromMaterialDef;
    }
    /**
     * 返回SubShaderDef的名称。<br/>
     * @returns {String}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
    /**
     * 添加一个变量。<br/>
     * @param {String}[type 变量类型]
     * @param {String}[name 变量名称]
     */

  }, {
    key: "addVar",
    value: function addVar(type, name) {
      this._m_Var_Table.push({
        type: type,
        name: name,
        pattern: eval("/" + name + "/"),
        pattern2: eval("/" + name + "[\\s+-;.,\\*\\\\]{1,}/")
      });
    }
    /**
     * 返回变量列表。<br/>
     * @return {{}|*}
     */

  }, {
    key: "getVarTable",
    value: function getVarTable() {
      return this._m_Var_Table;
    }
  }, {
    key: "addShaderSource",
    value: function addShaderSource(type, shader) {
      this._m_ShaderSource.set(type, shader);
    }
    /**
     * 返回材质定义的着色器源码。<br/>
     * @returns {Object}[ShaderSource]
     */

  }, {
    key: "getShaderSource",
    value: function getShaderSource() {
      return this._m_ShaderSource;
    }
  }]);

  return SubShaderDef;
}();

exports["default"] = SubShaderDef;

/***/ }),

/***/ 7057:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SubShaderSource = /*#__PURE__*/function () {
  function SubShaderSource(materialSourceDef) {
    _classCallCheck(this, SubShaderSource);

    // 读取materialSourceDef文件,然后解析出vs和fs源码
    // 提取vs和fs源码后,创建着色器程序。
    this._m_ShaderSource = null; // 解析得到vs和fs源码(应该将SubShaderSource转为SubShader,渲染时直接使用SubShader)

    this._m_ShaderSource = new _ShaderSource.default();

    this._m_ShaderSource.set(_ShaderSource.default.VERTEX_SHADER, materialSourceDef.getVsSrc());

    this._m_ShaderSource.set(_ShaderSource.default.FRAGMENT_SHADER, materialSourceDef.getFsSrc());
  }
  /**
   * 返回材质定义的着色器源码。<br/>
   * @returns {Object}[ShaderSource]
   */


  _createClass(SubShaderSource, [{
    key: "getShaderSource",
    value: function getShaderSource() {
      return this._m_ShaderSource;
    }
  }]);

  return SubShaderSource;
}();

exports["default"] = SubShaderSource;

/***/ }),

/***/ 2768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _SubPass = _interopRequireDefault(__webpack_require__(5449));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Technology = /*#__PURE__*/function () {
  function Technology(name) {
    _classCallCheck(this, Technology);

    this._m_Name = name; // 根据渲染路径分类
    // key:renderPath,value:SubPass

    this._m_SubPasss = {};
  }

  _createClass(Technology, [{
    key: "setName",
    value: function setName(name) {
      this._m_Name = name;
    }
    /**
     * 添加一个SubShader到指定的SubPass。<br/>
     * @param {String}[renderPath 渲染路径]
     * @param {SubShader}[subShader ]
     * @param {RenderState}[renderStte]
     */

  }, {
    key: "addSubPass",
    value: function addSubPass(renderPath, subShader, renderState) {
      if (!this._m_SubPasss[renderPath]) {
        this._m_SubPasss[renderPath] = new _SubPass.default(renderPath);
      }

      var rState = null;

      if (renderState) {
        for (var k in renderState) {
          if (!rState) {
            rState = new _RenderState.default();
          }

          rState.setFlag(k, renderState[k]);
        }
      }

      this._m_SubPasss[renderPath].addSubShader({
        subShader: subShader,
        renderState: rState
      });
    }
    /**
     * 返回指定渲染路径的subPass。<br/>
     * @param {String}[renderPath 渲染路径]
     * @returns {SubPass}
     */

  }, {
    key: "getSubPasss",
    value: function getSubPasss(renderPath) {
      return this._m_SubPasss[renderPath];
    }
    /**
     * 返回渲染阶段列表数据。<br/>
     * @return {SubPass[]}
     */

  }, {
    key: "getSubPassList",
    value: function getSubPassList() {
      return this._m_SubPasss;
    }
  }]);

  return Technology;
}();

exports["default"] = Technology;

/***/ }),

/***/ 8173:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TechnologyDef = /*#__PURE__*/function () {
  function TechnologyDef(name) {
    _classCallCheck(this, TechnologyDef);

    this.m_Name = name; // key:renderPath, value:SubShaderDef[]

    this.m_SubPass = {}; // 设置该SubShaderDef来自哪个MaterialDef

    this._m_FromMaterialDef = null;
  }

  _createClass(TechnologyDef, [{
    key: "getName",
    value: function getName() {
      return this.m_Name;
    }
    /**
     * 设置该SubShaderDef来自哪个MaterialDef。<br/>
     * @param {MaterialDef}[materialDef]
     */

  }, {
    key: "setFromMaterialDef",
    value: function setFromMaterialDef(materialDef) {
      this._m_FromMaterialDef = materialDef;
    }
    /**
     * 返回当前所属得MaterialDef。<br/>
     * @returns {MaterialDef}[materialDef]
     */

  }, {
    key: "getFromMaterialDef",
    value: function getFromMaterialDef() {
      return this._m_FromMaterialDef;
    }
    /**
     * 添加一个subShaderDef
     * @param {String}[path 渲染路径]
     * @param {SubPass}[subPass]
     */

  }, {
    key: "addSubPass",
    value: function addSubPass(path, subPass) {
      if (!this.m_SubPass[path]) {
        this.m_SubPass[path] = [];
      }

      this.m_SubPass[path].push(subPass);
      subPass.setFromMaterialDef(this._m_FromMaterialDef);
    }
    /**
     * 返回SubPass。<br/>
     * @returns {SubPass[]}
     */

  }, {
    key: "getSubPass",
    value: function getSubPass() {
      return this.m_SubPass;
    }
  }]);

  return TechnologyDef;
}();

exports["default"] = TechnologyDef;

/***/ }),

/***/ 3801:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BoundingVolume2 = _interopRequireDefault(__webpack_require__(1322));

var _Plane = _interopRequireDefault(__webpack_require__(7088));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var AABBBoundingBox = /*#__PURE__*/function (_BoundingVolume) {
  _inherits(AABBBoundingBox, _BoundingVolume);

  var _super = _createSuper(AABBBoundingBox);

  function AABBBoundingBox(props) {
    var _this;

    _classCallCheck(this, AABBBoundingBox);

    _this = _super.call(this, props);
    _this._m_XHalf = 0;
    _this._m_YHalf = 0;
    _this._m_ZHalf = 0;
    return _this;
  }
  /**
   * 设置半程值。<br/>
   * @param {Number}[x]
   * @param {Number}[y]
   * @param {Number}[z]
   */


  _createClass(AABBBoundingBox, [{
    key: "setHalfInXYZ",
    value: function setHalfInXYZ(x, y, z) {
      this._m_XHalf = x;
      this._m_YHalf = y;
      this._m_ZHalf = z;
    }
    /**
     * 设置半程值。<br/>
     * @param {Vector3}[vec3]
     */

  }, {
    key: "setHalf",
    value: function setHalf(vec3) {
      this._m_XHalf = vec3._m_X;
      this._m_YHalf = vec3._m_Y;
      this._m_ZHalf = vec3._m_Z;
    }
    /**
     * 设置x半径。<br/>
     * @param {Number}[xHalf]
     */

  }, {
    key: "setXHalf",
    value: function setXHalf(xHalf) {
      this._m_XHalf = xHalf;
    }
    /**
     * 返回x半径。<br/>
     * @return {Number}
     */

  }, {
    key: "getXHalf",
    value: function getXHalf() {
      return this._m_XHalf;
    }
    /**
     * 设置y半径。<br/>
     * @param {Number}[y]
     */

  }, {
    key: "setYHalf",
    value: function setYHalf(y) {
      this._m_YHalf = y;
    }
    /**
     * 返回y半径。<br/>
     * @return {Number}
     */

  }, {
    key: "getYHalf",
    value: function getYHalf() {
      return this._m_YHalf;
    }
    /**
     * 设置z半径。<br/>
     * @param {Number}[z]
     */

  }, {
    key: "setZHalf",
    value: function setZHalf(z) {
      this._m_ZHalf = z;
    }
    /**
     * 返回z半径。<br/>
     * @return {Number}
     */

  }, {
    key: "getZHalf",
    value: function getZHalf() {
      return this._m_ZHalf;
    }
    /**
     * 返回包围体类型。<br/>
     * @return {Number}
     */

  }, {
    key: "getType",
    value: function getType() {
      return _BoundingVolume2.default.S_TYPE_AABB;
    }
    /**
     * 从顶点位置数组初始化AABB包围盒。<br/>
     * 其中包围盒中心点为几何中心。<br/>
     * @param {Number[]}[positions]
     */

  }, {
    key: "fromPositions",
    value: function fromPositions(positions) {
      var minX = Number.MAX_VALUE;
      var minY = Number.MAX_VALUE;
      var minZ = Number.MAX_VALUE;
      var maxX = -Number.MAX_VALUE;
      var maxY = -Number.MAX_VALUE;
      var maxZ = -Number.MAX_VALUE; // 遍历所有顶点

      for (var i = 0; i < positions.length; i += 3) {
        minX = Math.min(positions[i], minX);
        minY = Math.min(positions[i + 1], minY);
        minZ = Math.min(positions[i + 2], minZ);
        maxX = Math.max(positions[i], maxX);
        maxY = Math.max(positions[i + 1], maxY);
        maxZ = Math.max(positions[i + 2], maxZ);
      } // 中心点


      this._m_Center.setToInXYZ(minX + maxX, minY + maxY, minZ + maxZ);

      this._m_Center.multLength(0.5); // 半径


      this._m_XHalf = Math.abs(maxX - this._m_Center._m_X);
      this._m_YHalf = Math.abs(maxY - this._m_Center._m_Y);
      this._m_ZHalf = Math.abs(maxZ - this._m_Center._m_Z);
    }
    /**
     * 从min,max边界范围初始化AABB包围盒。<br/>
     * 其中包围盒中心点为min,max几何中心。<br/>
     * @param {Vector3}[min]
     * @param {Vector3}[max]
     */

  }, {
    key: "fromMinMax",
    value: function fromMinMax(min, max) {
      this._m_Center.setTo(max);

      this._m_Center.add(min);

      this._m_Center.multLength(0.5); // 计算半轴


      this._m_XHalf = Math.abs(max._m_X - this._m_Center._m_X);
      this._m_YHalf = Math.abs(max._m_Y - this._m_Center._m_Y);
      this._m_ZHalf = Math.abs(max._m_Z - this._m_Center._m_Z);
    }
    /**
     * 返回处于平面的哪一边。<br/>
     * @param {Plane}[plane]
     * @return {Number}[GroupPlane.S_SIDE_POSITIVE/GroupPlane.S_SIDE_NEGATIVE/GroupPlane.NONE]
     */

  }, {
    key: "whichSide",
    value: function whichSide(plane) {
      // 判断当前包围盒中心点到平面的距离
      var distance = plane.distance(this._m_Center); // 计算AABB包围盒沿着平面方向的半径

      var planeNormal = plane.getNormal();
      var radius = Math.abs(this._m_XHalf * planeNormal._m_X) + Math.abs(this._m_YHalf * planeNormal._m_Y) + Math.abs(this._m_ZHalf * planeNormal._m_Z); // 如果距离大于半径,说明处于平面正方向

      if (distance > radius) {
        return _Plane.default.S_SIDE_POSITIVE;
      } // 如果距离小于-半径,说明处于平面反方向
      else if (distance < -radius) {
        return _Plane.default.S_SIDE_NEGATIVE;
      } // 否则处于平面上
      else {
        return _Plane.default.S_SIDE_NONE;
      }
    }
    /**
     * 用指定的中心点以及半轴量拓展该AABBBoundingBox。<br/>
     * @param {Vector3}[center]
     * @param {Number}[xHalf]
     * @param {Number}[yHalf]
     * @param {Number}[zHalf]
     * @return {AABBBoundingBox}
     * @private
     */

  }, {
    key: "_mergeFromCenterAndHalf",
    value: function _mergeFromCenterAndHalf(center, xHalf, yHalf, zHalf) {
      if (this._m_XHalf == Number.POSITIVE_INFINITY || xHalf == Number.POSITIVE_INFINITY) {
        this._m_Center._m_X = 0;
        this._m_XHalf = Number.POSITIVE_INFINITY;
      } else {
        var low = this._m_Center._m_X - this._m_XHalf;

        if (low > center._m_X - xHalf) {
          low = center._m_X - xHalf;
        }

        var high = this._m_Center._m_X + this._m_XHalf;

        if (high < center._m_X + xHalf) {
          high = center._m_X + xHalf;
        }

        this._m_Center._m_X = (low + high) / 2.0;
        this._m_XHalf = high - this._m_Center._m_X;
      }

      if (this._m_YHalf == Number.POSITIVE_INFINITY || xHalf == Number.POSITIVE_INFINITY) {
        this._m_Center._m_Y = 0;
        this._m_YHalf = Number.POSITIVE_INFINITY;
      } else {
        var _low = this._m_Center._m_Y - this._m_YHalf;

        if (_low > center._m_Y - yHalf) {
          _low = center._m_Y - yHalf;
        }

        var _high = this._m_Center._m_Y + this._m_YHalf;

        if (_high < center._m_Y + yHalf) {
          _high = center._m_Y + yHalf;
        }

        this._m_Center._m_Y = (_low + _high) / 2.0;
        this._m_YHalf = _high - this._m_Center._m_Y;
      }

      if (this._m_ZHalf == Number.POSITIVE_INFINITY || xHalf == Number.POSITIVE_INFINITY) {
        this._m_Center._m_Z = 0;
        this._m_ZHalf = Number.POSITIVE_INFINITY;
      } else {
        var _low2 = this._m_Center._m_Z - this._m_ZHalf;

        if (_low2 > center._m_Z - zHalf) {
          _low2 = center._m_Z - zHalf;
        }

        var _high2 = this._m_Center._m_Z + this._m_ZHalf;

        if (_high2 < center._m_Z + zHalf) {
          _high2 = center._m_Z + zHalf;
        }

        this._m_Center._m_Z = (_low2 + _high2) / 2.0;
        this._m_ZHalf = _high2 - this._m_Center._m_Z;
      }

      return this;
    }
    /**
     * 合并一个BoundingVolume。<br/>
     * @param {BoundingVolume}[boundingVolume]
     * @return {BoundingVolume}
     */

  }, {
    key: "merge",
    value: function merge(boundingVolume) {
      if (boundingVolume) {
        switch (boundingVolume.getType()) {
          case _BoundingVolume2.default.S_TYPE_AABB:
            return this._mergeFromCenterAndHalf(boundingVolume._m_Center, boundingVolume._m_XHalf, boundingVolume._m_YHalf, boundingVolume._m_ZHalf);
            break;

          case _BoundingVolume2.default.S_TYPE_SPHERE:
            break;
        }
      } else {
        return this;
      }
    }
    /**
     * 使用指定boundingVolume初始化该AABBBoundingBox。<br/>
     * @param {BoundingVolume}[boundingVolume]
     */

  }, {
    key: "setTo",
    value: function setTo(boundingVolume) {
      if (boundingVolume.getType() == _BoundingVolume2.default.S_TYPE_AABB) {
        this._m_Center.setTo(boundingVolume._m_Center);

        this._m_XHalf = boundingVolume._m_XHalf;
        this._m_YHalf = boundingVolume._m_YHalf;
        this._m_ZHalf = boundingVolume._m_ZHalf;
      }
    }
    /**
     * 变换该AABBBoundingBox。<br/>
     * @param {Vector3}[scale 缩放]
     * @param {Quaternion}[rotation 旋转]
     * @param {Vector3}[translation 平移]
     * @param {AABBBoundingBox}[result 存放结果]
     */

  }, {
    key: "transform",
    value: function transform(scale, rotation, translation, result) {
      result = result || AABBBoundingBox.S_TEMP_AABB; // 修改中心点
      // 缩放

      this._m_Center.mult(scale, result._m_Center); // 旋转


      rotation.multVec3(result._m_Center); // 平移

      result._m_Center.add(translation); // 缩放半轴


      AABBBoundingBox.S_TEMP_VEC3.setToInXYZ(this._m_XHalf * Math.abs(scale._m_X), this._m_YHalf * Math.abs(scale._m_Y), this._m_ZHalf * Math.abs(scale._m_Z)); // 将旋转矩阵强制为正旋转,以获得最大半径

      _Matrix.default.fromQuaternion(rotation, AABBBoundingBox.S_TEMP_MAT4);

      AABBBoundingBox.S_TEMP_MAT4.absLocal();

      _Matrix.default.multiplyMV3In3x3(AABBBoundingBox.S_TEMP_VEC32, AABBBoundingBox.S_TEMP_VEC3, AABBBoundingBox.S_TEMP_MAT4); // 保存结果
      // 旋转后可能为-,所以取abs


      result._m_XHalf = Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_X);
      result._m_YHalf = Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_Y);
      result._m_ZHalf = Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_Z);
    }
    /**
     * 变换该AABBBoundaryBox。<br/>
     * @param {Matrix44}[mat44]
     * @param {AABBBoundingBox}[result]
     */

  }, {
    key: "transformFromMat44",
    value: function transformFromMat44(mat44, result) {
      result = result || AABBBoundingBox.S_TEMP_AABB;

      var pw = _Matrix.default.multiplyMV3(result._m_Center, this._m_Center, mat44);

      result._m_Center.multLength(1.0 / pw);

      var tran = AABBBoundingBox.S_TEMP_MAT4;
      tran.set(mat44); // 只保留旋转矩阵部分

      tran.keepRotation(); // 确保得到正向半程（即半径）

      tran.absLocal();
      AABBBoundingBox.S_TEMP_VEC3.setToInXYZ(this._m_XHalf, this._m_YHalf, this._m_ZHalf);

      _Matrix.default.multiplyMV3In3x3(AABBBoundingBox.S_TEMP_VEC32, AABBBoundingBox.S_TEMP_VEC3, tran);

      result.setHalfInXYZ(Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_X), Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_Y), Math.abs(AABBBoundingBox.S_TEMP_VEC32._m_Z));
    }
    /**
     * 返回最小点。<br/>
     * @param {Vector3}[min 存放结果,可为空]
     * @return {min}
     */

  }, {
    key: "getMin",
    value: function getMin(min) {
      min = min || new _Vector.default();
      min.setTo(this._m_Center);
      min.subInXYZ(this._m_XHalf, this._m_YHalf, this._m_ZHalf);
      return min;
    }
    /**
     * 返回最大点。<br/>
     * @param {Vector3}[max]
     * @return {Vector3}
     */

  }, {
    key: "getMax",
    value: function getMax(max) {
      max = max || new _Vector.default();
      max.setTo(this._m_Center);
      max.addInXYZ(this._m_XHalf, this._m_YHalf, this._m_ZHalf);
      return max;
    }
  }, {
    key: "contains",
    value: function contains(boundingVolume) {
      switch (boundingVolume.getType()) {
        case _BoundingVolume2.default.S_TYPE_AABB:
          var min = this.getMin(AABBBoundingBox.S_TEMP_VEC3);
          var max = this.getMax(AABBBoundingBox.S_TEMP_VEC32);
          var tagMin = boundingVolume.getMin(AABBBoundingBox.S_TEMP_VEC33);
          var tagMax = boundingVolume.getMax(AABBBoundingBox.S_TEMP_VEC34); // return (tagMax._m_X <= max._m_X && tagMin._m_X >= min._m_X) && (tagMax._m_Y <= max._m_Y && tagMin._m_Y >= min._m_Y) && (tagMax._m_Z <= max._m_Z && tagMin._m_Z >= min._m_Z);

          return !(tagMin._m_X > max._m_X || tagMin._m_Y > max._m_Y || tagMin._m_Z > max._m_Z || tagMax._m_X < min._m_X || tagMax._m_Y < min._m_Y || tagMax._m_Z < min._m_Z);

        case _BoundingVolume2.default.S_TYPE_SPHERE:
          return false;
      }

      return false;
    }
  }]);

  return AABBBoundingBox;
}(_BoundingVolume2.default);

exports["default"] = AABBBoundingBox;

_defineProperty(AABBBoundingBox, "S_TEMP_VEC3", new _Vector.default());

_defineProperty(AABBBoundingBox, "S_TEMP_VEC32", new _Vector.default());

_defineProperty(AABBBoundingBox, "S_TEMP_VEC33", new _Vector.default());

_defineProperty(AABBBoundingBox, "S_TEMP_VEC34", new _Vector.default());

_defineProperty(AABBBoundingBox, "S_TEMP_MAT4", new _Matrix.default());

_defineProperty(AABBBoundingBox, "S_TEMP_AABB", new AABBBoundingBox());

/***/ }),

/***/ 1846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BoundingVolume2 = _interopRequireDefault(__webpack_require__(1322));

var _Plane = _interopRequireDefault(__webpack_require__(7088));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * BoundingSphere。<br/>
 * 包围球(边界球)定义一组顶点的的边界范围，通常用于更快的边界计算（比如求交，初步碰撞），<br/>
 * 可以使用一组范围顶点数据初始化边界球，或通过其他BoundingVolume获取边界球。<br/>
 * @author Kkk
 * @date 2021年3月20日15点50分
 */
var BoundingSphere = /*#__PURE__*/function (_BoundingVolume) {
  _inherits(BoundingSphere, _BoundingVolume);

  var _super = _createSuper(BoundingSphere);

  function BoundingSphere(props) {
    var _this;

    _classCallCheck(this, BoundingSphere);

    _this = _super.call(this, props); // 半径

    _this._m_Radius = 0;
    return _this;
  }
  /**
   * 设置半径。<br/>
   * @param radius
   */


  _createClass(BoundingSphere, [{
    key: "setRaiuds",
    value: function setRaiuds(radius) {
      this._m_Radius = radius;
    }
    /**
     * 返回半径。<br/>
     * @return {number}
     */

  }, {
    key: "getRadius",
    value: function getRadius() {
      return this._m_Radius;
    }
  }, {
    key: "getType",
    value: function getType() {
      return _BoundingVolume2.default.S_TYPE_SPHERE;
    }
    /**
     * 返回处于平面的哪一边。<br/>
     * @param {Plane}[plane]
     * @return {Number}[GroupPlane.S_SIDE_POSITIVE/GroupPlane.S_SIDE_NEGATIVE/GroupPlane.NONE]
     */

  }, {
    key: "whichSide",
    value: function whichSide(plane) {
      var distance = plane.distance(this._m_Center);

      if (distance > this._m_Radius) {
        return _Plane.default.S_SIDE_POSITIVE;
      } else if (distance < -this._m_Radius) {
        return _Plane.default.S_SIDE_NEGATIVE;
      }

      return _Plane.default.S_SIDE_NONE;
    }
  }]);

  return BoundingSphere;
}(_BoundingVolume2.default);

exports["default"] = BoundingSphere;

_defineProperty(BoundingSphere, "_S_RADIUS_EPSILON", 1.0 + 0.00001);

/***/ }),

/***/ 1322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BoundingVolume = /*#__PURE__*/function () {
  function BoundingVolume(props) {
    _classCallCheck(this, BoundingVolume);

    // 优先检测面
    this._m_PriorityPlane = 0; // 中心点

    this._m_Center = new _Vector.default();
  }
  /**
   * 设置中心点。<br/>
   * @param {Vector3}[center]
   */


  _createClass(BoundingVolume, [{
    key: "setCenter",
    value: function setCenter(center) {
      this._m_Center.setTo(center);
    }
    /**
     * 返回中心点。<br/>
     * @param {Vector3}[center]
     * @return {Vector3}
     */

  }, {
    key: "getCenter",
    value: function getCenter(center) {
      center = center || new _Vector.default();
      center.setTo(this._m_Center);
      return center;
    }
    /**
     * 返回包围体类型。<br/>
     * @return {Number}[无效包围体返回-1]
     */

  }, {
    key: "getType",
    value: function getType() {
      return -1;
    }
    /**
     * 返回处于平面的哪一边。<br/>
     * @param {GroupPlane}[plane]
     */

  }, {
    key: "whichSide",
    value: function whichSide(plane) {}
  }, {
    key: "setTo",
    value:
    /**
     * 将当前包围体初始化为指定包围体。<br/>
     * @param {BoundingVolume}
     */
    function setTo(boundingVolume) {}
  }, {
    key: "transform",
    value:
    /**
     * 将缩放，旋转和平移变换应用到包围体。<br/>
     * @param {Vector3}[scale 缩放]
     * @param {Quaternion}[rotation 旋转]
     * @param {Vector3}[translation 平移]
     * @param {BoundingVolume}[result 存放结果,可为null]
     */
    function transform(scale, rotation, translation, result) {}
  }, {
    key: "transformFromMat44",
    value:
    /**
     * 将4x4变换矩阵应用到包围体。<br/>
     * @param {Matrix44}[mat44]
     * @param {BoundingVolume}[result]
     */
    function transformFromMat44(mat44, result) {}
  }, {
    key: "merge",
    value:
    /**
     * 合并一个BoundingVolume。<br/>
     * @param {BoundingVolume}[boundingVolume]
     * @return {BoundingVolume}
     */
    function merge(boundingVolume) {
      return null;
    }
  }, {
    key: "setPriorityPlane",
    value:
    /**
     * 设置优先检测面。<br/>
     * 告诉引擎优先检测视锥体哪个平面。<br/>
     * @param {Number}[priorityPlane]
     */
    function setPriorityPlane(priorityPlane) {
      this._m_PriorityPlane = priorityPlane;
    }
    /**
     * 返回优先检测面。<br/>
     * @return {Number}
     */

  }, {
    key: "getPriorityPlane",
    value: function getPriorityPlane() {
      return this._m_PriorityPlane;
    }
    /**
     * 返回于指定包围体是否包含。<br/>
     * 如果完全包含，则返回true，否则返回false。<br/>
     * @param {BoundingVolume}[boundingVolume]
     * @return {Boolean}
     */

  }, {
    key: "contains",
    value: function contains(boundingVolume) {
      return false;
    }
    /**
     * 返回给定点与中心点距离。<br/>
     * @param {Vector3}[p]
     * @return {Number}
     */

  }, {
    key: "distance",
    value: function distance(p) {
      return this._m_Center.distance(p);
    }
  }]);

  return BoundingVolume;
}();

exports["default"] = BoundingVolume;

_defineProperty(BoundingVolume, "S_TYPE_AABB", 0);

_defineProperty(BoundingVolume, "S_TYPE_SPHERE", 1);

/***/ }),

/***/ 2320:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Matrix44 = /*#__PURE__*/function () {
  function Matrix44() {
    _classCallCheck(this, Matrix44);

    this.m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    this.bufferData = new Float32Array(16);
  }
  /**
   * 设置为单位矩阵。<br/>
   */


  _createClass(Matrix44, [{
    key: "identity",
    value: function identity() {
      this.m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    /**
     * 应用缩放。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     * @return {Matrix44}
     */

  }, {
    key: "scale",
    value: function scale(x, y, z) {
      this.m[0] *= x;
      this.m[4] *= y;
      this.m[8] *= z;
      this.m[1] *= x;
      this.m[5] *= y;
      this.m[9] *= z;
      this.m[2] *= x;
      this.m[6] *= y;
      this.m[10] *= z;
      this.m[3] *= x;
      this.m[7] *= y;
      this.m[11] *= z;
      return this;
    }
    /**
     * 应用平移。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     * @return {Matrix44}
     */

  }, {
    key: "translate",
    value: function translate(x, y, z) {
      var m3 = this.m[3];
      this.m[0] += m3 * x;
      this.m[1] += m3 * y;
      this.m[2] += m3 * z;
      var m7 = this.m[7];
      this.m[4] += m7 * x;
      this.m[5] += m7 * y;
      this.m[6] += m7 * z;
      var m11 = this.m[11];
      this.m[8] += m11 * x;
      this.m[9] += m11 * y;
      this.m[10] += m11 * z;
      var m15 = this.m[15];
      this.m[12] += m15 * x;
      this.m[13] += m15 * y;
      this.m[14] += m15 * z;
      return this;
    }
    /**
     * 计算视图矩阵。<br/>
     * @param {Vector3}[eye]
     * @param {Vector3}[at]
     * @param {Vector3}[up]
     * @param {Array}[result]
     * @returns {Matrix44}[viewMatrix]
     */

  }, {
    key: "lookAt",
    value:
    /**
     * 计算视图矩阵。<br/>
     * @param {Vector3}[eye]
     * @param {Vector3}[at]
     * @param {Vector3}[up]
     * @returns {Matrix44}[viewMatrix]
     */
    function lookAt(eye, at, up) {
      this.m = Matrix44.lookAt(eye, at, up, this.m);
      return this;
    }
    /**
     * 矩阵求逆。
     */

  }, {
    key: "inert",
    value: function inert() {
      var ok = Matrix44.invert(this.m, Matrix44._S_TEMP_MAT4.m);

      if (ok) {
        this.set(Matrix44._S_TEMP_MAT4);
      }
    }
    /**
     * 矩阵求逆并返回求逆后的结果。
     * @param {Matrix44}[result 结果矩阵]
     * @returns {Matrix44}[结果矩阵,求逆失败返回null]
     */

  }, {
    key: "inertRetNew",
    value: function inertRetNew(result) {
      var ok = Matrix44.invert(this.m, Matrix44._S_TEMP_MAT4.m);

      if (ok) {
        result = result || new Matrix44();
        result.set(Matrix44._S_TEMP_MAT4);
        return result;
      }

      return null;
    }
    /**
     * 矩阵求逆。
     * @param {Number[]}[a 输入矩阵数组]
     * @param {Number[]}[out 输出矩阵数组]
     * @returns {Number[]}[如果求逆失败,返回null]
     */

  }, {
    key: "set",
    value:
    /**
     * 将当前矩阵设置为指定矩阵。<br/>
     * @param {Matrix44}[mat44]
     */
    function set(mat44) {
      for (var i = 0; i < 16; i++) {
        this.m[i] = mat44.m[i];
      }
    }
    /**
     * 将当前矩阵设置为指定矩阵数组。<br/>
     * @param {Number[]}[array]
     */

  }, {
    key: "setArray",
    value: function setArray(array) {
      for (var i = 0; i < 16; i++) {
        this.m[i] = array[i];
      }
    }
    /**
     * 将当前矩阵设置为指定矩阵数组的转置。<br/>
     * @param {Number[]}[array]
     */

  }, {
    key: "setArrayTranspose",
    value: function setArrayTranspose(array) {
      for (var i = 0, t = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
          this.m[t++] = array[j * 4 + i];
        }
      }
    }
    /**
     * 保留旋转矩阵部分。<br/>
     */

  }, {
    key: "keepRotation",
    value: function keepRotation() {
      this.m[12] = this.m[13] = this.m[14] = 0.0;
      this.m[15] = 1.0;
    }
    /**
     * 转置该矩阵。<br/>
     */

  }, {
    key: "transpose",
    value: function transpose() {
      var array = [];

      for (var i = 0; i < this.m.length; i++) {
        array[i] = this.m[i];
      }

      for (var _i = 0, t = 0; _i < 4; _i++) {
        for (var j = 0; j < 4; j++) {
          this.m[t++] = array[j * 4 + _i];
        }
      }
    }
    /**
     * 将矩阵所有值设置为正。<br/>
     */

  }, {
    key: "absLocal",
    value: function absLocal() {
      for (var i = 0; i < 16; i++) {
        this.m[i] = Math.abs(this.m[i]);
      }
    }
    /**
     * 根据指定的边界定义平行投影矩阵。<br/>
     * @param {Array}[m 保存透视矩阵的浮点数组]
     * @param {Number}[offset 将偏移量偏移到写入透视矩阵数据的浮点数组m中]
     * @param {Number}[left]
     * @param {Number}[right]
     * @param {Number}[top]
     * @param {Number}[bottom]
     * @param {Number}[near]
     * @param {Number}[far]
     */

  }, {
    key: "perspectiveM",
    value:
    /**
     * 根据视场角度定义投影矩阵，纵横比和Z剪裁平面。
     * @param {Array}[m保存透视矩阵的浮点数组]
     * @param {Number}[offset将偏移量偏移到写入透视矩阵数据的浮点数组m中]
     * @param {Number}[fovyY方向的视野，以度为单位]
     * @param {Number}[aspect视区的纵横比]
     * @param {Number}[zNear]
     * @param {Number}[zFar]
     */
    function perspectiveM(fovy, aspect, zNear, zFar) {
      // console.log('fovy:' + fovy + ',aspect:' + aspect + ',zNear:' + zNear + ',zFar:' + zFar);
      Matrix44.perspectiveM(this.m, 0, fovy, aspect, zNear, zFar);
      return this;
    }
  }, {
    key: "parallelM",
    value: function parallelM(left, right, top, bottom, near, far) {
      this.identity();
      Matrix44.parallelM(this.m, 0, left, right, top, bottom, near, far);
      return this;
    }
    /**
     * 返回矩阵数值。<br/>
     * @returns {number[]}
     */

  }, {
    key: "getData",
    value: function getData() {
      return this.m;
    }
  }, {
    key: "getBufferData",
    value: function getBufferData() {
      this.bufferData.set(this.m);
      return this.bufferData;
    }
  }, {
    key: "toString",
    value: function toString() {
      return '[' + this.m[0] + ',' + this.m[1] + ',' + this.m[2] + ',' + this.m[3] + ',\n' + '' + this.m[4] + ',' + this.m[5] + ',' + this.m[6] + ',' + this.m[7] + ',\n' + '' + this.m[8] + ',' + this.m[9] + ',' + this.m[10] + ',' + this.m[11] + ',\n' + '' + this.m[12] + ',' + this.m[13] + ',' + this.m[14] + ',' + this.m[15] + ']';
    }
  }], [{
    key: "lookAt",
    value: function lookAt(eye, at, up, result) {
      // ndc是左手系
      var t = eye.subRetNew(at).normal();
      var r = up.crossRetNew(t).normal();
      var u = t.crossRetNew(r).normal();
      result = result || new Array(16).fill(0);
      result[0] = r._m_X;
      result[4] = r._m_Y;
      result[8] = r._m_Z;
      result[3] = 0;
      result[1] = u._m_X;
      result[5] = u._m_Y;
      result[9] = u._m_Z;
      result[7] = 0;
      result[2] = t._m_X;
      result[6] = t._m_Y;
      result[10] = t._m_Z;
      result[11] = 0;
      result[12] = -(eye._m_X * r._m_X + eye._m_Y * r._m_Y + eye._m_Z * r._m_Z);
      result[13] = -(eye._m_X * u._m_X + eye._m_Y * u._m_Y + eye._m_Z * u._m_Z);
      result[14] = -(eye._m_X * t._m_X + eye._m_Y * t._m_Y + eye._m_Z * t._m_Z);
      result[15] = 1;
      return result;
    }
  }, {
    key: "invert",
    value: function invert(a, out) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15],
          b00 = a00 * a11 - a01 * a10,
          b01 = a00 * a12 - a02 * a10,
          b02 = a00 * a13 - a03 * a10,
          b03 = a01 * a12 - a02 * a11,
          b04 = a01 * a13 - a03 * a11,
          b05 = a02 * a13 - a03 * a12,
          b06 = a20 * a31 - a21 * a30,
          b07 = a20 * a32 - a22 * a30,
          b08 = a20 * a33 - a23 * a30,
          b09 = a21 * a32 - a22 * a31,
          b10 = a21 * a33 - a23 * a31,
          b11 = a22 * a33 - a23 * a32,
          // 计算行列式
      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
  }, {
    key: "parallelM",
    value: function parallelM(m, offset, left, right, top, bottom, near, far) {
      // 这里假设传入的矩阵数组m已经是单位矩阵,则只计算几个重要行列值
      // scale
      m[offset + 0] = 2.0 / (right * 1.0 - left);
      m[offset + 5] = 2.0 / (top * 1.0 - bottom);
      m[offset + 10] = -2.0 / (far * 1.0 - near);
      m[offset + 15] = 1.0; // translation

      m[offset + 12] = -(right + left) / (right * 1.0 - left);
      m[offset + 13] = -(top + bottom) / (top * 1.0 - bottom);
      m[offset + 14] = -(far + near) / (far * 1.0 - near);
    }
    /**
     * 根据视场角度，纵横比和Z剪裁平面定义透视投影矩阵。
     * @param {Array}[m 保存透视矩阵的浮点数组]
     * @param {Number}[offset 将偏移量偏移到写入透视矩阵数据的浮点数组m中]
     * @param {Number}[fovy 方向的视野，以度为单位]
     * @param {Number}[aspect 视区的纵横比]
     * @param {Number}[zNear]
     * @param {Number}[zFar]
     */

  }, {
    key: "perspectiveM",
    value: function perspectiveM(m, offset, fovy, aspect, zNear, zFar) {
      var f = 1.0 / Math.tan(fovy * (Math.PI / 360.0));
      var rangeReciprocal = 1.0 / (zNear - zFar);
      m[offset + 0] = f / aspect;
      m[offset + 1] = 0.0;
      m[offset + 2] = 0.0;
      m[offset + 3] = 0.0;
      m[offset + 4] = 0.0;
      m[offset + 5] = f;
      m[offset + 6] = 0.0;
      m[offset + 7] = 0.0;
      m[offset + 8] = 0.0;
      m[offset + 9] = 0.0;
      m[offset + 10] = (zFar + zNear) * rangeReciprocal;
      m[offset + 11] = -1.0;
      m[offset + 12] = 0.0;
      m[offset + 13] = 0.0;
      m[offset + 14] = 2.0 * zFar * zNear * rangeReciprocal;
      m[offset + 15] = 0.0;
    }
    /**
     * 两个矩阵相乘,结果存放于result
     * @param result
     * @param resultOffset
     * @param lhs
     * @param lhsOffset
     * @param rhs
     * @param rhsOffset
     */

  }, {
    key: "multiplyMM",
    value: function multiplyMM(result, resultOffset, lhs, lhsOffset, rhs, rhsOffset) {
      result.m[resultOffset + 0] = rhs.m[0] * lhs.m[0] + rhs.m[1] * lhs.m[4] + rhs.m[2] * lhs.m[8] + rhs.m[3] * lhs.m[12];
      result.m[resultOffset + 1] = rhs.m[0] * lhs.m[1] + rhs.m[1] * lhs.m[5] + rhs.m[2] * lhs.m[9] + rhs.m[3] * lhs.m[13];
      result.m[resultOffset + 2] = rhs.m[0] * lhs.m[2] + rhs.m[1] * lhs.m[6] + rhs.m[2] * lhs.m[10] + rhs.m[3] * lhs.m[14];
      result.m[resultOffset + 3] = rhs.m[0] * lhs.m[3] + rhs.m[1] * lhs.m[7] + rhs.m[2] * lhs.m[11] + rhs.m[3] * lhs.m[15];
      result.m[resultOffset + 4] = rhs.m[4] * lhs.m[0] + rhs.m[5] * lhs.m[4] + rhs.m[6] * lhs.m[8] + rhs.m[7] * lhs.m[12];
      result.m[resultOffset + 5] = rhs.m[4] * lhs.m[1] + rhs.m[5] * lhs.m[5] + rhs.m[6] * lhs.m[9] + rhs.m[7] * lhs.m[13];
      result.m[resultOffset + 6] = rhs.m[4] * lhs.m[2] + rhs.m[5] * lhs.m[6] + rhs.m[6] * lhs.m[10] + rhs.m[7] * lhs.m[14];
      result.m[resultOffset + 7] = rhs.m[4] * lhs.m[3] + rhs.m[5] * lhs.m[7] + rhs.m[6] * lhs.m[11] + rhs.m[7] * lhs.m[15];
      result.m[resultOffset + 8] = rhs.m[8] * lhs.m[0] + rhs.m[9] * lhs.m[4] + rhs.m[10] * lhs.m[8] + rhs.m[11] * lhs.m[12];
      result.m[resultOffset + 9] = rhs.m[8] * lhs.m[1] + rhs.m[9] * lhs.m[5] + rhs.m[10] * lhs.m[9] + rhs.m[11] * lhs.m[13];
      result.m[resultOffset + 10] = rhs.m[8] * lhs.m[2] + rhs.m[9] * lhs.m[6] + rhs.m[10] * lhs.m[10] + rhs.m[11] * lhs.m[14];
      result.m[resultOffset + 11] = rhs.m[8] * lhs.m[3] + rhs.m[9] * lhs.m[7] + rhs.m[10] * lhs.m[11] + rhs.m[11] * lhs.m[15];
      result.m[resultOffset + 12] = rhs.m[12] * lhs.m[0] + rhs.m[13] * lhs.m[4] + rhs.m[14] * lhs.m[8] + rhs.m[15] * lhs.m[12];
      result.m[resultOffset + 13] = rhs.m[12] * lhs.m[1] + rhs.m[13] * lhs.m[5] + rhs.m[14] * lhs.m[9] + rhs.m[15] * lhs.m[13];
      result.m[resultOffset + 14] = rhs.m[12] * lhs.m[2] + rhs.m[13] * lhs.m[6] + rhs.m[14] * lhs.m[10] + rhs.m[15] * lhs.m[14];
      result.m[resultOffset + 15] = rhs.m[12] * lhs.m[3] + rhs.m[13] * lhs.m[7] + rhs.m[14] * lhs.m[11] + rhs.m[15] * lhs.m[15];
    }
    /**
     * result = m * v。<br/>
     * @param {Vector4}[result 结果向量]
     * @param {Vector4}[v 源向量]
     * @param {Matrix44}[m 目标矩阵]
     */

  }, {
    key: "multiplyMV",
    value: function multiplyMV(result, v, m) {
      // result._m_X = v._m_X * m.m[0] + v._m_Y * m.m[1] + v._m_Z * m.m[2] + v._m_W * m.m[3];
      // result._m_Y = v._m_X * m.m[4] + v._m_Y * m.m[5] + v._m_Z * m.m[6] + v._m_W * m.m[7];
      // result._m_Z = v._m_X * m.m[8] + v._m_Y * m.m[9] + v._m_Z * m.m[10] + v._m_W * m.m[11];
      // result._m_W = v._m_X * m.m[12] + v._m_Y * m.m[13] + v._m_Z * m.m[14] + v._m_W * m.m[15];
      result._m_X = v._m_X * m.m[0] + v._m_Y * m.m[4] + v._m_Z * m.m[8] + v._m_W * m.m[12];
      result._m_Y = v._m_X * m.m[1] + v._m_Y * m.m[5] + v._m_Z * m.m[9] + v._m_W * m.m[13];
      result._m_Z = v._m_X * m.m[2] + v._m_Y * m.m[6] + v._m_Z * m.m[10] + v._m_W * m.m[14];
      result._m_W = v._m_X * m.m[3] + v._m_Y * m.m[7] + v._m_Z * m.m[11] + v._m_W * m.m[15];
    }
    /**
     * 将一个vec3与mat44相乘,这里假设了第4个分量w存在并为1。<br/>
     * result = m * v的旋转部分,同时每个分量添加m的平移部分。<br/>
     * 这里假设了w等于1，所以各分量加上了m的平移部分，并返回计算w分量值。<br/>
     * @param {Vector3}[result]
     * @param {Vector3}[v]
     * @param {Matrix44}[m]
     * @return {Number}
     */

  }, {
    key: "multiplyMV3",
    value: function multiplyMV3(result, v, m) {
      // result._m_X = v._m_X * m.m[0] + v._m_Y * m.m[1] + v._m_Z * m.m[2] + m.m[3];
      // result._m_Y = v._m_X * m.m[4] + v._m_Y * m.m[5] + v._m_Z * m.m[6] + m.m[7];
      // result._m_Z = v._m_X * m.m[8] + v._m_Y * m.m[9] + v._m_Z * m.m[10] + m.m[11];
      // return v._m_X * m.m[12] + v._m_Y * m.m[13] + v._m_Z * m.m[14] + m.m[15];
      // 在cpu计算统一用右乘
      result._m_X = v._m_X * m.m[0] + v._m_Y * m.m[4] + v._m_Z * m.m[8] + m.m[12];
      result._m_Y = v._m_X * m.m[1] + v._m_Y * m.m[5] + v._m_Z * m.m[9] + m.m[13];
      result._m_Z = v._m_X * m.m[2] + v._m_Y * m.m[6] + v._m_Z * m.m[10] + m.m[14];
      return v._m_X * m.m[3] + v._m_Y * m.m[7] + v._m_Z * m.m[11] + m.m[15];
    }
    /**
     * 将一个vec3与mat44的3x3部分相乘。<br/>
     * result = m3x3 * v。<br/>
     * @param {Vector3}[result]
     * @param {Vector3}[v]
     * @param {Matrix44}[m]
     */

  }, {
    key: "multiplyMV3In3x3",
    value: function multiplyMV3In3x3(result, v, m) {
      result._m_X = v._m_X * m.m[0] + v._m_Y * m.m[4] + v._m_Z * m.m[8];
      result._m_Y = v._m_X * m.m[1] + v._m_Y * m.m[5] + v._m_Z * m.m[9];
      result._m_Z = v._m_X * m.m[2] + v._m_Y * m.m[6] + v._m_Z * m.m[10];
    }
    /**
     * 从指定的平移，旋转和缩放构造变换矩阵。<br/>
     * @param {Vector3}[translation 平移]
     * @param {Quaternion}[rotation 旋转]
     * @param {Vector3}[scale 缩放]
     * @param {Matrix44}[result 结果矩阵]
     * @returns {Matrix44}
     */

  }, {
    key: "composeMat4",
    value: function composeMat4(translation, rotation, scale, result) {
      Matrix44.fromQuaternion(rotation, result);
      result.scale(scale._m_X, scale._m_Y, scale._m_Z);
      result.translate(translation._m_X, translation._m_Y, translation._m_Z);
      return result;
    }
    /**
     * 从矩阵中解析translation,rotation和scale成分。<br/>
     * @param {Matrix44}[mat44]
     * @param {Vector3}[translation]
     * @param {Quaternion}[rotation]
     * @param {Vector3}[scale]
     */

  }, {
    key: "decomposeMat4",
    value: function decomposeMat4(mat44, translation, rotation, scale) {
      // 提取矩阵三个量的长度
      Matrix44._S_TEMP_VEC3.setToInXYZ(mat44.m[0], mat44.m[1], mat44.m[2]);

      var sx = Matrix44._S_TEMP_VEC3.length();

      Matrix44._S_TEMP_VEC3.setToInXYZ(mat44.m[4], mat44.m[5], mat44.m[6]);

      var sy = Matrix44._S_TEMP_VEC3.length();

      Matrix44._S_TEMP_VEC3.setToInXYZ(mat44.m[8], mat44.m[9], mat44.m[10]);

      var sz = Matrix44._S_TEMP_VEC3.length(); // 如果det结果为negative,则需要反转一个比例


      var det = Matrix44.determinantMat4(mat44);

      if (det < 0) {
        sx = -sx;
      }

      translation.setToInXYZ(mat44.m[12], mat44.m[13], mat44.m[14]); // 缩放以及旋转部分

      Matrix44._S_TEMP_MAT4.set(mat44); // 去掉缩放,得到旋转部分矩阵


      var invSX = 1.0 / sx;
      var invSY = 1.0 / sy;
      var invSZ = 1.0 / sz;
      Matrix44._S_TEMP_MAT4.m[0] *= invSX;
      Matrix44._S_TEMP_MAT4.m[1] *= invSX;
      Matrix44._S_TEMP_MAT4.m[2] *= invSX;
      Matrix44._S_TEMP_MAT4.m[4] *= invSY;
      Matrix44._S_TEMP_MAT4.m[5] *= invSY;
      Matrix44._S_TEMP_MAT4.m[6] *= invSY;
      Matrix44._S_TEMP_MAT4.m[8] *= invSZ;
      Matrix44._S_TEMP_MAT4.m[9] *= invSZ;
      Matrix44._S_TEMP_MAT4.m[10] *= invSZ; // 计算到四元数中

      rotation.fromMat44(Matrix44._S_TEMP_MAT4); // 缩放

      scale.setToInXYZ(sx, sy, sz);
    }
    /**
     * 返回指定行列式。<br/>
     * @param {Matrix44}[mat]
     * @return {number}
     */

  }, {
    key: "determinantMat4",
    value: function determinantMat4(mat) {
      // 缓存矩阵值,纪大提高计算速度!!
      var a00 = mat.m[0];
      var a01 = mat.m[1];
      var a02 = mat.m[2];
      var a03 = mat.m[3];
      var a10 = mat.m[4];
      var a11 = mat.m[5];
      var a12 = mat.m[6];
      var a13 = mat.m[7];
      var a20 = mat.m[8];
      var a21 = mat.m[9];
      var a22 = mat.m[10];
      var a23 = mat.m[11];
      var a30 = mat.m[12];
      var a31 = mat.m[13];
      var a32 = mat.m[14];
      var a33 = mat.m[15];
      return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 + a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 + a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 + a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 + a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 + a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
    }
    /**
     * 从四元数初始化变换矩阵。<br/>
     * @param {Quaternion}[quaternion]
     * @param {Matrix44}[result]
     * @return {Matrix44}
     */

  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(quaternion, result) {
      var x = quaternion._m_X;
      var y = quaternion._m_Y;
      var z = quaternion._m_Z;
      var w = quaternion._m_W;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      result.m[0] = 1 - (yy + zz);
      result.m[4] = xy - wz;
      result.m[8] = xz + wy;
      result.m[1] = xy + wz;
      result.m[5] = 1 - (xx + zz);
      result.m[9] = yz - wx;
      result.m[2] = xz - wy;
      result.m[6] = yz + wx;
      result.m[10] = 1 - (xx + yy); // last column

      result.m[3] = 0;
      result.m[7] = 0;
      result.m[11] = 0; // bottom row

      result.m[12] = 0;
      result.m[13] = 0;
      result.m[14] = 0;
      result.m[15] = 1;
      return result;
    }
  }]);

  return Matrix44;
}();

exports["default"] = Matrix44;

_defineProperty(Matrix44, "_S_TEMP_MAT4", new Matrix44());

_defineProperty(Matrix44, "_S_TEMP_VEC3", new _Vector.default());

/***/ }),

/***/ 431:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var aTr = 1.0 / 180.0 * Math.PI;
var rTa = 180.0 / Math.PI;
var pD = 180.0;
var pDN = 1.0 / pD;
var ppD = 1.0 / Math.PI;
/**
 * 增强js没有的数学部分。<br/>
 * @author Kkk
 * @date 2021年2月2日15点25分
 */

var MoreMath = /*#__PURE__*/function () {
  function MoreMath() {
    _classCallCheck(this, MoreMath);
  }
  /**
   * 将角度转为弧度。<br/>
   * @param {Number}[angdeg 角度值]
   * @returns {Number}[返回转换的弧度值]
   */


  _createClass(MoreMath, null, [{
    key: "toRadians",
    value: function toRadians(angdeg) {
      return angdeg * pDN * Math.PI;
    }
    /**
     * 将弧度转为角度。<br/>
     * @param {Number}[radians 弧度值]
     * @returns {Number}[返回转换的角度值]
     */

  }, {
    key: "toAngle",
    value: function toAngle(radians) {
      return radians * pD * ppD;
    }
    /**
     * 对单值进行线性插值。<br/>
     * @param {Number}[scale 0-1插值阈值]
     * @param {Number}[startValue 起始值]
     * @param {Number}[endValue 结束值]
     * @return {Number}[返回startValue~endValue之间的插值]
     */

  }, {
    key: "interpolateLinear",
    value: function interpolateLinear(scale, startValue, endValue) {
      if (startValue == endValue) {
        return startValue;
      }

      if (scale <= 0.0) {
        return startValue;
      }

      if (scale >= 1.0) {
        return endValue;
      }

      return (1.0 - scale) * startValue + scale * endValue;
    }
    /**
     * 对Vector3进行插值。<br/>
     * @param {Number}[scale 0-1插值阈值]
     * @param {Vector3}[startValue 起始值]
     * @param {Vector3}[endValue 结束值]
     * @return {Vector3}[返回startValue~endValue之间的插值]
     */

  }, {
    key: "interpolateLinearVec3",
    value: function interpolateLinearVec3(scale, startValue, endValue) {
      if (startValue == endValue) {
        return startValue;
      }

      if (scale <= 0.0) {
        return startValue;
      }

      if (scale >= 1.0) {
        return endValue;
      }

      startValue.multLength(1.0 - scale);
      startValue.add(endValue.mulReturn(scale));
      return startValue;
    }
  }]);

  return MoreMath;
}();

exports["default"] = MoreMath;

_defineProperty(MoreMath, "S_HALF_PI", 0.5 * Math.PI);

_defineProperty(MoreMath, "S_DEG_TO_RAD", 0.0174532925);

_defineProperty(MoreMath, "S_RAD_TO_DEG", 57.295779513);

_defineProperty(MoreMath, "S_TWO_PI", Math.PI * 2);

/***/ }),

/***/ 7088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Plane = /*#__PURE__*/function () {
  // 平面的正方向上
  // 平面的反方向上
  // 平面上
  function Plane() {
    _classCallCheck(this, Plane);

    // 平面的法线
    this._m_Normal = new _Vector.default(); // 平面的距离原点的距离常量

    this._m_D = 0;
  }
  /**
   * 设置平面距离原点的距离常量。<br/>
   * @param {Number}[d]
   */


  _createClass(Plane, [{
    key: "setD",
    value: function setD(d) {
      this._m_D = d;
    }
    /**
     * 返回平面距离原点的距离常量。<br/>
     * @return {Number}
     */

  }, {
    key: "getD",
    value: function getD() {
      return this._m_D;
    }
    /**
     * 设置平面的法线。<br/>
     * @param {Vector3}[normal 这里假设已经归一化]
     */

  }, {
    key: "setNormal",
    value: function setNormal(normal) {
      this._m_Normal.setTo(normal);

      this._m_Normal.normal();
    }
    /**
     * 设置平面的法线。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setNormaXYZ",
    value: function setNormaXYZ(x, y, z) {
      this._m_Normal.setToInXYZ(x, y, z);

      this._m_Normal.normal();
    }
    /**
     * 返回平面法线。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getNormal",
    value: function getNormal() {
      return this._m_Normal;
    }
    /**
     * 返回点到平面的距离，距离包含正负，如果处于平面返回0。<br/>
     * @param {Vector3}[point]
     * @return {Number}
     */

  }, {
    key: "distance",
    value: function distance(point) {
      // 带入平面定义方程
      return this._m_Normal.dot(point) - this._m_D;
    }
  }]);

  return Plane;
}();

exports["default"] = Plane;

_defineProperty(Plane, "S_SIDE_POSITIVE", 1);

_defineProperty(Plane, "S_SIDE_NEGATIVE", Plane.S_SIDE_POSITIVE << 1);

_defineProperty(Plane, "S_SIDE_NONE", Plane.S_SIDE_POSITIVE << 2);

/***/ }),

/***/ 453:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Quaternion = /*#__PURE__*/function () {
  // 内部缓存
  function Quaternion(x, y, z, w) {
    _classCallCheck(this, Quaternion);

    this._m_X = x || 0;
    this._m_Y = y || 0;
    this._m_Z = z || 0;
    this._m_W = w || 0;
  }
  /**
   * 设置四元数为指定四元数。<br/>
   * @param {Quaternion}[quaternion]
   */


  _createClass(Quaternion, [{
    key: "setTo",
    value: function setTo(quaternion) {
      this._m_X = quaternion._m_X;
      this._m_Y = quaternion._m_Y;
      this._m_Z = quaternion._m_Z;
      this._m_W = quaternion._m_W;
    }
    /**
     * 设置四元数为指定分量值。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     * @param {Number}[w]
     */

  }, {
    key: "setToInXYZW",
    value: function setToInXYZW(x, y, z, w) {
      this._m_X = x || 0;
      this._m_Y = y || 0;
      this._m_Z = z || 0;
      this._m_W = w || 0;
    }
    /**
     * 获取该四元数表示的欧拉角,由于欧拉角的应用顺序,其结果不一定百分百正确。<br/>
     * @see <a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/index.htm">http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/index.htm</a><br/>
     * @param {Number[]}[angles]
     * @return {Number[]}[返回欧拉角,注意是弧度]
     */

  }, {
    key: "toAngles",
    value: function toAngles(angles) {
      angles = angles || new Array(3);
      var sqw = this._m_W * this._m_W;
      var sqx = this._m_X * this._m_X;
      var sqy = this._m_Y * this._m_Y;
      var sqz = this._m_Z * this._m_Z;
      var unit = sqx + sqy + sqz + sqw; // 归一化
      // 计算修正因子

      var test = this._m_X * this._m_Y + this._m_Z * this._m_W;

      if (test > 0.499 * unit) {
        // 朝北极值
        angles[1] = 2 * Math.atan2(this._m_X, this._m_W);
        angles[2] = _MoreMath.default.S_HALF_PI;
        angles[0] = 0;
      } else if (test < -0.499 * unit) {
        // 朝南极值
        angles[1] = -2 * Math.atan2(this._m_X, this._m_W);
        angles[2] = -_MoreMath.default.S_HALF_PI;
        angles[0] = 0;
      } else {
        angles[1] = Math.atan2(2 * this._m_Y * this._m_W - 2 * this._m_X * this._m_Z, sqx - sqy - sqz + sqw); // yaw

        angles[2] = Math.asin(2 * test / unit); // roll

        angles[0] = Math.atan2(2 * this._m_X * this._m_W - 2 * this._m_Y * this._m_Z, -sqx + sqy - sqz + sqw); // pitch
      }

      return angles;
    }
    /**
     * 使用欧拉角初始化四元数。<br/>
     * 注意:这里按yzx应用欧拉角，但为了方便传值，对x,y,z参数进行排序提供。<br/>
     * @param {Number}[x pitch方位角，弧度值]
     * @param {Number}[y yaw方位角，弧度值]
     * @param {Number}[z roll方位角，弧度值]
     */

  }, {
    key: "fromEuler",
    value: function fromEuler(x, y, z) {
      var angle = -1;
      angle = x * 0.5;
      var c1 = Math.cos(angle);
      var s1 = Math.sin(angle);
      angle = y * 0.5;
      var c2 = Math.cos(angle);
      var s2 = Math.sin(angle);
      angle = z * 0.5;
      var c3 = Math.cos(angle);
      var s3 = Math.sin(angle);
      var c2c3 = c2 * c3;
      var s2s3 = s2 * s3;
      var c2s3 = c2 * s3;
      var s2c3 = s2 * c3;
      this._m_X = c2c3 * s1 + s2s3 * c1;
      this._m_Y = s2c3 * c1 + c2s3 * s1;
      this._m_Z = c2s3 * c1 - s2c3 * s1;
      this._m_W = c2c3 * c1 - s2s3 * s1;
    }
    /**
     * 从Matrix44初始化四元数。<br/>
     * @param {Matrix44}[mat44]
     */

  }, {
    key: "fromMat44",
    value: function fromMat44(mat44) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
      // 假设mat44的3x3部分只有旋转(不包含缩放)
      var m11 = mat44.m[0];
      var m12 = mat44.m[4];
      var m13 = mat44.m[8];
      var m21 = mat44.m[1];
      var m22 = mat44.m[5];
      var m23 = mat44.m[9];
      var m31 = mat44.m[2];
      var m32 = mat44.m[6];
      var m33 = mat44.m[10];
      var s;
      var trace = m11 + m22 + m33;

      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1.0);
        this._m_W = 0.25 / s;
        this._m_X = (m32 - m23) * s;
        this._m_Y = (m13 - m31) * s;
        this._m_Z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        this._m_W = (m32 - m23) / s;
        this._m_X = 0.25 * s;
        this._m_Y = (m12 + m21) / s;
        this._m_Z = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        this._m_W = (m13 - m31) / s;
        this._m_X = (m12 + m21) / s;
        this._m_Y = 0.25 * s;
        this._m_Z = (m23 + m32) / s;
      } else {
        s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        this._m_W = (m21 - m12) / s;
        this._m_X = (m13 + m31) / s;
        this._m_Y = (m23 + m32) / s;
        this._m_Z = 0.25 * s;
      }
    }
    /**
     * 将一个四元数与Vector3相乘，将结果存放到result中。<br/>
     * @param {Vector3}[vec3]
     * @param {Vector3}[result 当result为null时,结果存放到vec3,对于result来说,可以与vec3相同,这是安全的]
     * @return {Vector3}
     */

  }, {
    key: "multVec3",
    value: function multVec3(vec3, result) {
      // 如果result不存在就直接修改vec3
      result = result || vec3;
      var vx = vec3._m_X,
          vy = vec3._m_Y,
          vz = vec3._m_Z;
      var x = this._m_X;
      var y = this._m_Y;
      var z = this._m_Z;
      var w = this._m_W;
      result._m_X = w * w * vx + 2 * y * w * vz - 2 * z * w * vy + x * x * vx + 2 * y * x * vy + 2 * z * x * vz - z * z * vx - y * y * vx;
      result._m_Y = 2 * x * y * vx + y * y * vy + 2 * z * y * vz + 2 * w * z * vx - z * z * vy + w * w * vy - 2 * x * w * vz - x * x * vy;
      result._m_Z = 2 * x * z * vx + 2 * y * z * vy + z * z * vz - 2 * w * y * vx - y * y * vz + 2 * w * x * vy - x * x * vz + w * w * vz;
      return result;
    }
    /**
     * 以球面插值方式插值到q2。<br/>
     * @param {Quaternion}[q2]
     * @param {Number}[t]
     * @param {Quaternion}[result]
     * @return {Quaternion}
     */

  }, {
    key: "slerp",
    value: function slerp(q2, t, result) {
      return Quaternion.slerp(this, q2, t, result);
    }
    /**
     * 以球面插值方式从q1到q2。<br/>
     * @param {Quaternion}[q1]
     * @param {Quaternion}[q2]
     * @param {Number}[t]
     * @param {Quaternion}[result]
     * @return {Quaternion}
     */

  }, {
    key: "normal",
    value:
    /**
     * 归一化向量。<br/>
     * @returns {Vector3}
     */
    function normal() {
      var l = this.length();

      if (l) {
        l = 1.0 / l;
        this._m_X *= l;
        this._m_Y *= l;
        this._m_Z *= l;
        this._m_W *= l;
      } else {
        console.error("Vector3.normal异常,长度为0。");
      }

      return this;
    }
  }, {
    key: "length",
    value: function length() {
      var d = this._m_X * this._m_X + this._m_Y * this._m_Y + this._m_Z * this._m_Z + this._m_W * this._m_W;
      d = Math.sqrt(d);
      return d;
    }
    /**
     * 以线性插值方式插值到q2。<br/>
     * @param {Quaternion}[q2]
     * @param {Number}[t 0-1]
     * @param {Quaternion}[result]
     * @return {Quaternion}
     */

  }, {
    key: "inter",
    value: function inter(q2, t, result) {
      return Quaternion.inter(this, q2, t, result);
    }
    /**
     * 以线性插值方式从q1到q2。<br/>
     * @param {Quaternion}[q1]
     * @param {Quaternion}[q2]
     * @param {Number}[t 0-1]
     * @param {Quaternion}[result]
     * @return {Quaternion}
     */

  }, {
    key: "toString",
    value: function toString() {
      return "[" + this._m_X + "," + this._m_Y + "," + this._m_Z + "," + this._m_W + "]";
    }
  }], [{
    key: "slerp",
    value: function slerp(q1, q2, t, result) {
      var dot = q1._m_W * q2._m_W + q1._m_X * q2._m_X + q1._m_Y * q2._m_Y + q1._m_Z * q2._m_Z;
      var q0 = null;

      if (dot < 0.0) {
        q0 = Quaternion._S_TEMP_QUATERNION;
        q0._m_W = -q1._m_W;
        q0._m_X = -q1._m_X;
        q0._m_Y = -q1._m_Y;
        q0._m_Z = -q1._m_Z;
        dot = -dot;
      } else {
        q0 = q1;
      }

      var k0, k1;

      if (dot > 0.9995) {
        k0 = 1.0 - t;
        k1 = t;
      } else {
        var a = Math.acos(dot);
        var sina = Math.sin(a);
        k0 = Math.sin((1.0 - t) * a) / sina;
        k1 = Math.sin(t * a) / sina;
      } //q0.mW * k0 + q2.mW *k1, q0.mX * k0 + q2.mX * k1, q0.mY * k0 + q2.mY * k1, q0.mZ * k0 + q2.mZ * k1


      result = result ? result : Quaternion._S_TEMP_QUATERNION_2;
      result._m_W = q0._m_W * k0 + q2._m_W * k1;
      result._m_X = q0._m_X * k0 + q2._m_X * k1;
      result._m_Y = q0._m_Y * k0 + q2._m_Y * k1;
      result._m_Z = q0._m_Z * k0 + q2._m_Z * k1;
      return result;
    }
  }, {
    key: "slerp2",
    value: function slerp2(q1, q2, t, result) {
      result = result ? result : Quaternion._S_TEMP_QUATERNION_2;

      if (t === 0) {
        result.setTo(q1);
        return result;
      }

      ;

      if (t === 1) {
        result.setTo(q2);
        return result;
      }

      ;
      var x = q1._m_X,
          y = q1._m_Y,
          z = q1._m_Z,
          w = q1._m_W; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * q2._m_W + x * q2._m_X + y * q2._m_Y + z * q2._m_Z;
      var q0 = null;

      if (cosHalfTheta < 0) {
        q0 = Quaternion._S_TEMP_QUATERNION;
        q0._m_W = -q2._m_W;
        q0._m_X = -q2._m_X;
        q0._m_Y = -q2._m_Y;
        q0._m_Z = -q2._m_Z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        q0 = q2;
      }

      if (cosHalfTheta >= 1.0) {
        result._m_W = w;
        result._m_X = x;
        result._m_Y = y;
        result._m_Z = z;
        return result;
      }

      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1.0 - t;
        result._m_W = s * w + t * q0._m_W;
        result._m_X = s * x + t * q0._m_X;
        result._m_Y = s * y + t * q0._m_Y;
        result._m_Z = s * z + t * q0._m_Z;
        result.normal();
        return result;
      }

      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      result._m_W = w * ratioA + q0._m_W * ratioB;
      result._m_X = x * ratioA + q0._m_X * ratioB;
      result._m_Y = y * ratioA + q0._m_Y * ratioB;
      result._m_Z = z * ratioA + q0._m_Z * ratioB;
      return result;
    }
  }, {
    key: "inter",
    value: function inter(q1, q2, t, result) {
      var s = 1.0 - t;
      result = result ? result : Quaternion._S_TEMP_QUATERNION;
      result._m_X = q1._m_X * s + q2._m_X * t;
      result._m_Y = q1._m_Y * s + q2._m_Y * t;
      result._m_Z = q1._m_Z * s + q2._m_Z * t;
      result._m_W = q1._m_W * s + q2._m_W * t;
      return result;
    }
  }]);

  return Quaternion;
}();

exports["default"] = Quaternion;

_defineProperty(Quaternion, "_S_TEMP_QUATERNION", new Quaternion());

_defineProperty(Quaternion, "_S_TEMP_QUATERNION_2", new Quaternion());

/***/ }),

/***/ 9271:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Vector2 = /*#__PURE__*/function () {
  function Vector2(x, y) {
    _classCallCheck(this, Vector2);

    this._m_X = x || 0;
    this._m_Y = y || 0;
  }

  _createClass(Vector2, [{
    key: "setTo",
    value: function setTo(vec2) {
      this._m_X = vec2._m_X;
      this._m_Y = vec2._m_Y;
    }
  }, {
    key: "setToInXY",
    value: function setToInXY(x, y) {
      this._m_X = x || 0;
      this._m_Y = y || 0;
    }
    /**
     * 返回两个向量的点乘。<br/>
     * @param {Vector2}[vec2]
     * @returns {number}
     */

  }, {
    key: "dot",
    value: function dot(vec2) {
      return this._m_X * vec2._m_X + this._m_Y * vec2._m_Y;
    }
    /**
     * 返回两个向量的叉乘。<br/>
     * @param {Vector2}[vec2]
     * @param {Vector2}[result]
     */

  }, {
    key: "cross",
    value: function cross(vec2, result) {
      if (result) {
        result._m_X = this._m_Y * vec2._m_Z - this._m_Z * vec2._m_Y;
        result._m_Y = this._m_Z * vec2._m_X - this._m_X * vec2._m_Z;
        return result;
      } else {
        var x = this._m_Y * vec2._m_Z - this._m_Z * vec2._m_Y;
        var y = this._m_Z * vec2._m_X - this._m_X * vec2._m_Z;
        this._m_X = x;
        this._m_Y = y;
        return this;
      }
    }
  }, {
    key: "crossRetNew",
    value: function crossRetNew(vec2) {
      var r = new Vector2(0, 0);
      return this.cross(vec2, r);
    }
  }, {
    key: "divide",
    value: function divide(vec2, result) {
      if (result) {
        result._m_X = this._m_X / vec2._m_X;
        result._m_Y = this._m_Y / vec2._m_Y;
        return result;
      } else {
        this._m_X /= vec2._m_X;
        this._m_Y /= vec2._m_Y;
        return this;
      }
    }
  }, {
    key: "divideRetNew",
    value: function divideRetNew(vec2) {
      var r = new Vector2(0, 0);
      return this.divide(vec2, r);
    }
  }, {
    key: "mult",
    value: function mult(vec2, result) {
      if (result) {
        result._m_X = this._m_X * vec2._m_X;
        result._m_Y = this._m_Y * vec2._m_Y;
        return result;
      } else {
        this._m_X *= vec2._m_X;
        this._m_Y *= vec2._m_Y;
        return this;
      }
    }
  }, {
    key: "multRetNew",
    value: function multRetNew(vec2) {
      var r = new Vector2(0, 0);
      return this.mult(vec2, r);
    }
  }, {
    key: "sub",
    value: function sub(vec2, result) {
      if (result) {
        result._m_X = this._m_X - vec2._m_X;
        result._m_Y = this._m_Y - vec2._m_Y;
        return result;
      } else {
        this._m_X -= vec2._m_X;
        this._m_Y -= vec2._m_Y;
        return this;
      }
    }
  }, {
    key: "subRetNew",
    value: function subRetNew(vec2) {
      var r = new Vector2(0, 0);
      return this.sub(vec2, r);
    }
  }, {
    key: "add",
    value: function add(vec2, reslut) {
      if (reslut) {
        reslut._m_X = this._m_X + vec2._m_X;
        reslut._m_Y = this._m_Y + vec2._m_Y;
        return reslut;
      } else {
        this._m_X += vec2._m_X;
        this._m_Y += vec2._m_Y;
        return this;
      }
    }
  }, {
    key: "addRetNew",
    value: function addRetNew(vec2) {
      var r = new Vector2(0, 0);
      return this.add(vec2, r);
    }
  }, {
    key: "multLength",
    value: function multLength(l, result) {
      if (result) {
        result._m_X = this._m_X * l;
        result._m_Y = this._m_Y * l;
        return result;
      } else {
        this._m_X *= l;
        this._m_Y *= l;
        return this;
      }
    }
    /**
     * 归一化向量。<br/>
     * @returns {Vector3}
     */

  }, {
    key: "normal",
    value: function normal() {
      var l = this.length();

      if (l) {
        l = 1.0 / l;
        this._m_X *= l;
        this._m_Y *= l;
      } else {
        console.error("Vector3.normal异常,长度为0。");
      }

      return this;
    }
  }, {
    key: "length",
    value: function length() {
      var d = this._m_X * this._m_X + this._m_Y * this._m_Y;
      d = Math.sqrt(d);
      return d;
    }
  }, {
    key: "toString",
    value: function toString() {
      return '[' + this._m_X + ',' + this._m_Y + ']';
    }
  }]);

  return Vector2;
}();

exports["default"] = Vector2;

/***/ }),

/***/ 5604:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * vec3
 * @author kkk
 * @date 2020年10月10日10点53分
 */
var Vector3 = /*#__PURE__*/function () {
  // 内部缓存
  // 单位向量
  function Vector3(x, y, z) {
    _classCallCheck(this, Vector3);

    this._m_X = x || 0;
    this._m_Y = y || 0;
    this._m_Z = z || 0;
    this.bufferData = new Float32Array(3);
  }

  _createClass(Vector3, [{
    key: "getBufferData",
    value: function getBufferData() {
      this.bufferData.set([this._m_X, this._m_Y, this._m_Z]);
      return this.bufferData;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this._m_X, this._m_Y, this._m_Z];
    }
  }, {
    key: "setTo",
    value: function setTo(vec3) {
      this._m_X = vec3._m_X;
      this._m_Y = vec3._m_Y;
      this._m_Z = vec3._m_Z;
      return this;
    }
  }, {
    key: "setToInXYZ",
    value: function setToInXYZ(x, y, z) {
      this._m_X = x || 0;
      this._m_Y = y || 0;
      this._m_Z = z || 0;
      return this;
    }
    /**
     * 返回两个向量的点乘。<br/>
     * @param {Vector3}[vec3]
     * @returns {number}
     */

  }, {
    key: "dot",
    value: function dot(vec3) {
      return this._m_X * vec3._m_X + this._m_Y * vec3._m_Y + this._m_Z * vec3._m_Z;
    }
    /**
     * 计算与指定Vector3之间的最小值。<br/>
     * @param {Vector3}[vec3]
     * @param {Vector3}[result]
     * @return {Vector3}
     */

  }, {
    key: "min",
    value: function min(vec3, result) {
      // 之所以不用Math.min是为了减少大量频繁js函数调用开销
      // 另外这里完全可以result = result || this;但是对于高性能算法来说,分支预测比||快,直接展开代码是效率最快的
      // 在整个项目里会看到很多展开的代码而不是封装成调用函数
      // 不要怀疑代码的封装性，所谓的封装只会影响性能（性能第一）
      if (result) {
        result._m_X = vec3._m_X < this._m_X ? vec3._m_X : this._m_X;
        result._m_Y = vec3._m_Y < this._m_Y ? vec3._m_Y : this._m_Y;
        result._m_Z = vec3._m_Z < this._m_Z ? vec3._m_Z : this._m_Z;
        return result;
      } else {
        this._m_X = vec3._m_X < this._m_X ? vec3._m_X : this._m_X;
        this._m_Y = vec3._m_Y < this._m_Y ? vec3._m_Y : this._m_Y;
        this._m_Z = vec3._m_Z < this._m_Z ? vec3._m_Z : this._m_Z;
        return this;
      }
    }
    /**
     * 计算与指定Vector3之间的最大值。<br/>
     * @param {Vector3}[vec3]
     * @param {Vector3}[result]
     * @return {Vector3}
     */

  }, {
    key: "max",
    value: function max(vec3, result) {
      // 之所以不用Math.max是为了减少大量频繁js函数调用开销
      // 另外这里完全可以result = result || this;但是对于高性能算法来说,分支预测比||快,直接展开代码是效率最快的
      // 在整个项目里会看到很多展开的代码而不是封装成调用函数
      // 不要怀疑代码的封装性，所谓的封装只会影响性能（性能第一）
      if (result) {
        result._m_X = vec3._m_X > this._m_X ? vec3._m_X : this._m_X;
        result._m_Y = vec3._m_Y > this._m_Y ? vec3._m_Y : this._m_Y;
        result._m_Z = vec3._m_Z > this._m_Z ? vec3._m_Z : this._m_Z;
        return result;
      } else {
        this._m_X = vec3._m_X > this._m_X ? vec3._m_X : this._m_X;
        this._m_Y = vec3._m_Y > this._m_Y ? vec3._m_Y : this._m_Y;
        this._m_Z = vec3._m_Z > this._m_Z ? vec3._m_Z : this._m_Z;
        return this;
      }
    }
    /**
     * 返回两个向量的叉乘。<br/>
     * @param {Vector3}[vec3]
     * @param {Vector3}[result]
     */

  }, {
    key: "cross",
    value: function cross(vec3, result) {
      if (result) {
        result._m_X = this._m_Y * vec3._m_Z - this._m_Z * vec3._m_Y;
        result._m_Y = this._m_Z * vec3._m_X - this._m_X * vec3._m_Z;
        result._m_Z = this._m_X * vec3._m_Y - this._m_Y * vec3._m_X;
        return result;
      } else {
        var x = this._m_Y * vec3._m_Z - this._m_Z * vec3._m_Y;
        var y = this._m_Z * vec3._m_X - this._m_X * vec3._m_Z;
        var z = this._m_X * vec3._m_Y - this._m_Y * vec3._m_X;
        this._m_X = x;
        this._m_Y = y;
        this._m_Z = z;
        return this;
      }
    }
  }, {
    key: "crossRetNew",
    value: function crossRetNew(vec3) {
      var r = new Vector3(0, 0, 0);
      return this.cross(vec3, r);
    }
  }, {
    key: "distance",
    value: function distance(v) {
      return Math.sqrt(this.distanceSq(v));
    }
  }, {
    key: "distanceSq",
    value: function distanceSq(v) {
      var dx = this._m_X - v._m_X;
      var dy = this._m_Y - v._m_Y;
      var dz = this._m_Z - v._m_Z;
      return dx * dx + dy * dy + dz * dz;
    }
  }, {
    key: "divide",
    value: function divide(vec3, result) {
      if (result) {
        result._m_X = this._m_X / vec3._m_X;
        result._m_Y = this._m_Y / vec3._m_Y;
        result._m_Z = this._m_Z / vec3._m_Z;
        return result;
      } else {
        this._m_X /= vec3._m_X;
        this._m_Y /= vec3._m_Y;
        this._m_Z /= vec3._m_Z;
        return this;
      }
    }
  }, {
    key: "divideInXYZ",
    value: function divideInXYZ(x, y, z, result) {
      if (result) {
        result._m_X = this._m_X / x;
        result._m_Y = this._m_Y / y;
        result._m_Z = this._m_Z / z;
        return result;
      } else {
        this._m_X /= x;
        this._m_Y /= y;
        this._m_Z /= z;
        return this;
      }
    }
  }, {
    key: "divideRetNew",
    value: function divideRetNew(vec3) {
      var r = new Vector3(0, 0, 0);
      return this.divide(vec3, r);
    }
  }, {
    key: "divideRetNewInXYZ",
    value: function divideRetNewInXYZ(x, y, z) {
      var r = new Vector3(0, 0, 0);
      return this.divideInXYZ(x, y, z, r);
    }
  }, {
    key: "mult",
    value: function mult(vec3, result) {
      if (result) {
        result._m_X = this._m_X * vec3._m_X;
        result._m_Y = this._m_Y * vec3._m_Y;
        result._m_Z = this._m_Z * vec3._m_Z;
        return result;
      } else {
        this._m_X *= vec3._m_X;
        this._m_Y *= vec3._m_Y;
        this._m_Z *= vec3._m_Z;
        return this;
      }
    }
  }, {
    key: "multInXYZ",
    value: function multInXYZ(x, y, z, result) {
      if (result) {
        result._m_X = this._m_X * x;
        result._m_Y = this._m_Y * y;
        result._m_Z = this._m_Z * z;
        return result;
      } else {
        this._m_X *= x;
        this._m_Y *= y;
        this._m_Z *= z;
        return this;
      }
    }
  }, {
    key: "multRetNew",
    value: function multRetNew(vec3) {
      var r = new Vector3(0, 0, 0);
      return this.mult(vec3, r);
    }
  }, {
    key: "multRetNewInXYZ",
    value: function multRetNewInXYZ(x, y, z) {
      var r = new Vector3(0, 0, 0);
      return this.multInXYZ(x, y, z, r);
    }
  }, {
    key: "sub",
    value: function sub(vec3, result) {
      if (result) {
        result._m_X = this._m_X - vec3._m_X;
        result._m_Y = this._m_Y - vec3._m_Y;
        result._m_Z = this._m_Z - vec3._m_Z;
        return result;
      } else {
        this._m_X -= vec3._m_X;
        this._m_Y -= vec3._m_Y;
        this._m_Z -= vec3._m_Z;
        return this;
      }
    }
  }, {
    key: "subInXYZ",
    value: function subInXYZ(x, y, z, result) {
      if (result) {
        result._m_X = this._m_X - x;
        result._m_Y = this._m_Y - y;
        result._m_Z = this._m_Z - z;
        return result;
      } else {
        this._m_X -= x;
        this._m_Y -= y;
        this._m_Z -= z;
        return this;
      }
    }
  }, {
    key: "subRetNew",
    value: function subRetNew(vec3) {
      var r = new Vector3(0, 0, 0);
      return this.sub(vec3, r);
    }
  }, {
    key: "subRetNewInXYZ",
    value: function subRetNewInXYZ(x, y, z) {
      var r = new Vector3(0, 0, 0);
      return this.subInXYZ(x, y, z, r);
    }
  }, {
    key: "add",
    value: function add(vec3, reslut) {
      if (reslut) {
        reslut._m_X = this._m_X + vec3._m_X;
        reslut._m_Y = this._m_Y + vec3._m_Y;
        reslut._m_Z = this._m_Z + vec3._m_Z;
        return reslut;
      } else {
        this._m_X += vec3._m_X;
        this._m_Y += vec3._m_Y;
        this._m_Z += vec3._m_Z;
        return this;
      }
    }
  }, {
    key: "addInXYZ",
    value: function addInXYZ(x, y, z, result) {
      if (result) {
        reslut._m_X = this._m_X + x;
        reslut._m_Y = this._m_Y + y;
        reslut._m_Z = this._m_Z + z;
        return reslut;
      } else {
        this._m_X += x;
        this._m_Y += y;
        this._m_Z += z;
        return this;
      }
    }
  }, {
    key: "addRetNew",
    value: function addRetNew(vec3) {
      var r = new Vector3(0, 0, 0);
      return this.add(vec3, r);
    }
  }, {
    key: "addRetNewInXYZ",
    value: function addRetNewInXYZ(x, y, z) {
      var r = new Vector3(0, 0, 0);
      return this.addInXYZ(x, y, z, r);
    }
  }, {
    key: "multLength",
    value: function multLength(l, result) {
      if (result) {
        result._m_X = this._m_X * l;
        result._m_Y = this._m_Y * l;
        result._m_Z = this._m_Z * l;
        return result;
      } else {
        this._m_X *= l;
        this._m_Y *= l;
        this._m_Z *= l;
        return this;
      }
    }
    /**
     * 归一化向量。<br/>
     * @returns {Vector3}
     */

  }, {
    key: "normal",
    value: function normal() {
      var l = this.length();

      if (l) {
        l = 1.0 / l;
        this._m_X *= l;
        this._m_Y *= l;
        this._m_Z *= l;
      } else {
        this._m_X = this._m_Y = this._m_Z = 0;
      }

      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      return new Vector3(-this._m_X, -this._m_Y, -this._m_Z);
    }
  }, {
    key: "length",
    value: function length() {
      var d = this._m_X * this._m_X + this._m_Y * this._m_Y + this._m_Z * this._m_Z;
      d = Math.sqrt(d);
      return d;
    }
  }, {
    key: "toString",
    value: function toString() {
      return '[' + this._m_X + ',' + this._m_Y + ',' + this._m_Z + ']';
    }
    /**
     * 以线性插值方式插值到v2。<br/>
     * @param {Vector3}[v2]
     * @param {Number}[t 0-1]
     * @param {Vector3}[result]
     * @return {Vector3}
     */

  }, {
    key: "inter",
    value: function inter(v2, t, result) {
      return Vector3.inter(this, v2, t, result);
    }
    /**
     * 判断是否与指定的v相等。<br/>
     * @param {Vector3}[v]
     * @return {Boolean}
     */

  }, {
    key: "equals",
    value: function equals(v) {
      if (v == this) {
        return true;
      } else if (v == null) return false;else return this._m_X == v._m_X && this._m_Y == v._m_Y && this._m_Z == v._m_Z;
    }
    /**
     * 以线性插值方式从v1到v2。<br/>
     * @param {Vector3}[v1]
     * @param {Vector3}[v2]
     * @param {Number}[t 0-1]
     * @param {Vector3}[result]
     * @return {Vector3}
     */

  }], [{
    key: "inter",
    value: function inter(v1, v2, t, result) {
      var s = 1.0 - t;
      result = result ? result : Vector3._S_TEMP_VEC3;
      result._m_X = v1._m_X * s + v2._m_X * t;
      result._m_Y = v1._m_Y * s + v2._m_Y * t;
      result._m_Z = v1._m_Z * s + v2._m_Z * t;
      return result;
    }
  }]);

  return Vector3;
}();

exports["default"] = Vector3;

_defineProperty(Vector3, "_S_TEMP_VEC3", new Vector3());

_defineProperty(Vector3, "S_UNIT_AXIS_X", new Vector3(1, 0, 0));

_defineProperty(Vector3, "S_UNIT_AXIS_Y", new Vector3(0, 1, 0));

_defineProperty(Vector3, "S_UNIT_AXIS_Z", new Vector3(0, 0, 1));

_defineProperty(Vector3, "S_UNIT_AXIS_NEGATIVE_X", new Vector3(-1, 0, 0));

_defineProperty(Vector3, "S_UNIT_AXIS_NEGATIVE_Y", new Vector3(0, -1, 0));

_defineProperty(Vector3, "S_UNIT_AXIS_NEGATIVE_Z", new Vector3(0, 0, -1));

_defineProperty(Vector3, "S_POSITIVE_INFINITY", new Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));

_defineProperty(Vector3, "S_NEGATIVE_INFINITY", new Vector3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY));

_defineProperty(Vector3, "S_MAX", new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE));

_defineProperty(Vector3, "S_MIN", new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE));

/***/ }),

/***/ 7141:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Vector4 = /*#__PURE__*/function () {
  // 内部缓存
  function Vector4(x, y, z, w) {
    _classCallCheck(this, Vector4);

    this._m_X = x || 0;
    this._m_Y = y || 0;
    this._m_Z = z || 0;
    this._m_W = w != null && w != undefined ? w : 1;
    this.bufferData = new Float32Array(4);
  }

  _createClass(Vector4, [{
    key: "getBufferData",
    value: function getBufferData() {
      this.bufferData.set([this._m_X, this._m_Y, this._m_Z, this._m_W]);
      return this.bufferData;
    }
  }, {
    key: "setTo",
    value: function setTo(vec4) {
      this._m_X = vec4._m_X;
      this._m_Y = vec4._m_Y;
      this._m_Z = vec4._m_Z;
      this._m_W = vec4._m_W;
      return this;
    }
  }, {
    key: "setToInXYZW",
    value: function setToInXYZW(x, y, z, w) {
      this._m_X = x || 0;
      this._m_Y = y || 0;
      this._m_Z = z || 0;
      this._m_W = w != null && w != undefined ? w : 1;
      return this;
    }
    /**
     * 返回两个向量的点乘。<br/>
     * @param {Vector4}[vec4]
     * @returns {number}
     */

  }, {
    key: "dot",
    value: function dot(vec4) {
      return this._m_X * vec4._m_X + this._m_Y * vec4._m_Y + this._m_Z * vec4._m_Z + this._m_W * vec4._m_W;
    }
    /**
     * 返回两个向量的叉乘。<br/>
     * @param {Vector4}[vec4]
     * @param {Vector4}[result]
     */

  }, {
    key: "cross",
    value: function cross(vec4, result) {
      if (result) {
        result._m_X = this._m_Y * vec4._m_Z - this._m_Z * vec4._m_Y;
        result._m_Y = this._m_Z * vec4._m_X - this._m_X * vec4._m_Z;
        result._m_Z = this._m_X * vec4._m_Y - this._m_Y * vec4._m_X;
        return result;
      } else {
        var x = this._m_Y * vec4._m_Z - this._m_Z * vec4._m_Y;
        var y = this._m_Z * vec4._m_X - this._m_X * vec4._m_Z;
        var z = this._m_X * vec4._m_Y - this._m_Y * vec4._m_X;
        this._m_X = x;
        this._m_Y = y;
        this._m_Z = z;
        return this;
      }
    }
  }, {
    key: "crossRetNew",
    value: function crossRetNew(vec4) {
      var r = new Vector4(0, 0, 0, 1);
      return this.cross(vec4, r);
    }
  }, {
    key: "divide",
    value: function divide(vec4, result) {
      if (result) {
        result._m_X = this._m_X / vec4._m_X;
        result._m_Y = this._m_Y / vec4._m_Y;
        result._m_Z = this._m_Z / vec4._m_Z;
        result._m_W = this._m_W / vec4._m_W;
        return result;
      } else {
        this._m_X /= vec4._m_X;
        this._m_Y /= vec4._m_Y;
        this._m_Z /= vec4._m_Z;
        this._m_W /= vec4._m_W;
        return this;
      }
    }
  }, {
    key: "divideRetNew",
    value: function divideRetNew(vec4) {
      var r = new Vector4(0, 0, 0, 1);
      return this.divide(vec4, r);
    }
  }, {
    key: "mult",
    value: function mult(vec4, result) {
      if (result) {
        result._m_X = this._m_X * vec4._m_X;
        result._m_Y = this._m_Y * vec4._m_Y;
        result._m_Z = this._m_Z * vec4._m_Z;
        result._m_W = this._m_W * vec4._m_W;
        return result;
      } else {
        this._m_X *= vec4._m_X;
        this._m_Y *= vec4._m_Y;
        this._m_Z *= vec4._m_Z;
        this._m_W *= vec4._m_W;
        return this;
      }
    }
  }, {
    key: "multRetNew",
    value: function multRetNew(vec4) {
      var r = new Vector4(0, 0, 0, 1);
      return this.mult(vec4, r);
    }
  }, {
    key: "sub",
    value: function sub(vec4, result) {
      if (result) {
        result._m_X = this._m_X - vec4._m_X;
        result._m_Y = this._m_Y - vec4._m_Y;
        result._m_Z = this._m_Z - vec4._m_Z;
        return result;
      } else {
        this._m_X -= vec4._m_X;
        this._m_Y -= vec4._m_Y;
        this._m_Z -= vec4._m_Z;
        return this;
      }
    }
  }, {
    key: "subRetNew",
    value: function subRetNew(vec4) {
      var r = new Vector4(0, 0, 0, 1);
      return this.sub(vec4, r);
    }
  }, {
    key: "add",
    value: function add(vec4, reslut) {
      if (reslut) {
        reslut._m_X = this._m_X + vec4._m_X;
        reslut._m_Y = this._m_Y + vec4._m_Y;
        reslut._m_Z = this._m_Z + vec4._m_Z;
        return reslut;
      } else {
        this._m_X += vec4._m_X;
        this._m_Y += vec4._m_Y;
        this._m_Z += vec4._m_Z;
        return this;
      }
    }
  }, {
    key: "addRetNew",
    value: function addRetNew(vec4) {
      var r = new Vector4(0, 0, 0, 1);
      return this.add(vec4, r);
    }
  }, {
    key: "multLength",
    value: function multLength(l, result) {
      if (result) {
        result._m_X = this._m_X * l;
        result._m_Y = this._m_Y * l;
        result._m_Z = this._m_Z * l;
        return result;
      } else {
        this._m_X *= l;
        this._m_Y *= l;
        this._m_Z *= l;
        return this;
      }
    }
    /**
     * 归一化向量。<br/>
     * @returns {Vector3}
     */

  }, {
    key: "normal",
    value: function normal() {
      var l = this.length();

      if (l) {
        l = 1.0 / l;
        this._m_X *= l;
        this._m_Y *= l;
        this._m_Z *= l;
      } else {
        console.error("Vector3.normal异常,长度为0。");
      }

      return this;
    }
  }, {
    key: "distanceSq",
    value: function distanceSq(v) {
      var dx = this._m_X - v._m_X;
      var dy = this._m_Y - v._m_Y;
      var dz = this._m_Z - v._m_Z;
      return dx * dx + dy * dy + dz * dz;
    }
  }, {
    key: "distance",
    value: function distance(v) {
      return Math.sqrt(this.distanceSq(v));
    }
  }, {
    key: "length",
    value: function length() {
      var d = this._m_X * this._m_X + this._m_Y * this._m_Y + this._m_Z * this._m_Z;
      d = Math.sqrt(d);
      return d;
    }
  }, {
    key: "toString",
    value: function toString() {
      return '[' + this._m_X + ',' + this._m_Y + ',' + this._m_Z + ',' + this._m_W + ']';
    }
    /**
     * 以线性插值方式插值到v2。<br/>
     * @param {Vector4}[v2]
     * @param {Number}[t 0-1]
     * @param {Vector4}[result]
     * @return {Vector4}
     */

  }, {
    key: "inter",
    value: function inter(v2, t, result) {
      return Vector4.inter(this, v2, t, result);
    }
    /**
     * 以线性插值方式从v1到v2。<br/>
     * @param {Vector4}[v1]
     * @param {Vector4}[v2]
     * @param {Number}[t 0-1]
     * @param {Vector4}[result]
     * @return {Vector4}
     */

  }], [{
    key: "inter",
    value: function inter(v1, v2, t, result) {
      var s = 1.0 - t;
      result = result ? result : Vector4._S_TEMP_VEC4;
      result._m_X = v1._m_X * s + v2._m_X * t;
      result._m_Y = v1._m_Y * s + v2._m_Y * t;
      result._m_Z = v1._m_Z * s + v2._m_Z * t;
      result._m_W = 1.0;
      return result;
    }
  }]);

  return Vector4;
}();

exports["default"] = Vector4;

_defineProperty(Vector4, "_S_TEMP_VEC4", new Vector4());

/***/ }),

/***/ 5776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Picture2 = _interopRequireDefault(__webpack_require__(7280));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * FramePicture。<br/>
 * 提供后置渲染的帧数据捕捉。<br/>
 * @author Kkk
 * @date 2021年2月28日12点17分
 */
var FramePicture = /*#__PURE__*/function (_Picture) {
  _inherits(FramePicture, _Picture);

  var _super = _createSuper(FramePicture);

  function FramePicture(owner, cfg) {
    _classCallCheck(this, FramePicture);

    return _super.call(this, owner, cfg);
  }

  _createClass(FramePicture, [{
    key: "getType",
    value: function getType() {
      return 'FramePicture';
    }
  }, {
    key: "isFramePicture",
    value: function isFramePicture() {
      return true;
    }
  }]);

  return FramePicture;
}(_Picture2.default);

exports["default"] = FramePicture;

/***/ }),

/***/ 4720:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Node2 = _interopRequireDefault(__webpack_require__(2949));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Geometry继承Node,同时实现IDrawable接口,表示一个空间节点,同时表示一个可渲染的实例对象。<br/>
 * 是渲染引擎对外提供的渲染实例对象,包装内部渲染数据。<br/>
 * @author Kkk
 */
var Geometry = /*#__PURE__*/function (_Node) {
  _inherits(Geometry, _Node);

  var _super = _createSuper(Geometry);

  function Geometry(owner, cfg) {
    var _this;

    _classCallCheck(this, Geometry);

    _this = _super.call(this, owner, cfg);
    _this._m_Mesh = null;
    _this._m_ModelAABBBoundingBox = null;
    _this._m_Material = null;
    _this._m_IsDrawable = true;
    _this._m_Opaque = true;
    return _this;
  }
  /**
   * 设置该Geometry的细节层次。<br/>
   * @param {Number}[lod]
   */


  _createClass(Geometry, [{
    key: "getType",
    value: function getType() {
      return 'Geometry';
    }
  }, {
    key: "lod",
    value: function lod(_lod) {
      if (this._m_CurrentLod == _lod) return;
      this._m_CurrentLod = _lod;

      if (this._m_Mesh != null) {
        this._m_Mesh.lod(this._m_CurrentLod);
      }
    }
    /**
     * 设置当前Geometry使用的材质。<br/>
     * @param {Material}[material]
     */

  }, {
    key: "setMaterial",
    value: function setMaterial(material) {
      this._m_Material = material;

      if (this._m_Mesh) {
        this._refreshBufLocal();
      }
    }
    /**
     * 返回当前Geometry使用的材质。<br/>
     * @return {Material}
     */

  }, {
    key: "getMaterial",
    value: function getMaterial() {
      return this._m_Material;
    }
    /**
     * 设置Geometry的Mesh。<br/>
     * @param {Mesh}[mesh]
     */

  }, {
    key: "setMesh",
    value: function setMesh(mesh) {
      this._m_Mesh = mesh;

      if (this._m_Material) {
        this._refreshBufLocal();
      }
    }
    /**
     * 返回Geometry的Mesh。<br/>
     * @return {Mesh}
     */

  }, {
    key: "getMesh",
    value: function getMesh() {
      return this._m_Mesh;
    }
    /**
     * 更新Geometry数据，应该在创建完Geometry，设置了Mesh后调用一次，以便边界盒和其他信息准备完成。<br/>
     * 目前用于外部调用，有可能改为引擎内部调用。<br/>
     */

  }, {
    key: "updateBound",
    value: function updateBound() {
      if (this._m_Mesh) {
        this._m_Mesh._updateBound(this._m_Scene.getCanvas().getGLContext()); // 在至少包含Mesh之后再创建AABBBoudingBox,因为可能Geometry还没有设置Mesh


        if (!this._m_ModelAABBBoundingBox) {
          this._m_ModelAABBBoundingBox = new _AABBBoundingBox.default(); // 这里假设每个Geometry只设置一次Mesh(后面应该改善这里的逻辑,每次修改Mesh后都应该重新调用fromPositions重建AABB)

          this._m_ModelAABBBoundingBox.fromPositions(this._m_Mesh.getData(_Mesh.default.S_POSITIONS));

          if (!this._m_BoudingVolume) {
            this._m_BoudingVolume = new _AABBBoundingBox.default();
          }

          this._m_BoudingVolume.setTo(this._m_ModelAABBBoundingBox);
        }

        this._m_Mesh.lod(this._m_CurrentLod);
      }
    }
  }, {
    key: "getBoundingVolume",
    value: function getBoundingVolume() {
      // Geometry不应该包含子节点(因为Geometry应该只是叶子节点)
      // 所以Geometry应该直接返回最新状态的AABBBoundingBox
      // 当Mesh数据没有发生变更时,AABB只与变换更新有关
      // 当Mesh数据发生变更时,将在fromPositions重建AABB
      if (this._m_UpdateBoundingVolume) {
        // 更新AABBBoundingBox
        _Matrix.default.decomposeMat4(this.getWorldMatrix(), _Node2.default.S_TEMP_VEC3, _Node2.default.S_TEMP_Q, _Node2.default.S_TEMP_VEC3_2); // Log.log('Node.S_TEMP_VEC3_2:' + Node.S_TEMP_VEC3_2.toString());


        this._m_ModelAABBBoundingBox.transform(_Node2.default.S_TEMP_VEC3_2, _Node2.default.S_TEMP_Q, _Node2.default.S_TEMP_VEC3, this._m_BoudingVolume);

        this._m_UpdateBoundingVolume = false;
      }

      return this._m_BoudingVolume;
    }
    /**
     * 在设置材质后,更新自定义几何属性的位置属性
     * @private
     */

  }, {
    key: "_refreshBufLocal",
    value: function _refreshBufLocal() {
      // 获取材质的自定义几何属性
      var customAttrs = null;

      if (customAttrs) {
        this._m_Mesh._refreshBufLocal(this._m_Scene.getCanvas().getGLContext(), customAttrs);
      }
    }
    /**
     * 表示当前是否为可渲染实例
     */

  }, {
    key: "isDrawable",
    value: function isDrawable() {
      return this._m_IsDrawable;
    }
    /**
     * 设置当前是否为可渲染实例。<br/>
     * @param isDrawable
     */

  }, {
    key: "setIsDrawable",
    value: function setIsDrawable(isDrawable) {
      this._m_IsDrawable = isDrawable;
    }
    /**
     * 表示当前是否为FramePicture。<br/>
     * @return {boolean}
     */

  }, {
    key: "isFramePicture",
    value: function isFramePicture() {
      return false;
    }
    /**
     * 设置为不透明物体。<br/>
     */

  }, {
    key: "setOpaque",
    value: function setOpaque() {
      this._m_Opaque = true;
    }
    /**
     * 是否为非透明
     */

  }, {
    key: "isOpaque",
    value: function isOpaque() {
      return this._m_Opaque;
    }
    /**
     * 设置为半透明物体。<br/>
     */

  }, {
    key: "setTranslucent",
    value: function setTranslucent() {
      this._m_Opaque = false;
    }
    /**
     * 是否为半透明。<br/>
     */

  }, {
    key: "isTranslucent",
    value: function isTranslucent() {
      return !this._m_Opaque;
    }
    /**
     * 是否为Sky。<br/>
     */

  }, {
    key: "isSky",
    value: function isSky() {}
    /**
     * 属于GUI元素。<br/>
     */

  }, {
    key: "isGUI",
    value: function isGUI() {}
  }, {
    key: "draw",
    value: function draw(frameContext) {
      var gl = this._m_Scene.getCanvas().getGLContext(); // 提交模型矩阵到材质中


      var contextVars = frameContext.m_LastSubShader.getContextVars();
      var viewMatrix = null,
          projectMatrix = null;

      for (var vN in contextVars) {
        switch (vN) {
          case _ShaderSource.default.S_MODEL_MATRIX_SRC:
            // contextVars[vN].fun(contextVars[vN].loc, false, this.getWorldMatrix().getBufferData());
            gl[contextVars[vN].fun](contextVars[vN].loc, false, this.getWorldMatrix().getBufferData());
            break;

          case _ShaderSource.default.S_MV_SRC:
            viewMatrix = frameContext.getCalcContext(_ShaderSource.default.S_VIEW_MATRIX_SRC);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4, 0, viewMatrix, 0, this.getWorldMatrix(), 0);

            contextVars[vN].fun(contextVars[vN].loc, false, _TempVars.default.S_TEMP_MAT4.getBufferData());
            break;

          case _ShaderSource.default.S_MVP_SRC:
            viewMatrix = frameContext.getCalcContext(_ShaderSource.default.S_VIEW_MATRIX_SRC);
            projectMatrix = frameContext.getCalcContext(_ShaderSource.default.S_PROJECT_MATRIX_SRC);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4, 0, viewMatrix, 0, this.getWorldMatrix(), 0);

            _Matrix.default.multiplyMM(_TempVars.default.S_TEMP_MAT4_1, 0, projectMatrix, 0, viewMatrix, 0);

            gl[contextVars[vN].fun](contextVars[vN].loc, false, _TempVars.default.S_TEMP_MAT4_1.getBufferData());
            break;
        }
      } // 通过getW


      this._m_Mesh.draw(gl);
    }
    /**
     * 继承IDrawable接口函数,实现绘制逻辑。<br/>
    //  * @param {FrameContext}[frameContext]
    //  */
    // draw(frameContext){
    //     let gl = this._m_Scene.getCanvas().getGLContext();
    //
    //     // 提交该Geometry的modelMatrix到当前上下文中
    //     // // mI应该提前记录下来(记录到SubShader的local列表中,SubShader的local列表不用记录ubo blocks,因为ubo blocks不需要)
    //     // let mI = gl.getUniformLocation(frameContext.m_SubShader.getProgram(), "modelMatrix");
    //     // // 检测如果更新了变换矩阵才需要更新数据块
    //     // gl.uniformMatrix4fv(mI, false, new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
    //     // 根据材质
    //     if(frameContext.m_LastMaterila != this._m_Material){
    //         frameContext.m_LastMaterila = this._m_Material;
    //         // 查看材质参数,将视图,投影矩阵等矩阵提交到材质中
    //         this._m_Material.use();
    //     }
    //     // 通过getW
    //     this._m_Mesh.draw(gl);
    // }

  }]);

  return Geometry;
}(_Node2.default);

exports["default"] = Geometry;

/***/ }),

/***/ 2949:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Quaternion = _interopRequireDefault(__webpack_require__(453));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 节点组件表示场景的一个关节，用于对场景进行场景图管理。<br/>
 * @author Kkk
 */
var Node = /*#__PURE__*/function (_Component) {
  _inherits(Node, _Component);

  var _super = _createSuper(Node);

  function Node(owner, cfg) {
    var _this;

    _classCallCheck(this, Node);

    // 在不同叶子中,可能存在同名NodeName
    // 为了区别componentId和NodeName,并使得componentId唯一,这里使用生成算法生成componentId
    // 后续改为NodeName和componentId分开设置
    _this = _super.call(this, owner, {
      id: _Tools.default.nextId() + cfg.id
    });
    _this._m_Name = cfg.id;
    _this._m_CurrentLod = 0; // 变换信息

    _this._m_LocalMatrix = new _Matrix.default();
    _this._m_WorldMatrix = new _Matrix.default();
    _this._m_Parent = null;
    _this._m_Children = [];
    _this._m_ChildrenIDs = {}; // 缩放

    _this._m_LocalScale = new _Vector.default(1, 1, 1); // 旋转

    _this._m_LocalRotation = new _Quaternion.default(0, 0, 0, 1); // 平移

    _this._m_LocalTranslation = new _Vector.default(); // 两种可能,本地矩阵发生变化时,需要更新本地矩阵,然后更新世界矩阵
    // 本地矩阵没有发生变化时,只需要更新世界矩阵

    _this._m_UpdateLocalMatrix = false;
    _this._m_UpdateWorldMatrix = false; // 包围盒(Node的包围盒由所有子节点合并得到)

    _this._m_BoudingVolume = null; // 设置为true,确保第一次调用getBoundingVolume()时可以获得有效BoundingVolume

    _this._m_UpdateBoundingVolume = true; // 与视锥体的状态

    _this._m_FrustumContain = _Camera.default.S_FRUSTUM_INTERSECT_INTERSECTS; // 剔除模式(动态,总不,总是)

    _this._m_CullMode = null; // 剔除标记

    _this._m_CullingFlags = 1;
    _this._m_CullingFlags |= Node.S_DEFAULT_FRUSTUM_CULLING; // 过滤标记

    _this._m_FilterFlag = Node.S_DYNAMIC; // 阴影模式

    _this._m_ShadowMode = 1;
    _this._m_ShadowMode |= Node.S_SHADOW_CAST_AND_RECEIVE;
    return _this;
  }
  /**
   * 设置是否计算阴影。<br/>
   * @param {Boolean}[cast]
   */


  _createClass(Node, [{
    key: "getType",
    value: // 默认视锥剔除
    // 动态剔除
    // 总是剔除
    // 永不
    // 接受阴影
    // 计算阴影
    // 计算并接受阴影
    // 关闭阴影
    function getType() {
      return 'Node';
    }
  }, {
    key: "castShadow",
    value: function castShadow(cast) {
      if (cast && ((this._m_ShadowMode & Node.S_SHADOW_CAST) == 0 || (this._m_ShadowMode & Node.S_SHADOW_CAST_AND_RECEIVE) == 0)) {
        this._m_ShadowMode |= Node.S_SHADOW_CAST;
      } else {
        if ((this._m_ShadowMode & Node.S_SHADOW_CAST) != 0) {
          this._m_ShadowMode ^= Node.S_SHADOW_CAST;
        }

        if ((this._m_ShadowMode & Node.S_SHADOW_CAST_AND_RECEIVE) != 0) {
          this._m_ShadowMode ^= Node.S_SHADOW_CAST_AND_RECEIVE;
          console.log('_m_ShadowMode:' + this._m_ShadowMode);

          if (this._m_ShadowMode & Node.S_SHADOW_RECEIVE == 0) {
            this._m_ShadowMode |= Node.S_SHADOW_RECEIVE;
          }
        }
      }

      this._m_Children.forEach(function (c) {
        c.castShadow(cast);
      });
    }
    /**
     * 返回是否计算阴影。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isCastShadow",
    value: function isCastShadow() {
      return (this._m_ShadowMode & Node.S_SHADOW_CAST) != 0 || (this._m_ShadowMode & Node.S_SHADOW_CAST_AND_RECEIVE) != 0;
    }
    /**
     * 设置是否接受阴影。<br/>
     * @param {Boolean}[receive]
     */

  }, {
    key: "receiveShadow",
    value: function receiveShadow(receive) {
      if (receive && ((this._m_ShadowMode & Node.S_SHADOW_RECEIVE) == 0 || (this._m_FilterFlag & Node.S_SHADOW_CAST_AND_RECEIVE) == 0)) {
        this._m_ShadowMode |= Node.S_SHADOW_RECEIVE;
      } else {
        if ((this._m_ShadowMode & Node.S_SHADOW_RECEIVE) != 0) {
          this._m_ShadowMode ^= Node.S_SHADOW_RECEIVE;
        }

        if ((this._m_ShadowMode & Node.S_SHADOW_CAST_AND_RECEIVE) != 0) {
          this._m_ShadowMode ^= Node.S_SHADOW_CAST_AND_RECEIVE;

          if (this._m_ShadowMode & Node.S_SHADOW_CAST == 0) {
            this._m_ShadowMode |= Node.S_SHADOW_CAST;
          }
        }
      }

      this._m_Children.forEach(function (c) {
        c.receiveShadow(receive);
      });
    }
    /**
     * 返回是否接受阴影。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isReceiveShadow",
    value: function isReceiveShadow() {
      return (this._m_ShadowMode & Node.S_SHADOW_RECEIVE) != 0 || (this._m_ShadowMode & Node.S_SHADOW_CAST_AND_RECEIVE) != 0;
    }
    /**
     * 表示当前是否为可渲染实例
     */

  }, {
    key: "isDrawable",
    value: function isDrawable() {
      return false;
    }
    /**
     * 设置当前分支下所有渲染实例的细节层次。<br/>
     * @param {Number}[lod]
     */

  }, {
    key: "lod",
    value: function lod(_lod) {
      if (this._m_CurrentLod == _lod) return; // 提前判断可以减少forEach空列表带来的开销

      if (this._m_Children.getChildren().length > 0) {
        this._m_Children.forEach(function (c) {
          c.lod(_lod);
        });
      }
    }
    /**
     * 设置过滤标记。<br/>
     * @param {Number}[filterFlag]
     */

  }, {
    key: "setFilterFlag",
    value: function setFilterFlag(filterFlag) {
      this._m_FilterFlag = filterFlag;
    }
    /**
     * 返回过滤标记，为Node.S_DYNAMIC,Node.S_ALWAYS和Node.S_NEVER之一。<br/>
     * @return {Number}
     */

  }, {
    key: "getFilterFlag",
    value: function getFilterFlag() {
      return this._m_FilterFlag;
    }
    /**
     * 返回剔除标记。<br/>
     * @return {Number}
     */

  }, {
    key: "getCullingFlags",
    value: function getCullingFlags() {
      return this._m_CullingFlags;
    }
    /**
     * 清楚指定剔除标记。<br/>
     * @param {Number}[flags 指定的剔除标记位]
     */

  }, {
    key: "clearCullingFlags",
    value: function clearCullingFlags(flags) {
      this._m_CullingFlags ^= flags;
    }
    /**
     * 添加指定剔除标记位。<br/>
     * @param {Number}[flags]
     */

  }, {
    key: "addCullingFlags",
    value: function addCullingFlags(flags) {
      this._m_CullingFlags |= flags;
    }
    /**
     * 检测是否处于视锥体中。<br/>
     * @param camera
     * @return {boolean}
     */

  }, {
    key: "inFrustum",
    value: function inFrustum(camera) {
      // 跳过不需要剔除的节点
      // 检测父节点是否被剔除(因为可能由外部调用该方法而非引擎调用)
      this._m_FrustumContain = this._m_Parent == null ? _Camera.default.S_FRUSTUM_INTERSECT_INTERSECTS : this._m_Parent._m_FrustumContain;

      if (this._m_FrustumContain == _Camera.default.S_FRUSTUM_INTERSECT_INTERSECTS) {
        // 跳过一些特殊对象
        // 执行视锥剔除
        this._m_FrustumContain = camera.frustumContains(this.getBoundingVolume());
      }

      return this._m_FrustumContain != _Camera.default.S_FRUSTUM_INTERSECT_OUTSIDE;
    }
    /**
     * 返回BoundingVolume。<br/>
     * 如果当前是Node节点，并且没有子节点或者子节点没有包围体，则返回null。<br/>
     * @return {BoundingVolume}
     */

  }, {
    key: "getBoundingVolume",
    value: function getBoundingVolume() {
      var _this2 = this;

      if (this._m_UpdateBoundingVolume) {
        // 更新包围盒
        // 如果存在子节点,则合并子节点
        if (this._m_Children.length > 0) {
          var aabb = null; // 清空包围体(避免保留上次结果)

          this._m_Children.forEach(function (children) {
            aabb = children.getBoundingVolume();

            if (aabb) {
              // 说明存在子节点包围盒
              if (!_this2._m_BoudingVolume) {
                // 说明是初次获取,则创建该Node的包围盒
                _this2._m_BoudingVolume = new _AABBBoundingBox.default();
              } // 合并子节点包围体


              _this2._m_BoudingVolume.merge(aabb);
            }
          });
        }

        this._m_UpdateBoundingVolume = false;
      }

      return this._m_BoudingVolume;
    }
    /**
     * 返回子节点列表。<br/>
     * @return {Node[]}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._m_Children;
    }
    /**
     * 返回指定名称的节点，将搜索整科树。<br/>
     * @param {String}[name]
     * @return {Node}
     */

  }, {
    key: "getChildrenAtName",
    value: function getChildrenAtName(name) {
      var c = this._m_ChildrenIDs[name];

      if (c) {
        return c;
      } else {
        // 遍历子节点
        var count = this._m_Children.length;

        for (var i = 0; i < count; i++) {
          c = this._m_Children[i].getChildrenAtName(name);

          if (c) {
            return c;
          }
        }
      }

      return null;
    }
    /**
     * 返回指定索引的子节点。<br/>
     * @param {Number}[i]
     * @return {Node}
     */

  }, {
    key: "getChildrenAtIndex",
    value: function getChildrenAtIndex(i) {
      if (i >= this._m_Children.length) {
        return null;
      }

      return this._m_Children[i];
    }
    /**
     * 返回父节点。<br/>
     * @return {Node/Null}
     */

  }, {
    key: "getParent",
    value: function getParent() {
      return this._m_Parent;
    }
    /**
     * 设置局部缩放。<br/>
     * @param {Vector3}[scale]
     */

  }, {
    key: "setLocalScale",
    value: function setLocalScale(scale) {
      this._m_LocalScale.setTo(scale);

      this._updateLocalMatrix();
    }
    /**
     * 设置缩放。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setLocalScaleXYZ",
    value: function setLocalScaleXYZ(x, y, z) {
      this._m_LocalScale.setToInXYZ(x, y, z);

      this._updateLocalMatrix();
    }
    /**
     * 返回缩放。<br/>
     * @returns {Vector3}
     */

  }, {
    key: "getLocalScale",
    value: function getLocalScale() {
      return this._m_LocalScale;
    }
    /**
     * 设置旋转。<br/>
     * @param {Quaternion}[rotation]
     */

  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(rotation) {
      this._m_LocalRotation.setTo(rotation);

      this._updateLocalMatrix();
    }
    /**
     * 设置旋转欧拉角。<br/>
     * @param {Number}[x 轴欧拉角]
     * @param {Number}[y 轴欧拉角]
     * @param {Number}[z 轴欧拉角]
     */

  }, {
    key: "setLocalRotationFromEuler",
    value: function setLocalRotationFromEuler(x, y, z) {
      this._m_LocalRotation.fromEuler(x, y, z);

      this._updateLocalMatrix();
    }
    /**
     * 使用四元数值设置旋转部分。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     * @param {Number}[w]
     */

  }, {
    key: "setLocalRotationFromXYZW",
    value: function setLocalRotationFromXYZW(x, y, z, w) {
      this._m_LocalRotation.setToInXYZW(x, y, z, w);

      this._updateLocalMatrix();
    }
    /**
     * 返回旋转。<br/>
     * @returns {Quaternion}
     */

  }, {
    key: "getLocalRotation",
    value: function getLocalRotation() {
      return this._m_LocalRotation;
    }
    /**
     * 设置平移。<br/>
     * @param {Vector3}[translation]
     */

  }, {
    key: "setLocalTranslation",
    value: function setLocalTranslation(translation) {
      this._m_LocalTranslation.setTo(translation);

      this._updateLocalMatrix();
    }
    /**
     * 设置平移。<br/>
     * @param {Number}[x]
     * @param {Number}[y]
     * @param {Number}[z]
     */

  }, {
    key: "setLocalTranslationXYZ",
    value: function setLocalTranslationXYZ(x, y, z) {
      this._m_LocalTranslation.setToInXYZ(x, y, z);

      this._updateLocalMatrix();
    }
    /**
     * 返回平移。<br/>
     * @returns {Vector3}
     */

  }, {
    key: "getLocalTranslation",
    value: function getLocalTranslation() {
      return this._m_LocalTranslation;
    }
    /**
     * 更新包围体。<br/>
     * @private
     */

  }, {
    key: "_updateBounding",
    value: function _updateBounding() {
      this._m_UpdateBoundingVolume = true;
    }
    /**
     * 更新本地矩阵。<br/>
     * @private
     */

  }, {
    key: "_updateLocalMatrix",
    value: function _updateLocalMatrix() {
      this._m_UpdateLocalMatrix = true;

      this._updateWorldMatrix(); // 更新边界


      this._updateBounding();

      if (this._m_Parent != null) {
        this._m_Parent._updateBounding();
      }

      this._m_Children.forEach(function (children) {
        children._updateBounding();
      });
    }
    /**
     * 更新世界矩阵。<br/>
     * @private
     */

  }, {
    key: "_updateWorldMatrix",
    value: function _updateWorldMatrix() {
      this._m_UpdateWorldMatrix = true; // 通知所有子节点更新世界矩阵

      this._m_Children.forEach(function (children) {
        children._updateWorldMatrix();
      });
    }
    /**
     * 返回本地矩阵。<br/>
     * @returns {Matrix44}
     */

  }, {
    key: "getLocalMatrix",
    value: function getLocalMatrix() {
      if (this._m_UpdateLocalMatrix) {
        // 更新本地矩阵
        _Matrix.default.composeMat4(this._m_LocalTranslation, this._m_LocalRotation, this._m_LocalScale, this._m_LocalMatrix);

        this._m_UpdateLocalMatrix = false;
      }

      return this._m_LocalMatrix;
    }
    /**
     * 设置本地矩阵。<br/>
     * @param {Matrix44}[matrix]
     */

  }, {
    key: "setLocalMatrix",
    value: function setLocalMatrix(matrix) {
      // 覆盖矩阵
      this._m_LocalMatrix.set(matrix);

      this._updateLocalMatrix(); // updateLocalMatrix设置UpdateLocalMatrix为true,但是我们手动复制了matrix到localMatrix中,所以可以在updateLocalMatrix()调用后手动设置UpdateLocalMatrix为false减少计算量


      this._m_UpdateLocalMatrix = false; // 从矩阵提取translation,rotation,scale

      _Matrix.default.decomposeMat4(matrix, this._m_LocalTranslation, this._m_LocalRotation, this._m_LocalScale);
    }
    /**
     * 设置本地矩阵。<br/>
     * @param {Number[]}[mat44Array]
     */

  }, {
    key: "setLocalMatrixFromArray",
    value: function setLocalMatrixFromArray(mat44Array) {
      // 覆盖矩阵
      this._m_LocalMatrix.setArray(mat44Array);

      this._updateLocalMatrix(); // updateLocalMatrix设置UpdateLocalMatrix为true,但是我们手动复制了matrix到localMatrix中,所以可以在updateLocalMatrix()调用后手动设置UpdateLocalMatrix为false减少计算量


      this._m_UpdateLocalMatrix = false; // 从矩阵提取translation,rotation,scale

      _Matrix.default.decomposeMat4(this._m_LocalMatrix, this._m_LocalTranslation, this._m_LocalRotation, this._m_LocalScale);
    }
    /**
     * 返回世界矩阵。<br/>
     * @returns {Matrix44}
     */

  }, {
    key: "getWorldMatrix",
    value: function getWorldMatrix() {
      if (this._m_UpdateWorldMatrix) {
        // 更新世界矩阵
        this._buildWorldMatrix();
      }

      return this._m_WorldMatrix;
    }
    /**
     * 构建世界矩阵。<br/>
     * @private
     */

  }, {
    key: "_buildWorldMatrix",
    value: function _buildWorldMatrix() {
      if (this._m_UpdateWorldMatrix) {
        // 1.执行本地矩阵变换
        var localMatrix = this.getLocalMatrix(); // 2.执行世界变换

        if (!this._m_Parent) {
          // 复制,不要使用引用,因为Node可实时调整父节点
          this._m_WorldMatrix.set(this._m_LocalMatrix);
        } else {
          // 执行世界变换
          // 获取父变换矩阵,只要一个父节点获取了父节点变换矩阵,那么父节点变换矩阵就已经被计算了(即只会计算一次)
          // 由于渲染不会按照场景图进行渲染,而是按照排序算法，遮挡算法进行处理，所以更新节点成本很低(每个需要更新的节点只会计算一次)
          // 合并矩阵
          _Matrix.default.multiplyMM(this._m_WorldMatrix, 0, this._m_Parent.getWorldMatrix(), 0, this._m_LocalMatrix, 0);
        } // ...


        this._m_UpdateWorldMatrix = false;
      }
    }
    /**
     * 返回节点名称。<br/>
     * @return {String}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
    /**
     * 添加一个子节点。<br/>
     * @param {Node}[children]
     */

  }, {
    key: "addChildren",
    value: function addChildren(children) {
      if (children instanceof Node) {
        // 检测children组件是否已经载入scene组件列表
        // 检测children是否已经添加过
        if (children._m_Parent == null && !this._m_ChildrenIDs[children.getName()]) {
          this._m_ChildrenIDs[children.getName()] = children;

          this._m_Children.push(children);

          children._m_Parent = this; // 更新子节点

          children._updateWorldMatrix();

          this._updateBounding();
        } else {
          var nextName = children.getName() + _Tools.default.nextId();

          _Log.default.warn("已存在:" + children.getName() + ",重命名为:" + nextName);

          children._m_Name = nextName;

          if (children._m_Parent == null) {
            this._m_ChildrenIDs[children.getName()] = children;

            this._m_Children.push(children);

            children._m_Parent = this; // 更新子节点

            children._updateWorldMatrix();

            this._updateBounding();
          } else {
            _Log.default.warn(nextName + "已存在与父节点:" + children._m_Parent.getName());
          }
        }
      } else {
        _Log.default.error("children不是一个合法的Node!");
      }
    }
    /**
     * 移除一个子节点。<br/>
     * @param {Node}[children]
     */

  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      if (children instanceof Node) {
        if (this._m_ChildrenIDs[children.getName()]) {
          this._m_ChildrenIDs[children.getName()] = null;

          var i = this._m_Children.indexOf(children);

          if (i > -1) {
            this._m_Children.splice(i, 1);
          }

          children._m_Parent = null;
        }
      }
    }
    /**
     * 深度优先遍历场景图。<br/>
     * @param {Function}[call]
     */

  }, {
    key: "traverse",
    value: function traverse(call) {
      if (call) {
        call(this);
      }

      this._m_Children.forEach(function (children) {
        if (call) {
          call(children);
        }

        children.traverse(call);
      });
    }
  }]);

  return Node;
}(_Component2.default);

exports["default"] = Node;

_defineProperty(Node, "S_DEFAULT_FRUSTUM_CULLING", 1 << 1);

_defineProperty(Node, "S_DYNAMIC", 1 << 2);

_defineProperty(Node, "S_ALWAYS", 1 << 3);

_defineProperty(Node, "S_NEVER", 1 << 4);

_defineProperty(Node, "S_SHADOW_RECEIVE", 1 << 1);

_defineProperty(Node, "S_SHADOW_CAST", 1 << 2);

_defineProperty(Node, "S_SHADOW_CAST_AND_RECEIVE", 1 << 3);

_defineProperty(Node, "S_SHADOW_NONE", 0);

_defineProperty(Node, "S_TEMP_VEC3", new _Vector.default());

_defineProperty(Node, "S_TEMP_Q", new _Quaternion.default());

_defineProperty(Node, "S_TEMP_VEC3_2", new _Vector.default());

/***/ }),

/***/ 7280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Picture用于提供图像输出需要,一般而言,用它作为GUI元素或Frame输出结果。<br/>
 * @author Kkk
 * @data 2021年2月14日615点32分
 */
var Picture = /*#__PURE__*/function (_Geometry) {
  _inherits(Picture, _Geometry);

  var _super = _createSuper(Picture);

  function Picture(owner, cfg) {
    var _this;

    _classCallCheck(this, Picture);

    _this = _super.call(this, owner, cfg);
    _this._m_Width = cfg.width || 1.0;
    _this._m_Height = cfg.height || 1.0;
    _this._m_Zindex = 1;
    _this._m_Left = 0;
    _this._m_Top = 0; // 创建mesh

    var mesh = new _Mesh.default(); // 创建一个最远的picture

    mesh.setData(_Mesh.default.S_POSITIONS, [-1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1]);
    mesh.setData(_Mesh.default.S_UV0, [0, 1, 0, 0, 1, 1, 1, 0]);
    mesh.setData(_Mesh.default.S_INDICES, [0, 1, 2, 2, 1, 3]);

    _this.setMesh(mesh);

    _this.updateBound(); // 过滤标记


    _this._m_FilterFlag = _Node.default.S_NEVER; // 阴影模式

    _this._m_ShadowMode = _Node.default.S_SHADOW_NONE;
    return _this;
  }
  /**
   * 使用默认材质。<br/>
   */


  _createClass(Picture, [{
    key: "getType",
    value: function getType() {
      return 'Picture';
    }
  }, {
    key: "useDefaultMat",
    value: function useDefaultMat() {
      this.setMaterial(new _Material.default(this._m_Scene, {
        id: 'picture_gui_' + _Tools.default.nextId(),
        materialDef: _MaterialDef.default.parse(_Internal.default.S_PICTURE_DEF_DATA)
      }));
    }
    /**
     * 设置大小。<br/>
     * @param {Number}[w 值为0.0-1.0]
     * @param {Number}[h 值为0.0-1.0]
     */

  }, {
    key: "setSize",
    value: function setSize(w, h) {
      if (this._m_Width != w || this._m_Height != h) {
        this.setLocalScaleXYZ(w, h, 1);
      }
    }
    /**
     * 设置左上角位置，即绘制开始点，以左上角为起始位置。<br/>
     * @param {Number}[left 0.0-1.0]
     * @param {Number}[top 0.0-1.0]
     */

  }, {
    key: "setLeftTop",
    value: function setLeftTop(left, top) {
      if (this._m_Left != left || this._m_Top != top) {
        this._m_Left = left;
        this._m_Top = top;
        this.setLocalTranslationXYZ(this._m_Left, this._m_Top, 2.0 * this._m_Zindex - 1.0);
      }
    }
    /**
     * 设置深度位置，默认为1，最顶层为0，最底层为1。<br/>
     * @param {Number}[zIndex 0-1]
     */

  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      if (this._m_Zindex != zIndex) {
        this._m_Zindex = Math.min(Math.max(0, zIndex), 1);

        var w = this._m_Scene.getCanvas().getWidth();

        var h = this._m_Scene.getCanvas().getHeight();

        this.setLocalTranslationXYZ(this._m_Left, this._m_Top, 2.0 * this._m_Zindex - 1.0);
      }
    }
    /**
     * 返回宽度。<br/>
     * @return {Number}[值为像素单位]
     */

  }, {
    key: "getWidthSize",
    value: function getWidthSize() {
      return this._m_Width * this._m_Scene.getCanvas().getWidth();
    }
    /**
     * 返回宽度。<br/>
     * @return {Number}[值为0.0-1.0]
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this._m_Width;
    }
    /**
     * 返回高度。<br/>
     * @return {Number}[值为像素单位]
     */

  }, {
    key: "getHeightSize",
    value: function getHeightSize() {
      return this._m_Height * this._m_Scene.getCanvas().getHeight();
    }
    /**
     * 返回高度。<br/>
     * @return {Number}[值为0.0-1.0]
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this._m_Height;
    }
  }, {
    key: "isDrawable",
    value: function isDrawable() {
      return true;
    }
  }, {
    key: "isGUI",
    value: function isGUI() {
      return true;
    }
  }]);

  return Picture;
}(_Geometry2.default);

exports["default"] = Picture;

/***/ }),

/***/ 5765:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Box。<br/>
 * @author Kkk
 * @date 2021年2月22日16点52分
 */
var Box = /*#__PURE__*/function (_Geometry) {
  _inherits(Box, _Geometry);

  var _super = _createSuper(Box);

  /**
   * 创建一个Box。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   * @param {Number}[cfg.xHalf x方向的半长度]
   * @param {Number}[cfg.yHalf y方向的半长度]
   * @param {Number}[cfg.zHalf z方向的半长度]
   * @param {Vector3}[cfg.center 中心点]
   */
  function Box(owner, cfg) {
    var _this;

    _classCallCheck(this, Box);

    _this = _super.call(this, owner, cfg);
    var xHalf = cfg.xHalf || 1;

    if (xHalf <= 0) {
      console.error("xHalf不能小于等于0!");
      xHalf *= -1;
    }

    var yHalf = cfg.yHalf || 1;

    if (yHalf <= 0) {
      console.error("yHalf不能小于等于0!");
      yHalf *= -1;
    }

    var zHalf = cfg.zHalf || 1;

    if (zHalf <= 0) {
      console.error("zHalf不能小于等于0!");
      zHalf *= -1;
    }

    var center = cfg.center;
    var centerX = center ? center._m_X : 0;
    var centerY = center ? center._m_Y : 0;
    var centerZ = center ? center._m_Z : 0;
    var xmin = -xHalf + centerX;
    var ymin = -yHalf + centerY;
    var zmin = -zHalf + centerZ;
    var xmax = xHalf + centerX;
    var ymax = yHalf + centerY;
    var zmax = zHalf + centerZ;
    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, [// v0-v1-v2-v3 front
    xmax, ymax, zmax, xmin, ymax, zmax, xmin, ymin, zmax, xmax, ymin, zmax, // v0-v3-v4-v1 right
    xmax, ymax, zmax, xmax, ymin, zmax, xmax, ymin, zmin, xmax, ymax, zmin, // v0-v1-v6-v1 top
    xmax, ymax, zmax, xmax, ymax, zmin, xmin, ymax, zmin, xmin, ymax, zmax, // v1-v6-v7-v2 left
    xmin, ymax, zmax, xmin, ymax, zmin, xmin, ymin, zmin, xmin, ymin, zmax, // v7-v4-v3-v2 bottom
    xmin, ymin, zmin, xmax, ymin, zmin, xmax, ymin, zmax, xmin, ymin, zmax, // v4-v7-v6-v1 back
    xmax, ymin, zmin, xmin, ymin, zmin, xmin, ymax, zmin, xmax, ymax, zmin]);
    mesh.setData(_Mesh.default.S_NORMALS, [// v0-v1-v2-v3 front
    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v3-v4-v5 right
    1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v5-v6-v1 top
    0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v1-v6-v7-v2 left
    -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v7-v4-v3-v2 bottom
    0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v4-v7-v6-v5 back
    0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);
    mesh.setData(_Mesh.default.S_UV0, [// v0-v1-v2-v3 front
    1, 0, 0, 0, 0, 1, 1, 1, // v0-v3-v4-v1 right
    0, 0, 0, 1, 1, 1, 1, 0, // v0-v1-v6-v1 top
    1, 1, 1, 0, 0, 0, 0, 1, // v1-v6-v7-v2 left
    1, 0, 0, 0, 0, 1, 1, 1, // v7-v4-v3-v2 bottom
    0, 1, 1, 1, 1, 0, 0, 0, // v4-v7-v6-v1 back
    0, 1, 1, 1, 1, 0, 0, 0]);
    mesh.setData(_Mesh.default.S_INDICES, [0, 1, 2, 0, 2, 3, // front
    4, 5, 6, 4, 6, 7, // right
    8, 9, 10, 8, 10, 11, // top
    12, 13, 14, 12, 14, 15, // left
    16, 17, 18, 16, 18, 19, // bottom
    20, 21, 22, 20, 22, 23]); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  _createClass(Box, [{
    key: "getType",
    value: function getType() {
      return 'Box';
    }
  }]);

  return Box;
}(_Geometry2.default);

exports["default"] = Box;

/***/ }),

/***/ 4992:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Cylinder。<br/>
 * 一个基础圆柱体，锥体形体几何。<br/>
 * 参考:http://www.e-reading-lib.com/bookreader.php/143437/Pike_-_DirectX_8_Programming_Tutorial.html。<br/>
 * @author Kkk
 * @date 2021年9月28日15点31分
 */
var Cylinder = /*#__PURE__*/function (_Geometry) {
  _inherits(Cylinder, _Geometry);

  var _super = _createSuper(Cylinder);

  /**
   * 创建一个Cylinder。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   * @param {Number}[cfg.radiusTop 顶部圆盖半径,最小为1,此时接近点]
   * @param {Number}[cfg.radiusBottom 底部圆盖半径,最小为1,此时接近点]
   * @param {Number}[cfg.height 柱体高度,默认1]
   * @param {Number}[cfg.radialSegments 半径切片数目,默认60]
   * @param {Vector3}[cfg.heightSegments 柱体切片数目,默认1]
   * @param {Vector3}[cfg.openEnded 开口,默认false]
   */
  function Cylinder(owner, cfg) {
    var _this;

    _classCallCheck(this, Cylinder);

    _this = _super.call(this, owner, cfg);
    /* config */

    var radiusTop = cfg.radiusTop !== undefined ? cfg.radiusTop : 1;
    var radiusBottom = cfg.radiusBottom !== undefined ? cfg.radiusBottom : 1;
    var height = cfg.height !== undefined ? cfg.height : 1;
    var radialSegments = cfg.radialSegments || 60;
    var heightSegments = cfg.heightSegments || 1;
    var openEnded = cfg.openEnded || false;
    /* config end */

    var heightHalf = height / 2;
    var heightLength = height / heightSegments;
    var radialAngle = 2.0 * Math.PI / radialSegments;
    var radialLength = 1.0 / radialSegments;
    var nextRadius = _this.radiusBottom;
    var radiusChange = (radiusTop - radiusBottom) / heightSegments;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = []; // 创建顶点属性

    var normalY = (90.0 - Math.atan(height / (radiusBottom - radiusTop)) * 180 / Math.PI) / 90.0;

    for (var h = 0; h <= heightSegments; h++) {
      var currentRadius = radiusTop - h * radiusChange;
      var currentHeight = heightHalf - h * heightLength;

      for (var i = 0; i <= radialSegments; i++) {
        var x = Math.sin(i * radialAngle);
        var z = Math.cos(i * radialAngle);
        normals.push(currentRadius * x);
        normals.push(normalY); //todo

        normals.push(currentRadius * z);
        uvs.push(1 - i * radialLength);
        uvs.push(0 + h * 1 / heightSegments);
        positions.push(currentRadius * x);
        positions.push(currentHeight);
        positions.push(currentRadius * z);
      }
    } // indices部分


    for (var _h = 0; _h < heightSegments; _h++) {
      for (var _i = 0; _i <= radialSegments; _i++) {
        var first = _h * (radialSegments + 1) + _i;
        var second = first + radialSegments;
        indices.push(first);
        indices.push(second);
        indices.push(second + 1);
        indices.push(first);
        indices.push(second + 1);
        indices.push(first + 1);
      }
    } // 创建顶部圆盖


    if (!openEnded && radiusTop > 0) {
      var startIndex = positions.length / 3; // 顶部中心

      normals.push(0.0);
      normals.push(1.0);
      normals.push(0.0);
      uvs.push(0.5);
      uvs.push(0.5);
      positions.push(0);
      positions.push(heightHalf);
      positions.push(0); // 顶部三角形面

      for (var _i2 = 0; _i2 <= radialSegments; _i2++) {
        var _x = Math.sin(_i2 * radialAngle);

        var _z = Math.cos(_i2 * radialAngle);

        var tu = 0.5 * Math.sin(_i2 * radialAngle) + 0.5;
        var tv = 0.5 * Math.cos(_i2 * radialAngle) + 0.5;
        normals.push(radiusTop * _x);
        normals.push(1.0);
        normals.push(radiusTop * _z);
        uvs.push(tu);
        uvs.push(tv);
        positions.push(radiusTop * _x);
        positions.push(heightHalf);
        positions.push(radiusTop * _z);
      }

      for (var _i3 = 0; _i3 < radialSegments; _i3++) {
        var center = startIndex;

        var _first = startIndex + 1 + _i3;

        indices.push(_first);
        indices.push(_first + 1);
        indices.push(center);
      }
    } // 创建底部圆盖


    if (!openEnded && radiusBottom > 0) {
      var _startIndex = positions.length / 3; // 底部中心


      normals.push(0.0);
      normals.push(-1.0);
      normals.push(0.0);
      uvs.push(0.5);
      uvs.push(0.5);
      positions.push(0);
      positions.push(0 - heightHalf);
      positions.push(0); // 底部三角形面

      for (var _i4 = 0; _i4 <= radialSegments; _i4++) {
        var _x2 = Math.sin(_i4 * radialAngle);

        var _z2 = Math.cos(_i4 * radialAngle);

        var _tu = 0.5 * Math.sin(_i4 * radialAngle) + 0.5;

        var _tv = 0.5 * Math.cos(_i4 * radialAngle) + 0.5;

        normals.push(radiusBottom * _x2);
        normals.push(-1.0);
        normals.push(radiusBottom * _z2);
        uvs.push(_tu);
        uvs.push(_tv);
        positions.push(radiusBottom * _x2);
        positions.push(0 - heightHalf);
        positions.push(radiusBottom * _z2);
      }

      for (var _i5 = 0; _i5 < radialSegments; _i5++) {
        var _center = _startIndex;

        var _first2 = _startIndex + 1 + _i5;

        indices.push(_center);
        indices.push(_first2 + 1);
        indices.push(_first2);
      }
    }

    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, positions);
    mesh.setData(_Mesh.default.S_NORMALS, normals);
    mesh.setData(_Mesh.default.S_UV0, uvs);
    mesh.setData(_Mesh.default.S_INDICES, indices); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  return Cylinder;
}(_Geometry2.default);

exports["default"] = Cylinder;

/***/ }),

/***/ 7698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Grid。<br/>
 * @author Kkk
 * @date 2021年9月26日16点35分
 */
var Grid = /*#__PURE__*/function (_Geometry) {
  _inherits(Grid, _Geometry);

  var _super = _createSuper(Grid);

  /**
   * 根据指定参数创建一个Grid。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   * @param {Number}[cfg.width x方向每个切片长度,默认1]
   * @param {Number}[cfg.height z方向每个切片长度,默认1]
   * @param {Number}[cfg.widthSegments x方向切片数量,默认1]
   * @param {Number}[cfg.heightSegments z方向切片数量,默认1]
   */
  function Grid(owner, cfg) {
    var _this;

    _classCallCheck(this, Grid);

    _this = _super.call(this, owner, cfg);
    var width = cfg.width || 1.0;
    var height = cfg.height || 1.0;
    var widthSegments = cfg.widthSegments || 1;
    var heightSegments = cfg.heightSegments || 1;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    var ix, iz;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridX = widthSegments;
    var gridZ = heightSegments;
    var gridX1 = gridX + 1;
    var gridZ1 = gridZ + 1;
    var segWidth = width / gridX;
    var segHeight = height / gridZ;
    var x;
    var z;

    for (iz = 0; iz < gridZ1; iz++) {
      for (ix = 0; ix < gridX1; ix++) {
        x = ix * segWidth - halfWidth;
        z = iz * segHeight - halfHeight;
        positions.push(x);
        positions.push(0);
        positions.push(-z);
        normals.push(0);
        normals.push(1);
        normals.push(0);
        uvs.push(ix / gridX);
        uvs.push(1 - iz / gridZ);
      }
    }

    var a;
    var b;
    var c;
    var d;

    for (iz = 0; iz < gridZ; iz++) {
      for (ix = 0; ix < gridX; ix++) {
        a = ix + gridX1 * iz;
        b = ix + gridX1 * (iz + 1);
        c = ix + 1 + gridX1 * (iz + 1);
        d = ix + 1 + gridX1 * iz;
        indices.push(a);
        indices.push(b);
        indices.push(c);
        indices.push(c);
        indices.push(d);
        indices.push(a);
      }
    }

    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, positions);
    mesh.setData(_Mesh.default.S_NORMALS, normals);
    mesh.setData(_Mesh.default.S_UV0, uvs);
    mesh.setData(_Mesh.default.S_INDICES, indices); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);
    mesh.setPrimitive(_Mesh.default.S_PRIMITIVE_LINES);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  return Grid;
}(_Geometry2.default);

exports["default"] = Grid;

/***/ }),

/***/ 1645:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * GroupPlane。<br/>
 * @author Kkk
 * @date 2021年2月22日17点18分
 */
var GroupPlane = /*#__PURE__*/function (_Geometry) {
  _inherits(GroupPlane, _Geometry);

  var _super = _createSuper(GroupPlane);

  /**
   * 根据指定参数创建一个Plane。<br/>
   * @param {Component}[owner]
   * @param {String}[cfg.id]
   * @param {Vector3}[cfg.center 中心点]
   * @param {Number}[cfg.xSize x方向半长,默认1]
   * @param {Number}[cfg.zSize z方向半长,默认1]
   * @param {Number}[cfg.xSegments x方向切片数量,默认1]
   * @param {Number}[cfg.zSegments z方向切片数量,默认1]
   * @param {Boolean}[cfg.xRepeat x方向重复纹理,必须xSegments大于1.0]
   * @param {Boolean}[cfg.zRepeat z方向重复纹理,必须zSegments大于1.0]
   */
  function GroupPlane(owner, cfg) {
    var _this;

    _classCallCheck(this, GroupPlane);

    _this = _super.call(this, owner, cfg); // 创建Plane

    var xSize = cfg.xSize || 1;

    if (xSize <= 0) {
      console.error("xSize不能小于等于0!");
      xSize *= -1;
    }

    var zSize = cfg.zSize || 1;

    if (zSize <= 0) {
      console.error("zSize不能小于等于0!");
      zSize *= -1;
    }

    var xSegments = cfg.xSegments || 1;

    if (xSegments <= 0) {
      console.error("xSegments不能小于等于0!");
      xSegments *= -1;
    }

    if (xSegments < 1) {
      xSegments = 1;
    }

    var zSegments = cfg.zSegments || 1;

    if (zSegments < 0) {
      console.error("zSegments不能小于等于0!");
      zSegments *= -1;
    }

    if (zSegments < 1) {
      zSegments = 1;
    }

    var center = cfg.center;
    var centerX = center ? center[0] : 0;
    var centerY = center ? center[1] : 0;
    var centerZ = center ? center[2] : 0;
    var halfWidth = xSize / 2;
    var halfHeight = zSize / 2;
    var planeX = Math.floor(xSegments) || 1;
    var planeZ = Math.floor(zSegments) || 1;
    var planeX1 = planeX + 1;
    var planeZ1 = planeZ + 1;
    var segmentWidth = xSize / planeX;
    var segmentHeight = zSize / planeZ;
    var positions = new Float32Array(planeX1 * planeZ1 * 3);
    var normals = new Float32Array(planeX1 * planeZ1 * 3);
    var uvs = new Float32Array(planeX1 * planeZ1 * 2);
    var offset = 0;
    var offset2 = 0;
    var iz;
    var ix;
    var x;
    var a;
    var b;
    var c;
    var d;

    for (iz = 0; iz < planeZ1; iz++) {
      var z = iz * segmentHeight - halfHeight;

      for (ix = 0; ix < planeX1; ix++) {
        x = ix * segmentWidth - halfWidth;
        positions[offset] = x + centerX;
        positions[offset + 1] = centerY;
        positions[offset + 2] = -z + centerZ;
        normals[offset + 2] = -1;
        uvs[offset2] = planeX - ix;
        uvs[offset2 + 1] = planeZ - iz;

        if (!cfg.xRepeat) {
          uvs[offset2] /= planeX;
        }

        if (!cfg.zRepeat) {
          uvs[offset2 + 1] /= planeZ;
        }

        offset += 3;
        offset2 += 2;
      }
    }

    offset = 0;
    var indices = new (positions.length / 3 > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);

    for (iz = 0; iz < planeZ; iz++) {
      for (ix = 0; ix < planeX; ix++) {
        a = ix + planeX1 * iz;
        b = ix + planeX1 * (iz + 1);
        c = ix + 1 + planeX1 * (iz + 1);
        d = ix + 1 + planeX1 * iz;
        indices[offset] = d;
        indices[offset + 1] = b;
        indices[offset + 2] = a;
        indices[offset + 3] = d;
        indices[offset + 4] = c;
        indices[offset + 5] = b;
        offset += 6;
      }
    }

    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, positions);
    mesh.setData(_Mesh.default.S_NORMALS, normals);
    mesh.setData(_Mesh.default.S_UV0, uvs);
    mesh.setData(_Mesh.default.S_INDICES, indices); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  return GroupPlane;
}(_Geometry2.default);

exports["default"] = GroupPlane;

/***/ }),

/***/ 6341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Sphere。<br/>
 * @author Kkk
 * @date 2021年2月22日17点02分
 */
var Sphere = /*#__PURE__*/function (_Geometry) {
  _inherits(Sphere, _Geometry);

  var _super = _createSuper(Sphere);

  /**
   * 根据指定的参数创建一个Sphere。<br/>
   * @param {Component}[owner]
   * @param {Number}[cfg.lod 细节等级,默认1]
   * @param {Vector3}[cfg.center 中心点]
   * @param {Number}[cfg.radius 半径,默认为1]
   * @param {Number}[cfg.widthSegments 宽度方向的切片数量,默认18]
   * @param {Number}[cfg.heightSegments 高度方向的切片数量,默认18]
   * @param {Number}[cfg.widthUVScale 宽度方向的uv缩放,默认0.5]
   * @param {Number}[cfg.heightUVScale 高度方向的uv缩放,默认0.5]
   */
  function Sphere(owner, cfg) {
    var _this;

    _classCallCheck(this, Sphere);

    _this = _super.call(this, owner, cfg); // 创建Sphere

    var lod = cfg.lod || 1;
    var centerX = cfg.center ? cfg.center._m_X : 0;
    var centerY = cfg.center ? cfg.center._m_Y : 0;
    var centerZ = cfg.center ? cfg.center._m_Z : 0;
    var radius = cfg.radius || 1;

    if (radius <= 0) {
      console.error("radius不能小于等于0!");
      radius *= -1;
    }

    var heightSegments = cfg.heightSegments || 18;

    if (heightSegments <= 0) {
      console.error("heightSegments不能小于等于0!");
      heightSegments *= -1;
    }

    heightSegments = Math.floor(lod * heightSegments);

    if (heightSegments < 18) {
      heightSegments = 18;
    }

    var widthSegments = cfg.widthSegments || 18;

    if (widthSegments <= 0) {
      console.error("widthSegments不能小于等于0!");
      widthSegments *= -1;
    }

    widthSegments = Math.floor(lod * widthSegments);

    if (widthSegments < 18) {
      widthSegments = 18;
    }

    var widthUVScale = cfg.widthUVScale || 0.5;
    var heightUVScale = cfg.heightUVScale || 0.5;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    var i;
    var j;
    var theta;
    var sinTheta;
    var cosTheta;
    var phi;
    var sinPhi;
    var cosPhi;
    var x;
    var y;
    var z;
    var u;
    var v;
    var first;
    var second;

    for (i = 0; i <= heightSegments; i++) {
      theta = i * Math.PI / heightSegments;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);

      for (j = 0; j <= widthSegments; j++) {
        phi = j * 2 * Math.PI / widthSegments;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        u = 1.0 - j / (widthSegments * widthUVScale);
        v = i / (heightSegments * widthUVScale);
        normals.push(x);
        normals.push(y);
        normals.push(z);
        uvs.push(u);
        uvs.push(v);
        positions.push(centerX + radius * x);
        positions.push(centerY + radius * y);
        positions.push(centerZ + radius * z);
      }
    }

    for (i = 0; i < heightSegments; i++) {
      for (j = 0; j < widthSegments; j++) {
        first = i * (widthSegments + 1) + j;
        second = first + widthSegments + 1;
        indices.push(first + 1);
        indices.push(second + 1);
        indices.push(second);
        indices.push(first + 1);
        indices.push(second);
        indices.push(first);
      }
    }

    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, positions);
    mesh.setData(_Mesh.default.S_NORMALS, normals);
    mesh.setData(_Mesh.default.S_UV0, uvs);
    mesh.setData(_Mesh.default.S_INDICES, indices); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  _createClass(Sphere, [{
    key: "getType",
    value: function getType() {
      return 'Sphere';
    }
  }]);

  return Sphere;
}(_Geometry2.default);

exports["default"] = Sphere;

/***/ }),

/***/ 8011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Torus。<br/>
 * 一个圆环形体。<br/>
 * @author Kkk
 * @date 2021年9月28日15点50分
 */
var Torus = /*#__PURE__*/function (_Geometry) {
  _inherits(Torus, _Geometry);

  var _super = _createSuper(Torus);

  /**
   * @param {Component}[owner]
   * @param {Number}[cfg.tube 管宽,默认0.3]
   * @param {Vector3}[cfg.center 中心点]
   * @param {Number}[cfg.radius 半径,默认为1]
   * @param {Number}[cfg.segmentsR R切片数目默认32]
   * @param {Number}[cfg.segmentsT T切片数目默认24
   * @param {Number}[cfg.arc 弧度,默认pi/2]
   */
  function Torus(owner, cfg) {
    var _this;

    _classCallCheck(this, Torus);

    _this = _super.call(this, owner, cfg);
    var radius = cfg.radius || 1;
    var tube = cfg.tube || 0.3;
    var segmentsR = cfg.segmentsR || 32;
    var segmentsT = cfg.segmentsT || 24;
    var arc = cfg.arc || Math.PI * 2;
    var positions = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    var u;
    var v;
    var centerX;
    var centerY;
    var centerZ = 0;
    var x;
    var y;
    var z;
    var vec;

    for (var j = 0; j <= segmentsR; j++) {
      for (var i = 0; i <= segmentsT; i++) {
        u = i / segmentsT * arc;
        v = j / segmentsR * Math.PI * 2;
        centerX = radius * Math.cos(u);
        centerY = radius * Math.sin(u);
        x = (radius + tube * Math.cos(v)) * Math.cos(u);
        y = (radius + tube * Math.cos(v)) * Math.sin(u);
        z = tube * Math.sin(v);
        positions.push(x);
        positions.push(y);
        positions.push(z);
        uvs.push(i / segmentsT);
        uvs.push(1 - j / segmentsR);
        vec = _this.normalize(_this.sub([x, y, z], [centerX, centerY, centerZ], []), []);
        normals.push(vec[0]);
        normals.push(vec[1]);
        normals.push(vec[2]);
      }
    }

    var a;
    var b;
    var c;
    var d;

    for (var _j = 1; _j <= segmentsR; _j++) {
      for (var _i = 1; _i <= segmentsT; _i++) {
        a = (segmentsT + 1) * _j + _i - 1;
        b = (segmentsT + 1) * (_j - 1) + _i - 1;
        c = (segmentsT + 1) * (_j - 1) + _i;
        d = (segmentsT + 1) * _j + _i;
        indices.push(a);
        indices.push(b);
        indices.push(c);
        indices.push(c);
        indices.push(d);
        indices.push(a);
      }
    }

    var mesh = new _Mesh.default();
    mesh.setData(_Mesh.default.S_POSITIONS, positions);
    mesh.setData(_Mesh.default.S_NORMALS, normals);
    mesh.setData(_Mesh.default.S_UV0, uvs);
    mesh.setData(_Mesh.default.S_INDICES, indices); // 切线数据

    var tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

    mesh.setData(_Mesh.default.S_TANGENTS, tangents);

    _this.setMesh(mesh);

    _this.updateBound();

    return _this;
  }

  _createClass(Torus, [{
    key: "normalize",
    value: function normalize(v, dest) {
      var f = 1.0 / len(v);
      return this.mul(v, f, dest);
    }
  }, {
    key: "len",
    value: function len(v) {
      return Math.sqrt(this.sqLen(v));
    }
  }, {
    key: "sqLen",
    value: function sqLen(v) {
      return this.dot(v, v);
    }
  }, {
    key: "dot",
    value: function dot(u, v) {
      return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
    }
  }, {
    key: "mul",
    value: function mul(v, s, dest) {
      dest[0] = v[0] * s;
      dest[1] = v[1] * s;
      dest[2] = v[2] * s;
      return dest;
    }
  }, {
    key: "sub",
    value: function sub(u, v, dest) {
      dest[0] = u[0] - v[0];
      dest[1] = u[1] - v[1];
      dest[2] = u[2] - v[2];
      return dest;
    }
  }]);

  return Torus;
}(_Geometry2.default);

exports["default"] = Torus;

/***/ }),

/***/ 9468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry2 = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * SkyBox。<br/>
 * 表示一个天空盒，由一组6切片纹理定义，或有球形环境图（比如HDR环境图）定义。<br/>
 * SkyBox的展开图如下:<br/>
 *         _____
 *        |     |
 *        | +Y  |
 *   _____|_____|_____ _____
 *  |     |     |     |     |
 *  | -X  | +Z  | +X  | -Z  |
 *  |_____|_____|_____|_____|
 *        |     |
 *        | -Y  |
 *        |_____|
 * 典型的用法是:<br/>
 * let skyMat = skyBox.getMaterial();<br/>
 * skyMat.setParam("useCubeMap", new BoolVars().valueOf(true));
 * skyMat.setParam("cubeMap", TextureCubeVars);<br/>
 * 对于球形环境图,其用法如下:<br/>
 * skyMat.setParam("useEnvMap", new BoolVars().valueOf(true));<br/>
 * skyMat.setParam("envMap", Texture2DVars);<br/>
 * 只能二选一。<br/>
 * @author Kkk
 * @date 2021年3月20日21点05分
 */
var SkyBox = /*#__PURE__*/function (_Geometry) {
  _inherits(SkyBox, _Geometry);

  var _super = _createSuper(SkyBox);

  function SkyBox(owner, cfg) {
    var _this;

    _classCallCheck(this, SkyBox);

    _this = _super.call(this, owner, cfg);
    var mesh = new _Mesh.default(); // 对于不需要旋转的Sky,我们仅需要positions和indices数据

    mesh.setData(_Mesh.default.S_POSITIONS, [3.4201992, 0.0, -9.396927, 2.7669992, 2.0103426, -9.396927, 1.0568995, 3.2528028, -9.396927, -1.0568998, 3.2528026, -9.396927, -2.7669995, 2.0103424, -9.396927, -3.4201992, -2.9900332E-7, -9.396927, -2.766999, -2.010343, -9.396927, -1.0569, -3.2528026, -9.396927, 1.0569001, -3.2528026, -9.396927, 2.7670002, -2.0103416, -9.396927, 3.4201992, 0.0, -9.396927, 6.427875, 0.0, -7.660445, 5.20026, 3.7782102, -7.660445, 1.9863225, 6.1132727, -7.660445, -1.9863229, 6.113272, -7.660445, -5.2002606, 3.7782097, -7.660445, -6.427875, -5.6194267E-7, -7.660445, -5.2002597, -3.7782109, -7.660445, -1.9863232, -6.113272, -7.660445, 1.9863235, -6.113272, -7.660445, 5.2002616, -3.7782083, -7.660445, 6.427875, 0.0, -7.660445, 8.6602545, 0.0, -4.9999995, 7.0062933, 5.0903697, -4.9999995, 2.6761656, 8.236392, -4.9999995, -2.676166, 8.236391, -4.9999995, -7.006294, 5.090369, -4.9999995, -8.6602545, -7.5710346E-7, -4.9999995, -7.006293, -5.0903707, -4.9999995, -2.6761668, -8.236391, -4.9999995, 2.676167, -8.236391, -4.9999995, 7.006295, -5.0903673, -4.9999995, 8.6602545, 0.0, -4.9999995, 9.848078, 0.0, -1.7364818, 7.9672623, 5.7885547, -1.7364818, 3.0432231, 9.366078, -1.7364818, -3.0432239, 9.366078, -1.7364818, -7.9672627, 5.788554, -1.7364818, -9.848078, -8.6094633E-7, -1.7364818, -7.967262, -5.788556, -1.7364818, -3.0432243, -9.366078, -1.7364818, 3.0432246, -9.366078, -1.7364818, 7.9672647, -5.788552, -1.7364818, 9.848078, 0.0, -1.7364818, 9.848078, 0.0, 1.7364826, 7.9672623, 5.7885547, 1.7364826, 3.0432231, 9.366078, 1.7364826, -3.0432239, 9.366078, 1.7364826, -7.9672627, 5.788554, 1.7364826, -9.848078, -8.6094633E-7, 1.7364826, -7.967262, -5.788556, 1.7364826, -3.0432243, -9.366078, 1.7364826, 3.0432246, -9.366078, 1.7364826, 7.9672647, -5.788552, 1.7364826, 9.848078, 0.0, 1.7364826, 8.660254, 0.0, 5.0000005, 7.0062923, 5.090369, 5.0000005, 2.6761653, 8.236391, 5.0000005, -2.6761658, 8.23639, 5.0000005, -7.006293, 5.0903687, 5.0000005, -8.660254, -7.571034E-7, 5.0000005, -7.006292, -5.09037, 5.0000005, -2.6761663, -8.23639, 5.0000005, 2.6761665, -8.23639, 5.0000005, 7.0062943, -5.090367, 5.0000005, 8.660254, 0.0, 5.0000005, 6.427875, 0.0, 7.660445, 5.20026, 3.7782102, 7.660445, 1.9863225, 6.1132727, 7.660445, -1.9863229, 6.113272, 7.660445, -5.2002606, 3.7782097, 7.660445, -6.427875, -5.6194267E-7, 7.660445, -5.2002597, -3.7782109, 7.660445, -1.9863232, -6.113272, 7.660445, 1.9863235, -6.113272, 7.660445, 5.2002616, -3.7782083, 7.660445, 6.427875, 0.0, 7.660445, 3.4201992, 0.0, 9.396927, 2.7669992, 2.0103426, 9.396927, 1.0568995, 3.2528028, 9.396927, -1.0568998, 3.2528026, 9.396927, -2.7669995, 2.0103424, 9.396927, -3.4201992, -2.9900332E-7, 9.396927, -2.766999, -2.010343, 9.396927, -1.0569, -3.2528026, 9.396927, 1.0569001, -3.2528026, 9.396927, 2.7670002, -2.0103416, 9.396927, 3.4201992, 0.0, 9.396927, 0.0, 0.0, -10.0, 0.0, 0.0, 10.0]); // mesh.setData(Mesh.S_NORMALS, [-0.34201992, -0.0, 0.9396927, -0.27669993, -0.20103426, 0.9396927, -0.10568996, -0.32528028, 0.9396927, 0.10568998, -0.32528028, 0.9396927, 0.27669996, -0.20103423, 0.9396927, 0.34201992, 2.990033E-8, 0.9396927, 0.2766999, 0.20103431, 0.9396927, 0.10569, 0.32528028, 0.9396927, -0.10569002, 0.32528028, 0.9396927, -0.27670002, 0.20103417, 0.9396927, -0.34201992, -0.0, 0.9396927, -0.6427875, -0.0, 0.76604456, -0.520026, -0.37782103, 0.76604456, -0.19863226, -0.6113273, 0.76604456, 0.19863228, -0.61132723, 0.76604456, 0.5200261, -0.37782097, 0.76604456, 0.6427875, 5.6194267E-8, 0.76604456, 0.52002597, 0.3778211, 0.76604456, 0.19863233, 0.61132723, 0.76604456, -0.19863234, 0.61132723, 0.76604456, -0.52002615, 0.37782082, 0.76604456, -0.6427875, -0.0, 0.76604456, -0.86602545, -0.0, 0.49999997, -0.70062935, -0.50903696, 0.49999997, -0.26761654, -0.82363915, 0.4999999, 0.2676166, -0.8236391, 0.49999997, 0.70062935, -0.5090369, 0.4999999, 0.86602545, 7.5710346E-8, 0.49999997, 0.70062923, 0.509037, 0.4999999, 0.2676167, 0.8236391, 0.49999997, -0.26761672, 0.8236391, 0.49999997, -0.7006295, 0.5090367, 0.4999999, -0.86602545, -0.0, 0.49999997, -0.9848078, -0.0, 0.17364818, -0.7967262, -0.57885545, 0.17364818, -0.30432233, -0.93660784, 0.17364818, 0.3043224, -0.93660784, 0.17364818, 0.7967263, -0.57885545, 0.17364818, 0.9848078, 8.609464E-8, 0.17364818, 0.79672617, 0.57885563, 0.17364818, 0.30432245, 0.93660784, 0.17364818, -0.30432245, 0.93660784, 0.17364818, -0.79672647, 0.5788552, 0.17364818, -0.9848078, -0.0, 0.17364818, -0.9848078, -0.0, -0.17364827, -0.7967262, -0.57885545, -0.17364827, -0.30432233, -0.93660784, -0.17364827, 0.3043224, -0.93660784, -0.17364827, 0.7967263, -0.57885545, -0.17364827, 0.9848078, 8.609464E-8, -0.17364827, 0.7967261, 0.5788556, -0.17364825, 0.30432242, 0.9366078, -0.17364825, -0.30432245, 0.9366078, -0.17364825, -0.79672647, 0.5788552, -0.17364827, -0.9848078, -0.0, -0.17364827, -0.8660254, -0.0, -0.50000006, -0.70062923, -0.50903696, -0.50000006, -0.26761654, -0.8236391, -0.50000006, 0.2676166, -0.82363904, -0.50000006, 0.7006293, -0.5090369, -0.50000006, 0.8660254, 7.571034E-8, -0.50000006, 0.7006292, 0.509037, -0.50000006, 0.26761663, 0.82363904, -0.50000006, -0.26761666, 0.82363904, -0.50000006, -0.7006294, 0.5090367, -0.50000006, -0.8660254, -0.0, -0.50000006, -0.6427875, -0.0, -0.76604456, -0.520026, -0.37782103, -0.76604456, -0.19863226, -0.6113273, -0.76604456, 0.19863228, -0.61132723, -0.76604456, 0.5200261, -0.37782097, -0.76604456, 0.6427875, 5.6194267E-8, -0.76604456, 0.52002597, 0.3778211, -0.76604456, 0.19863233, 0.61132723, -0.76604456, -0.19863234, 0.61132723, -0.76604456, -0.52002615, 0.37782082, -0.76604456, -0.6427875, -0.0, -0.76604456, -0.34201992, -0.0, -0.9396927, -0.27669993, -0.20103426, -0.9396927, -0.10568996, -0.32528028, -0.9396927, 0.10568998, -0.32528028, -0.9396927, 0.27669996, -0.20103423, -0.9396927, 0.34201992, 2.990033E-8, -0.9396927, 0.2766999, 0.20103431, -0.9396927, 0.10569, 0.32528028, -0.9396927, -0.10569002, 0.32528028, -0.9396927, -0.27670002, 0.20103417, -0.9396927, -0.34201992, -0.0, -0.9396927, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0]);

    mesh.setData(_Mesh.default.S_INDICES, [0, 11, 1, 1, 11, 12, 1, 12, 2, 2, 12, 13, 2, 13, 3, 3, 13, 14, 3, 14, 4, 4, 14, 15, 4, 15, 5, 5, 15, 16, 5, 16, 6, 6, 16, 17, 6, 17, 7, 7, 17, 18, 7, 18, 8, 8, 18, 19, 8, 19, 9, 9, 19, 20, 9, 20, 10, 10, 20, 21, 11, 22, 12, 12, 22, 23, 12, 23, 13, 13, 23, 24, 13, 24, 14, 14, 24, 25, 14, 25, 15, 15, 25, 26, 15, 26, 16, 16, 26, 27, 16, 27, 17, 17, 27, 28, 17, 28, 18, 18, 28, 29, 18, 29, 19, 19, 29, 30, 19, 30, 20, 20, 30, 31, 20, 31, 21, 21, 31, 32, 22, 33, 23, 23, 33, 34, 23, 34, 24, 24, 34, 35, 24, 35, 25, 25, 35, 36, 25, 36, 26, 26, 36, 37, 26, 37, 27, 27, 37, 38, 27, 38, 28, 28, 38, 39, 28, 39, 29, 29, 39, 40, 29, 40, 30, 30, 40, 41, 30, 41, 31, 31, 41, 42, 31, 42, 32, 32, 42, 43, 33, 44, 34, 34, 44, 45, 34, 45, 35, 35, 45, 46, 35, 46, 36, 36, 46, 47, 36, 47, 37, 37, 47, 48, 37, 48, 38, 38, 48, 49, 38, 49, 39, 39, 49, 50, 39, 50, 40, 40, 50, 51, 40, 51, 41, 41, 51, 52, 41, 52, 42, 42, 52, 53, 42, 53, 43, 43, 53, 54, 44, 55, 45, 45, 55, 56, 45, 56, 46, 46, 56, 57, 46, 57, 47, 47, 57, 58, 47, 58, 48, 48, 58, 59, 48, 59, 49, 49, 59, 60, 49, 60, 50, 50, 60, 61, 50, 61, 51, 51, 61, 62, 51, 62, 52, 52, 62, 63, 52, 63, 53, 53, 63, 64, 53, 64, 54, 54, 64, 65, 55, 66, 56, 56, 66, 67, 56, 67, 57, 57, 67, 68, 57, 68, 58, 58, 68, 69, 58, 69, 59, 59, 69, 70, 59, 70, 60, 60, 70, 71, 60, 71, 61, 61, 71, 72, 61, 72, 62, 62, 72, 73, 62, 73, 63, 63, 73, 74, 63, 74, 64, 64, 74, 75, 64, 75, 65, 65, 75, 76, 66, 77, 67, 67, 77, 78, 67, 78, 68, 68, 78, 79, 68, 79, 69, 69, 79, 80, 69, 80, 70, 70, 80, 81, 70, 81, 71, 71, 81, 82, 71, 82, 72, 72, 82, 83, 72, 83, 73, 73, 83, 84, 73, 84, 74, 74, 84, 85, 74, 85, 75, 75, 85, 86, 75, 86, 76, 76, 86, 87, 0, 1, 88, 1, 2, 88, 2, 3, 88, 3, 4, 88, 4, 5, 88, 5, 6, 88, 6, 7, 88, 7, 8, 88, 8, 9, 88, 9, 10, 88, 77, 89, 78, 78, 89, 79, 79, 89, 80, 80, 89, 81, 81, 89, 82, 82, 89, 83, 83, 89, 84, 84, 89, 85, 85, 89, 86, 86, 89, 87]);

    _this.setMesh(mesh);

    _this.updateBound(); // 材质


    var defSkyMat = new _Material.default(owner, {
      id: cfg.id + _Tools.default.nextId(),
      materialDef: _MaterialDef.default.parse(_Internal.default.S_DEFAULT_SKY_BOX_DEF)
    });

    _this.setMaterial(defSkyMat);

    return _this;
  }

  _createClass(SkyBox, [{
    key: "getType",
    value: function getType() {
      return 'SkyBox';
    }
  }]);

  return SkyBox;
}(_Geometry2.default);

exports["default"] = SkyBox;

/***/ }),

/***/ 2482:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * LodControl。<br/>
 * 该控制器提供了对持有对象（通常继承自Geometry）的"Level of detail"的支持。<br/>
 * 最初的思路是查找屏幕面积得到需要的lod级别，尽管该逻辑大部分正确，但是暂时使用更快的范围级别LOD。<br/>
 * @author Kkk
 * @date 2021年3月14日08点30分
 * @lastdate 2021年3月15日16点26分
 */
var LodControl = /*#__PURE__*/function (_Component) {
  _inherits(LodControl, _Component);

  var _super = _createSuper(LodControl);

  /**
   * 创建LodControl。<br/>
   * @param {Geometry}[owner]
   * @param {String}[cfg.id 组件id]
   * @param {Number}[cfg.distCommonDifference 每个层次的距离公差,默认为1.0]
   * @param {Number}[cfg.trisPerPixel 每像素三角形数量,由于暂时不基于面积实现,所以忽略该参数]
   */
  function LodControl(owner, cfg) {
    var _this;

    _classCallCheck(this, LodControl);

    _this = _super.call(this, owner, cfg);

    if (!(owner instanceof _Node.default)) {
      _Log.default.error('owner必须是Geometry或其子类!');
    } // 记录最后的距离


    _this._m_LastDistance = 0.0; // 记录最后的细节层次级别

    _this._m_LastLodLevel = 0; // 距离公差

    _this._m_DistCommonDifference = cfg.distCommonDifference || 1.0; // 每个层级距离

    _this._m_LodLevelDists = []; // 每像素三角形大小

    _this._m_TrisPerPixel = cfg.trisPerPixel || 1.0; // 细节层次数量

    _this._m_NumLodLevels = 0; // 每个细节层次三角形数量

    _this._m_NumTris = [];

    _this.distr();

    _this._m_Scene.on('render', function (exTime) {
      _this._doUpdate();
    });

    return _this;
  }
  /**
   * 分配数据。<br/>
   */


  _createClass(LodControl, [{
    key: "getType",
    value: function getType() {
      return 'LodControl';
    }
  }, {
    key: "distr",
    value: function distr() {
      this._m_NumLodLevels = this._m_Owner.getMesh().getLodLevelCount();

      for (var i = 0; i < this._m_NumLodLevels; i++) {
        this._m_NumTris[i] = this._m_Owner.getMesh().getLodPrimitiveCount(i);
        this._m_LodLevelDists[i] = this._m_DistCommonDifference * i;
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      var bv = this._m_Owner.getBoundingVolume();

      var mainCamera = this._m_Scene.getMainCamera();

      var atanNH = Math.atan(mainCamera.getTop() * mainCamera.getNear());
      var ratio = Math.PI / (8.0 * atanNH);
      var distance = bv.distance(mainCamera.getEye()) / ratio;
      var lodLevel = 0; // Log.log('distance:' + distance + ';lastDistance:' + this._m_LastDistance + ";d:" + Math.abs(distance - this._m_LastDistance));

      if (distance > this._m_LastDistance && Math.abs(distance - this._m_LastDistance) <= this._m_DistCommonDifference) {
        // 在细节层次有效移动范围内,不改变细节层次级别
        lodLevel = this._m_LastLodLevel;
      } else if (this._m_LastDistance > distance && this._m_LastLodLevel == 0) {
        // 已经处于最低级别,但仍在靠近物体,直接返回最低级别
        lodLevel = this._m_LastLodLevel;
      } else if (this._m_LastDistance < distance && this._m_LastLodLevel == this._m_NumLodLevels - 1) {
        // 已经处于最远级别,但仍在远离物体,直接返回最远级别
        lodLevel = this._m_LastLodLevel;
      } else {
        if (distance > this._m_LastDistance) {
          lodLevel = this._m_LastLodLevel + 1;
        } else {
          lodLevel = this._m_LastLodLevel - 1;
        }

        lodLevel = Math.min(lodLevel, this._m_NumLodLevels);
        lodLevel = Math.max(lodLevel, 0);
        this._m_LastDistance = this._m_LodLevelDists[lodLevel]; // 下面是另一个实现,使用近似面积计算,但是似乎该实现有问题
        // // 近似计算边界体面积
        // // 按照最远过滤查找最匹配的细节层次级别
        // this._m_LastDistance = distance;
        //
        // let area = Tools.approxScreenArea(bv, this._m_LastDistance, mainCamera.getWidth()) * this._m_TrisPerPixel;
        // lodLevel = this._m_NumLodLevels - 1;
        // for(let i = this._m_NumLodLevels;--i >= 0;){
        //     if(area - this._m_NumTris[i] < 0){
        //         break;
        //     }
        //     lodLevel = i;
        // }

        this._m_LastLodLevel = lodLevel;
      }

      this._m_Owner.lod(lodLevel);
    }
  }]);

  return LodControl;
}(_Component2.default);

exports["default"] = LodControl;

/***/ }),

/***/ 9011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _OctNode = _interopRequireDefault(__webpack_require__(9369));

var _Geometry = _interopRequireDefault(__webpack_require__(4720));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _MeshFactor = _interopRequireDefault(__webpack_require__(8583));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * OctCullingControl。<br/>
 * 对有界场景树提供基于动态八叉树优化策略。<br/>
 * @author Kkk
 * @date 2021年2月26日16点21分
 */
var OctCullingControl = /*#__PURE__*/function (_Component) {
  _inherits(OctCullingControl, _Component);

  var _super = _createSuper(OctCullingControl);

  function OctCullingControl(owner, cfg) {
    var _this;

    _classCallCheck(this, OctCullingControl);

    _this = _super.call(this, owner, cfg);
    _this._m_OctNode = null; // 判断当前持有对象是否为有效的Node类型

    if (owner instanceof _Node.default) {
      // 以该owner为树根节点构建八叉树
      owner.clearCullingFlags(_Node.default.S_DEFAULT_FRUSTUM_CULLING); // 默认深度4

      _this.createOct(owner, 4); // 在每一帧渲染时进行八叉树加速剔除


      if (_this._m_OctNode) {
        var visDrawables = null;
        var frustumCullingCamera = null; // 这里的架构有问题,理论上应该是owner来更新子组件,但是这里直接监听scene组件的render事件,后面再调整架构

        _this._m_Scene.on('render', function (exTime) {
          // 获取剔除相机和显示列表
          visDrawables = _this._m_Scene.getRender().getVisDrawables();
          frustumCullingCamera = _this._m_Scene.getFrustumCullingCamera();

          _this.octCulling(frustumCullingCamera, visDrawables);
        });
      }
    }

    return _this;
  }
  /**
   * 调试OctCullingControl。<br/>
   * 将Octree叶子节点绘制到渲染器中以便查看计算正确性。<br/>
   * @param {Node}[sceneNode]
   * @param {Material}[debugMat]
   * @param {OctNode}[leaf]
   * @private
   */


  _createClass(OctCullingControl, [{
    key: "getType",
    value: function getType() {
      return 'OctCullingControl';
    }
  }, {
    key: "_debug",
    value: function _debug(sceneNode, debugMat, leaf) {
      var _this2 = this;

      if (leaf.isValid()) {
        var leafGeo = new _Geometry.default(sceneNode, {
          id: _MeshFactor.default.nextId() + "_oct"
        });
        leafGeo.setMesh(_MeshFactor.default.createAABBBoundingBoxMeshFromAABBBoundingBox(leaf.getAABBBoundingBox()));
        leafGeo.setMaterial(debugMat);
        leafGeo.updateBound(); // leafGeo.clearCullingFlags(Node.S_DEFAULT_FRUSTUM_CULLING);

        sceneNode.addChildren(leafGeo); // 子列表

        if (leaf.getLeafs()) {
          leaf.getLeafs().forEach(function (leaf) {
            _this2._debug(sceneNode, debugMat, leaf);
          });
        }
      }
    }
    /**
     * 调试OctCullingControl。<br/>
     * 通过将Octree绘制到引擎中以便调试。<br/>
     * @param {Node}[sceneNode]
     * @param {Material}[debugMat]
     */

  }, {
    key: "debug",
    value: function debug(sceneNode, debugMat) {
      if (this._m_OctNode) {
        // 绘制八叉树到sceneNode中
        this._debug(sceneNode, debugMat, this._m_OctNode); // console.log("oct:", this._m_OctNode);

      }
    }
    /**
     * 创建八叉树。<br/>
     * @param {Node}[node]
     * @param {Number}[depth]
     */

  }, {
    key: "createOct",
    value: function createOct(node, depth) {
      // 获取AABB边界
      var aabb = node.getBoundingVolume();

      if (aabb) {
        // 如果存在有效边界体,则进行构建,这意味着无效根节点不会为其创建八叉树
        // 标准八叉树
        var standardAABB = new _AABBBoundingBox.default();
        var xHalf = aabb.getXHalf();
        var yHalf = aabb.getYHalf();
        var zHalf = aabb.getZHalf();
        var d = Math.max(Math.max(xHalf, yHalf), zHalf);
        var c = aabb.getCenter();
        standardAABB.fromMinMax(new _Vector.default(-d + c._m_X, -d + c._m_Y, -d + c._m_Z), new _Vector.default(d + c._m_X, d + c._m_Y, d + c._m_Z));
        this._m_OctNode = new _OctNode.default(null, standardAABB); // 用于标记根节点为有效(这里其实应该判断子节点是否有一个包含有效数据)

        this._m_OctNode.setValid(true);

        _Log.default.debug("开始预建!");

        this._preBuilt(this._m_OctNode, depth);

        _Log.default.debug("预建完成!"); // 分配八叉树


        this.distrNode(node, this._m_OctNode);
      }
    }
    /**
     * 预建叶子。<br/>
     * @param {OctNode}[oct 父节点]
     * @param {Number}[depth 当前深度]
     * @private
     */

  }, {
    key: "_preBuiltOctLeaf",
    value: function _preBuiltOctLeaf(oct, depth) {
      // 建立叶子
      // 并对每个叶子递归预建立
      var leaf = null;
      var leafs = oct.getLeafs();
      var pAABB = oct.getAABBBoundingBox();
      var pMin = pAABB.getMin();
      var pMax = pAABB.getMax();
      var pCenter = pAABB.getCenter(); // tbl
      // min.x,center.y,min.z/center.x,max.y,center.z

      OctCullingControl.S_TEMP_MIN.setToInXYZ(pMin._m_X, pCenter._m_Y, pMin._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pCenter._m_X, pMax._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // tfl
      // min.x,center.y,center.z/center.x,max.y,max.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pMin._m_X, pCenter._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pCenter._m_X, pMax._m_Y, pMax._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // tbr
      // center.x,center.y,min.z/max.x,max.y,center.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pCenter._m_X, pCenter._m_Y, pMin._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pMax._m_X, pMax._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // tfr
      // center.x,center.y,center.z/max.x,max.y,max.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pCenter._m_X, pCenter._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pMax._m_X, pMax._m_Y, pMax._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // bbl
      // min.x,min.y,min.z/center.x,center.y,center.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pMin._m_X, pMin._m_Y, pMin._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pCenter._m_X, pCenter._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // bfl
      // min.x,min.y,center.z/center.x,center.y,max.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pMin._m_X, pMin._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pCenter._m_X, pCenter._m_Y, pMax._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // bbr
      // center.x,min.y,min.z/max.x,center.y,center.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pCenter._m_X, pMin._m_Y, pMin._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pMax._m_X, pCenter._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth); // bfr
      // center.x,min.y,center.z/max.x,center.y,max.z


      OctCullingControl.S_TEMP_MIN.setToInXYZ(pCenter._m_X, pMin._m_Y, pCenter._m_Z);
      OctCullingControl.S_TEMP_MAX.setToInXYZ(pMax._m_X, pCenter._m_Y, pMax._m_Z);
      OctCullingControl.S_TEMP_AABBBOUNDINGBOX.fromMinMax(OctCullingControl.S_TEMP_MIN, OctCullingControl.S_TEMP_MAX);
      leaf = new _OctNode.default(null, OctCullingControl.S_TEMP_AABBBOUNDINGBOX);
      leafs.push(leaf);

      this._preBuilt(leaf, depth);
    }
    /**
     * 根据深度预建Oct。<br/>
     * @param {OctNode}[oct]
     * @param {Number}[depth]
     * @private
     */

  }, {
    key: "_preBuilt",
    value: function _preBuilt(oct, depth) {
      // 递归建立八叉树
      if (depth > 0) {
        depth--;
        oct.initLeafs(); // 创建叶子

        this._preBuiltOctLeaf(oct, depth);
      }
    }
    /**
     * 分配Node到Octree中。<br/>
     * @param {Node}[node]
     * @param {OctNode}[oct]
     */

  }, {
    key: "distrNode",
    value: function distrNode(node, oct) {
      var _this3 = this;

      var children = node.getChildren();

      if (children && children.length > 0) {
        // 将子节点分配到合适的八叉树节点中
        children.forEach(function (cn) {
          _this3.distrNode(cn, oct);
        });
      } else if (node instanceof _Geometry.default) {
        // 默认ref到Geometry
        // 理论上也应该只ref到Geometry
        this.distrOct(node, oct);
      }
    }
    /**
     * 分配ref到octree中。<br/>
     * @param {Object}[ref 一般是Geometry]
     * @param {OctNode}[oct]
     * @return {Boolean}
     */

  }, {
    key: "distrOct",
    value: function distrOct(ref, oct) {
      var refAABB = ref.getBoundingVolume();

      if (oct.getAABBBoundingBox().contains(refAABB)) {
        // 递归leaf
        var leafs = oct.getLeafs();

        if (leafs != null) {
          var distrToLeaf = false;

          for (var i = 0; i < 8; i++) {
            // 只要有一个leaf包含该ref则退出(因为包含是完全包含)
            if (this.distrOct(ref, leafs[i])) {
              // 将此节点标记为有效,以便加速剔除
              distrToLeaf = true;
              oct.setValid(true);
              break;
            }
          } // 说明无法被leaf包含
          // 则添加到当前oct


          if (!distrToLeaf) {
            oct.addRef(ref);
            oct.setValid(true);
          }

          return true;
        } else {
          // 已经是leaf,包含该ref并返回true
          oct.addRef(ref);
          oct.setValid(true);
          return true;
        }
      } // 当前节点无法包含ref


      return false;
    }
    /**
     * 剔除叶子节点。<br/>
     * @param {OctNode}[leaf]
     * @param {Camera}[frustumCamera]
     * @param {Drawable[]}[visDrawables]
     */

  }, {
    key: "cullingLeafs",
    value: function cullingLeafs(leaf, frustumCamera, visDrawables) {
      var _this4 = this;

      // 只检测有效叶子
      if (leaf.isValid()) {
        if (leaf.inFrustum(frustumCamera)) {
          if (leaf.getRefs()) {
            // 加入渲染列表
            var restoreFrustumMask = frustumCamera.getFrustumMask();
            leaf.getRefs().forEach(function (ref) {
              // 对这些ref进行精确FrustumCulling
              // 似乎有bug
              if (ref.inFrustum(frustumCamera)) {
                visDrawables.push(ref);
              } // visDrawables.push(ref);


              frustumCamera.setFrustumMask(restoreFrustumMask);
            });
          } // 判断是否为叶子节点


          if (leaf.getLeafs()) {
            // 递归检测其叶子列表
            var _restoreFrustumMask = frustumCamera.getFrustumMask();

            leaf.getLeafs().forEach(function (leaf) {
              frustumCamera.setFrustumMask(_restoreFrustumMask);

              _this4.cullingLeafs(leaf, frustumCamera, visDrawables);
            });
          }
        }
      }
    }
    /**
     * 进行octCulling。<br/>
     * @param {Camera}[frustumCamera]
     * @param {Drawables[]}[visDrawables]
     */

  }, {
    key: "octCulling",
    value: function octCulling(frustumCamera, visDrawables) {
      var restoreFrustumMask = frustumCamera.getFrustumMask(); // 从oct根节点开始

      frustumCamera.setFrustumMask(0);
      this.cullingLeafs(this._m_OctNode, frustumCamera, visDrawables); // 恢复

      frustumCamera.setFrustumMask(restoreFrustumMask);
    }
  }]);

  return OctCullingControl;
}(_Component2.default);

exports["default"] = OctCullingControl;

_defineProperty(OctCullingControl, "S_TEMP_AABBBOUNDINGBOX", new _AABBBoundingBox.default());

_defineProperty(OctCullingControl, "S_TEMP_MIN", new _Vector.default());

_defineProperty(OctCullingControl, "S_TEMP_MAX", new _Vector.default());

/***/ }),

/***/ 9369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var OctNode = /*#__PURE__*/function () {
  // 叶子节点编号

  /**
   * 八叉树节点。<br/>
   * @param {Object[]}[refs 这里一般指向一个Geometry列表]
   * @param {AABBBoundingBox}[aabbBoundingBox]
   */
  function OctNode(refs, aabbBoundingBox) {
    _classCallCheck(this, OctNode);

    // OctNode可能不包含Ref列表,但其叶子包含,所以仍然可能是有效节点
    this._m_Valid = false;
    this._m_Refs = refs;
    this._m_AABBBoundingBox = new _AABBBoundingBox.default();

    this._m_AABBBoundingBox.setTo(aabbBoundingBox);

    this._m_Leafs = null; // 剔除状态

    this._m_FrustumContain = null;
  }
  /**
   * 检测是否处于视锥体中。<br/>
   * @param camera
   * @return {boolean}
   */


  _createClass(OctNode, [{
    key: "inFrustum",
    value: function inFrustum(camera) {
      // 执行视锥剔除
      this._m_FrustumContain = camera.frustumContains(this.getAABBBoundingBox());
      return this._m_FrustumContain != _Camera.default.S_FRUSTUM_INTERSECT_OUTSIDE;
    }
    /**
     * 设置为有效节点。<br/>
     * @param {Boolean}[valid]
     */

  }, {
    key: "setValid",
    value: function setValid(valid) {
      this._m_Valid = valid;
    }
    /**
     * 是否为有效节点。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return this._m_Valid;
    }
    /**
     * 添加一个ref。<br/>
     * @param {Object}[ref]
     */

  }, {
    key: "addRef",
    value: function addRef(ref) {
      if (!this._m_Refs) {
        this._m_Refs = [];
      }

      this._m_Refs.push(ref);
    }
    /**
     * 返回所有ref。<br/>
     * @return {Object[]}
     */

  }, {
    key: "getRefs",
    value: function getRefs() {
      return this._m_Refs;
    }
    /**
     * 返回AABBBoundingBox。<br/>
     * @return {AABBBoundingBox}
     */

  }, {
    key: "getAABBBoundingBox",
    value: function getAABBBoundingBox() {
      return this._m_AABBBoundingBox;
    }
    /**
     * 返回指定叶子。<br/>
     * @param {Number}[number]
     * @return {OctNode}
     */

  }, {
    key: "getLeaf",
    value: function getLeaf(number) {
      return this._m_Leafs[number];
    }
    /**
     * 返回叶子列表。<br/>
     * @return {OctNode[]}
     */

  }, {
    key: "getLeafs",
    value: function getLeafs() {
      return this._m_Leafs;
    }
  }, {
    key: "initLeafs",
    value: function initLeafs() {
      // 不一定8个子节点,可变性
      this._m_Leafs = [];
    }
  }]);

  return OctNode;
}();

exports["default"] = OctNode;

_defineProperty(OctNode, "S_LEAF_TBL", 0);

_defineProperty(OctNode, "S_LEAF_TFL", 1);

_defineProperty(OctNode, "S_LEAF_TBR", 2);

_defineProperty(OctNode, "S_LEAF_TFR", 3);

_defineProperty(OctNode, "S_LEAF_BBL", 4);

_defineProperty(OctNode, "S_LEAF_BFL", 5);

_defineProperty(OctNode, "S_LEAF_BBR", 6);

_defineProperty(OctNode, "S_LEAF_BFR", 7);

/***/ }),

/***/ 1797:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 渲染引擎框架,提供启动和关闭引擎的操作。<br/>
 * 其中,包含一个主循环,以便为加入的场景实现渲染。<br/>
 * @author Kkk
 * @date 2020年9月15日15点43分
 */
var RenderEngine = /*#__PURE__*/function () {
  function RenderEngine() {
    _classCallCheck(this, RenderEngine);

    this._m_Scenes = [];
    this._m_SceneIds = {};
    this._m_Stop = false;
  }
  /**
   * 添加一个场景
   * @param scene
   */


  _createClass(RenderEngine, [{
    key: "addScene",
    value: function addScene(scene) {
      if (!this._m_SceneIds[scene.id]) {
        this._m_SceneIds[scene.id] = scene;

        this._m_Scenes.push(scene);
      }
    }
    /**
     * 移除一个场景
     * @param scene
     */

  }, {
    key: "removeScene",
    value: function removeScene(scene) {
      if (this._m_SceneIds[scene.id]) {
        this._m_SceneIds[scene.id] = null;

        this._m_Scenes.remove(scene);
      }
    }
    /**
     * 启动引擎
     */

  }, {
    key: "launch",
    value: function launch() {
      var _this = this;

      this._m_Stop = false;

      var _self = this;

      var startTime = Date.now();

      var _t = 1.0 / 1000.0;

      var _loop = function _loop() {
        var time = Date.now();
        var exTime = (time - startTime) * _t;
        startTime = time; // 执行所有下一帧之前的任务
        // 比如组件的更新
        // 之所以这样设计,是为了避免在scene.update中遍历场景图进行更新组件

        _this._m_Scenes.forEach(function (scene) {
          scene.update(exTime);
          scene.render(exTime);
        });

        if (!_self._m_Stop) requestAnimationFrame(_loop);
      };

      requestAnimationFrame(_loop);
    }
  }, {
    key: "close",
    value: function close() {
      this._m_Stop = true;
    }
  }]);

  return RenderEngine;
}();

exports["default"] = RenderEngine;

/***/ }),

/***/ 7664:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * IDrawable接口定义了一个渲染元素,只有实现这个接口的对象才是一个可渲染元素。<br/>
 * @author Kkk
 */
var IDrawable = /*#__PURE__*/function () {
  function IDrawable() {
    _classCallCheck(this, IDrawable);
  }
  /**
   * 表示当前是否为可渲染实例
   */


  _createClass(IDrawable, [{
    key: "isDrawable",
    value: function isDrawable() {}
    /**
     * 是否属于Post帧提交渲染
     */

  }, {
    key: "isFramePicture",
    value: function isFramePicture() {}
    /**
     * 是否为非透明
     */

  }, {
    key: "isOpaque",
    value: function isOpaque() {}
    /**
     * 是否为半透明。<br/>
     */

  }, {
    key: "isTranslucent",
    value: function isTranslucent() {}
    /**
     * 是否为透明。<br/>
     */

  }, {
    key: "isTransparent",
    value: function isTransparent() {}
    /**
     * 绘制当前元素。<br/>
     * @param frameContext
     */

  }, {
    key: "draw",
    value: function draw(frameContext) {}
  }]);

  return IDrawable;
}();

exports["default"] = IDrawable;

/***/ }),

/***/ 3370:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Internal = function Internal() {
  _classCallCheck(this, Internal);
};

exports["default"] = Internal;

_defineProperty(Internal, "S_WIREFRAME_DEF_DATA", "// 由于webGL基于openGLES3.x,其不存在openGL线框模式,所以在这里通过shader实现线框\n" + "Def WireframeDef{\n" + "    Params{\n" + "        vec4 color;\n" + "        float wireframeWidth;\n" + "    }\n" + "    SubTechnology Wireframe{\n" + "        Vars{\n" + "            vec3 bary;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "                bary = Context.InBarycentric;\n" + "\n" + "\n" + "\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                #ifdef Params.color\n" + "                    vec4 _wireframeColor = Params.color;\n" + "                #else\n" + "                    vec4 _wireframeColor = vec4(0.2f, 0.2f, 0.2f, 1.0f);\n" + "                #endif\n" + "                #ifdef Params.wireframeWidth\n" + "                    float _wireframeWidth = Params.wireframeWidth;\n" + "                #else\n" + "                    float _wireframeWidth = 0.01f;\n" + "                #endif\n" + "                if(any(lessThan(bary, vec3(_wireframeWidth)))){\n" + "                    Context.OutColor = _wireframeColor;\n" + "                }\n" + "                else{\n" + "                    discard;\n" + "                }\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass Wireframe{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_COLOR_DEF_DATA", "// 颜色材质,提供指定颜色或颜色纹理并渲染\n" + "Def ColorDef{\n" + "    Params{\n" + "        vec4 color;\n" + "        sampler2D colorMap;\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology ScalePass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                //Context.OutPosition = Context.ProjectViewModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                mat4 scaleMat4 = mat4(\n" + "                    0.2f, 0.0f, 0.0f, 0.0f,\n" + "                    0.0f, 0.2f, 0.0f, 0.0f,\n" + "                    0.0f, 0.0f, 0.2f, 0.0f,\n" + "                    0.0f, 0.0f, 0.0f, 1.0f\n" + "                );\n" + "                Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                // 使用自定义颜色输出\n" + "                #ifdef Params.color\n" + "                    Context.OutColor = Params.color;\n" + "                #else\n" + "                    // 使用纹理\n" + "                    #ifdef Params.colorMap\n" + "                        Context.OutColor = texture(Params.colorMap, Context.InUv0);\n" + "                        #ifdef Params.alphaDiscard\n" + "                            if(Context.OutColor.a < Params.alphaDiscard){\n" + "                                discard;\n" + "                            }\n" + "                        #endif\n" + "                    #else\n" + "                        Context.OutColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n" + "                    #endif\n" + "                #endif\n" + "                vec4 wPosition = wordPosition;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology ColorPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                //Context.OutPosition = Context.ProjectViewModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                // 使用自定义颜色输出\n" + "                #ifdef Params.color\n" + "                    Context.OutColor = Params.color;\n" + "                #else\n" + "                    // 使用纹理\n" + "                    #ifdef Params.colorMap\n" + "                        Context.OutColor = texture(Params.colorMap, uv0);\n" + "                        #ifdef Params.alphaDiscard\n" + "                            if(Context.OutColor.a < Params.alphaDiscard){\n" + "                                discard;\n" + "                            }\n" + "                        #endif\n" + "                    #else\n" + "                        Context.OutColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n" + "                    #endif\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology GreenPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                // 先判断Params.color是否有值\n" + "                #ifdef Params.color\n" + "                    Context.OutColor = Params.color;\n" + "                #else\n" + "                    Context.OutColor = vec4(0.0f, 1.0f, 0.0f, 1.0f);\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass ColorPass{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology Green{\n" + "        Sub_Pass{\n" + "            Pass GreenPass{\n" + "            }\n" + "        }\n" + "    }\n" + "    // ScaleColorPass\n" + "    Technology ScaleColor{\n" + "        Sub_Pass{\n" + "            //第一个pass不应该写入深度,否则第二个pass被剔除\n" + "            //可以指定每个pass的写入状态,比如关闭深度,开启深度之类的\n" + "            Pass ScalePass{\n" + "                // 这个pass剔除前面\n" + "                FaceCull Front;\n" + "            }\n" + "            Pass ColorPass{\n" + "                // 这个pass剔除背面\n" + "                FaceCull Back;\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_POST_SHADOW_DEF_DATA", "// PostShadowDef\n" + "Def PostShadowDef{\n" + "    Params{\n" + "        // ShadowInfo\n" + "        float shadowIntensity;\n" + "        int filterMode;\n" + "        bool hardwareShadow;\n" + "        bool backfaceShadows;\n" + "        float pcfEdge;\n" + "        vec2 fadeInfo;\n" + "    }\n" + "    SubTechnology PostShadowPass{\n" + "        Vars{\n" + "            vec2 wUv0;\n" + "            mat4 pvInverse;\n" + "            vec4 pvRow2;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "                // glsl是列矩阵,这里我获取第二行(只需要变换得到z即可测试PSSM)\n" + "                pvRow2 = vec4(Context.ProjectViewMatrix[0][2], Context.ProjectViewMatrix[1][2], Context.ProjectViewMatrix[2][2], Context.ProjectViewMatrix[3][2]);\n" + "                wUv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            //#extension GL_ARB_gpu_shader5 : enable\n" + "            float shadowBorderScale = 1.0f;\n" + "            #ifdef HARDWARE_SHADOWS\n" + "                #define SHADOWMAP sampler2DShadow\n" + "                #define SHADOWCOMPAREOFFSET(tex,coord,offset) textureProjOffset(tex, coord, offset)\n" + "                #define SHADOWCOMPARE(tex,coord) textureProj(tex, coord)\n" + "                #define SHADOWGATHER(tex,coord) textureGather(tex, coord.xy, coord.z)\n" + "            #else\n" + "                #define SHADOWMAP sampler2D\n" + "                #define SHADOWCOMPAREOFFSET(tex,coord,offset) step(coord.z, textureProjOffset(tex, coord, offset).r)\n" + "                #define SHADOWCOMPARE(tex,coord) step(coord.z, textureProj(tex, coord).r)\n" + "                #define SHADOWGATHER(tex,coord) step(coord.z, textureGather(tex, coord.xy))\n" + "            #endif\n" + "\n" + "            #define FILTER_MODE 1\n" + "\n" + "            #if FILTER_MODE == 10\n" + "                #define GETSHADOW Shadow_Nearest\n" + "                #define KERNEL 1.0\n" + "            #elif FILTER_MODE == 1\n" + "                #ifdef HARDWARE_SHADOWS\n" + "                    #define GETSHADOW Shadow_Nearest\n" + "                #else\n" + "                    #define GETSHADOW Shadow_DoBilinear_2x2\n" + "                #endif\n" + "                #define KERNEL 1.0\n" + "            #endif\n" + "\n" + "            #if (FILTER_MODE == 2)\n" + "                #define GETSHADOW Shadow_DoDither_2x2\n" + "                #define KERNEL 1.0\n" + "            #elif FILTER_MODE == 3\n" + "                #define GETSHADOW Shadow_DoPCF\n" + "                #define KERNEL 4.0\n" + "            #elif FILTER_MODE == 4\n" + "                #define GETSHADOW Shadow_DoPCFPoisson\n" + "                #define KERNEL 4.0\n" + "            #elif FILTER_MODE == 5\n" + "                #define GETSHADOW Shadow_DoPCF\n" + "                #define KERNEL 8.0\n" + "            #endif\n" + "\n" + "            float Shadow_DoShadowCompare(in SHADOWMAP tex,in vec4 projCoord){\n" + "                return SHADOWCOMPARE(tex, projCoord);\n" + "            }\n" + "\n" + "            float Shadow_BorderCheck(in vec2 coord){\n" + "                // 最快的“hack”方法（使用 4-5 条指令）\n" + "                vec4 t = vec4(coord.xy, 0.0f, 1.0f);\n" + "                t = step(t.wwxy, t.xyzz);\n" + "                return dot(t,t);\n" + "            }\n" + "\n" + "            float Shadow_Nearest(in SHADOWMAP tex,in vec4 projCoord){\n" + "                float border = Shadow_BorderCheck(projCoord.xy);\n" + "                if (border > 0.0f){\n" + "                    return 1.0f;\n" + "                }\n" + "                return SHADOWCOMPARE(tex, projCoord);\n" + "            }\n" + "\n" + "            //----------------------------------ShadowFilter--------------------------------------\n" + "            float Shadow_DoShadowCompareOffset(in SHADOWMAP tex,in vec4 projCoord,in vec2 offset){\n" + "                vec4 coord = vec4(projCoord.xy + offset.xy * Context.SMapSizeInverse * shadowBorderScale, projCoord.zw);\n" + "                return SHADOWCOMPARE(tex, coord);\n" + "            }\n" + "\n" + "\n" + "            float Shadow_DoDither_2x2(in SHADOWMAP tex, in vec4 projCoord){\n" + "                float border = Shadow_BorderCheck(projCoord.xy);\n" + "                if (border > 0.0f)\n" + "                    return 1.0f;\n" + "\n" + "                float shadow = 0.0f;\n" + "                vec2 o = vec2(ivec2(mod(floor(gl_FragCoord.xy), 2.0f))); //Strict type checking in GLSL ES\n" + "                shadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2(-1.5f, 1.5f)+o));\n" + "                shadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2( 0.5f, 1.5f)+o));\n" + "                shadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2(-1.5f, -0.5f)+o));\n" + "                shadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2( 0.5f, -0.5f)+o));\n" + "                shadow *= 0.25f;\n" + "                return shadow;\n" + "            }\n" + "\n" + "            float Shadow_DoBilinear_2x2(in SHADOWMAP tex, in vec4 projCoord){\n" + "                float border = Shadow_BorderCheck(projCoord.xy);\n" + "                if (border > 0.0f){\n" + "                    return 1.0f;\n" + "                }\n" + "\n" + "                vec4 gather = vec4(0.0f);\n" + "                #if defined GL_ARB_gpu_shader5 || defined GL_OES_gpu_shader5\n" + "                    vec4 coord = vec4(projCoord.xyz / projCoord.www, 0.0f);\n" + "                    gather = SHADOWGATHER(tex, coord);\n" + "                #else\n" + "                    gather.x = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(0, 1));\n" + "                    gather.y = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(1, 1));\n" + "                    gather.z = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(1, 0));\n" + "                    gather.w = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(0, 0));\n" + "                #endif\n" + "\n" + "               vec2 f = fract( projCoord.xy * Context.ShadowMapSize );\n" + "               vec2 mx = mix( gather.wx, gather.zy, f.x );\n" + "               return mix( mx.x, mx.y, f.y );\n" + "            }\n" + "\n" + "            float Shadow_DoPCF(in SHADOWMAP tex,in vec4 projCoord){\n" + "\n" + "                float shadow = 0.0f;\n" + "                float border = Shadow_BorderCheck(projCoord.xy);\n" + "                if (border > 0.0f)\n" + "                    return 1.0f;\n" + "\n" + "                float bound = KERNEL * 0.5f - 0.5f;\n" + "                bound *= Params.pcfEdge;\n" + "                for (float y = -bound; y <= bound; y += Params.pcfEdge){\n" + "                    for (float x = -bound; x <= bound; x += Params.pcfEdge){\n" + "                        shadow += Shadow_DoShadowCompareOffset(tex, projCoord, vec2(x,y));\n" + "                    }\n" + "                }\n" + "\n" + "                shadow = shadow / (KERNEL * KERNEL);\n" + "                return shadow;\n" + "            }\n" + "\n" + "            //12 tap poisson disk\n" + "            const vec2 poissonDisk0 =  vec2(-0.1711046f, -0.425016f);\n" + "            const vec2 poissonDisk1 =  vec2(-0.7829809f, 0.2162201f);\n" + "            const vec2 poissonDisk2 =  vec2(-0.2380269f, -0.8835521f);\n" + "            const vec2 poissonDisk3 =  vec2(0.4198045f, 0.1687819f);\n" + "            const vec2 poissonDisk4 =  vec2(-0.684418f, -0.3186957f);\n" + "            const vec2 poissonDisk5 =  vec2(0.6026866f, -0.2587841f);\n" + "            const vec2 poissonDisk6 =  vec2(-0.2412762f, 0.3913516f);\n" + "            const vec2 poissonDisk7 =  vec2(0.4720655f, -0.7664126f);\n" + "            const vec2 poissonDisk8 =  vec2(0.9571564f, 0.2680693f);\n" + "            const vec2 poissonDisk9 =  vec2(-0.5238616f, 0.802707f);\n" + "            const vec2 poissonDisk10 = vec2(0.5653144f, 0.60262f);\n" + "            const vec2 poissonDisk11 = vec2(0.0123658f, 0.8627419f);\n" + "\n" + "\n" + "            float Shadow_DoPCFPoisson(in SHADOWMAP tex, in vec4 projCoord){\n" + "                float shadow = 0.0f;\n" + "                float border = Shadow_BorderCheck(projCoord.xy);\n" + "                if (border > 0.0f){\n" + "                    return 1.0f;\n" + "                }\n" + "\n" + "                vec2 texelSize = Context.SMapSizeInverse * 4.0f * Params.pcfEdge * shadowBorderScale;\n" + "\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk0 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk1 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk2 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk3 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk4 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk5 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk6 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk7 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk8 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk9 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk10 * texelSize, projCoord.zw));\n" + "                shadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk11 * texelSize, projCoord.zw));\n" + "\n" + "                // 除以 12\n" + "                return shadow * 0.08333333333f;\n" + "            }\n" + "            //----------------------------------ShadowFilter--------------------------------------\n" + "\n" + "\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0f)) - vec2(1.0f);\n" + "                pos.z  = depth * 2.0f - 1.0f;\n" + "                pos.w  = 1.0f;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            #ifdef Context.Pssm\n" + "                // 基于PSSM实现的DirectionalLightShadows\n" + "                float getDirectionalLightShadows(in vec4 splits,in float shadowPosition, in SHADOWMAP shadowMap0, in SHADOWMAP shadowMap1, in SHADOWMAP shadowMap2,in SHADOWMAP shadowMap3, in vec4 projCoord0,in vec4 projCoord1,in vec4 projCoord2,in vec4 projCoord3){\n" + "                    float shadow = 1.0f;\n" + "                    if(shadowPosition < splits.x){\n" + "                        shadow = GETSHADOW(shadowMap0, projCoord0 );\n" + "                    }\n" + "                    else if( shadowPosition <  splits.y){\n" + "                        shadowBorderScale = 0.5f;\n" + "                        shadow = GETSHADOW(shadowMap1, projCoord1);\n" + "                    }\n" + "                    else if( shadowPosition <  splits.z){\n" + "                        shadowBorderScale = 0.25f;\n" + "                        shadow = GETSHADOW(shadowMap2, projCoord2);\n" + "                    }\n" + "                    else if( shadowPosition <  splits.w){\n" + "                        shadowBorderScale = 0.125f;\n" + "                        shadow = GETSHADOW(shadowMap3, projCoord3);\n" + "                    }\n" + "                    return shadow;\n" + "                }\n" + "            #endif\n" + "            #ifdef Context.PointLightShadows\n" + "                float getPointLightShadows(in vec4 worldPos,in vec3 lightPos, in SHADOWMAP shadowMap0, in SHADOWMAP shadowMap1, in SHADOWMAP shadowMap2, in SHADOWMAP shadowMap3, in SHADOWMAP shadowMap4, in SHADOWMAP shadowMap5, in vec4 projCoord0,in vec4 projCoord1,in vec4 projCoord2,in vec4 projCoord3,in vec4 projCoord4,in vec4 projCoord5){\n" + "                    float shadow = 1.0f;\n" + "                    vec3 vect = worldPos.xyz - lightPos;\n" + "                    vec3 absv = abs(vect);\n" + "                    float maxComp = max(absv.x,max(absv.y,absv.z));\n" + "                    if(maxComp == absv.y){\n" + "                       if(vect.y < 0.0f){\n" + "                           shadow = GETSHADOW(shadowMap0, projCoord0 / projCoord0.w);\n" + "                       }\n" + "                       else{\n" + "                           shadow = GETSHADOW(shadowMap1, projCoord1 / projCoord1.w);\n" + "                       }\n" + "                    }\n" + "                    else if(maxComp == absv.z){\n" + "                       if(vect.z < 0.0f){\n" + "                           shadow = GETSHADOW(shadowMap2, projCoord2 / projCoord2.w);\n" + "                       }\n" + "                       else{\n" + "                           shadow = GETSHADOW(shadowMap3, projCoord3 / projCoord3.w);\n" + "                       }\n" + "                    }\n" + "                    else if(maxComp == absv.x){\n" + "                       if(vect.x < 0.0f){\n" + "                           shadow = GETSHADOW(shadowMap4, projCoord4 / projCoord4.w);\n" + "                       }\n" + "                       else{\n" + "                           shadow = GETSHADOW(shadowMap5, projCoord5 / projCoord5.w);\n" + "                       }\n" + "                    }\n" + "                    return shadow;\n" + "                }\n" + "            #endif\n" + "            #ifdef Context.SpotLightShadows\n" + "                float getSpotLightShadows(in SHADOWMAP shadowMap, in  vec4 projCoord){\n" + "                    float shadow = 1.0f;\n" + "                    projCoord /= projCoord.w;\n" + "                    shadow = GETSHADOW(shadowMap, projCoord);\n" + "\n" + "                    // 一个小的衰减，使阴影很好地融入暗部，将纹理坐标值转换为 -1,1 范围，因此纹理坐标向量的长度实际上是地面上变亮区域的半径\n" + "                    projCoord = projCoord * 2.0f - 1.0f;\n" + "                    float fallOff = ( length(projCoord.xy) - 0.9f ) / 0.1f;\n" + "                    return mix(shadow, 1.0f, clamp(fallOff, 0.0f, 1.0f));\n" + "                }\n" + "            #endif\n" + "            vec3 approximateNormal(in vec4 worldPos,in vec2 texCoord, in sampler2D depthMap, in vec2 resolutionInverse){\n" + "                float step = resolutionInverse.x;\n" + "                float stepy = resolutionInverse.y;\n" + "                float depth2 = texture(depthMap, texCoord + vec2(step, -stepy)).r;\n" + "                float depth3 = texture(depthMap, texCoord + vec2(-step, -stepy)).r;\n" + "                vec4 worldPos2 = vec4(getPosition(depth2, texCoord + vec2(step, -stepy)),1.0f);\n" + "                vec4 worldPos3 = vec4(getPosition(depth3, texCoord + vec2(-step, -stepy)),1.0f);\n" + "\n" + "                vec3 v1 = (worldPos - worldPos2).xyz;\n" + "                vec3 v2 = (worldPos3 - worldPos2).xyz;\n" + "                return normalize(cross(v1, v2));\n" + "            }\n" + "            const mat4 biasMat = mat4(0.5f, 0.0f, 0.0f, 0.0f,\n" + "                                      0.0f, 0.5f, 0.0f, 0.0f,\n" + "                                      0.0f, 0.0f, 0.5f, 0.0f,\n" + "                                      0.5f, 0.5f, 0.5f, 1.0f);\n" + "            void main(){\n" + "                float depth = texture(Context.InDepth, wUv0).r;\n" + "                Context.OutColor = texture(Context.InScreen, wUv0);\n" + "\n" + "                // 跳过不需要的部分,depth为1.0的基本上是背景或sky部分\n" + "                if(depth >= 1.0f){\n" + "                    return;\n" + "                }\n" + "\n" + "                // 深度重建世界坐标\n" + "                vec4 wPosition = vec4(getPosition(depth, wUv0), 1.0f);\n" + "\n" + "                vec3 lightDir;\n" + "                #ifdef Context.Pssm\n" + "                    lightDir = Context.LightDir;\n" + "                #else\n" + "                    lightDir = wPosition.xyz - Context.LightPos;\n" + "                #endif\n" + "\n" + "                #ifdef Params.backfaceShadows\n" + "                    // 丢弃背面时,由于在forward pipeline下无法获取该点法线,所以只能通过近似算法获取法线\n" + "                    // 该近似算法依赖于深度信息,所以很容易造成Shadow Acne\n" + "                    if(!Params.backfaceShadows){\n" + "                        vec3 normal = approximateNormal(wPosition, wUv0, Context.InDepth, Context.ResolutionInverse);\n" + "                        float ndotl = dot(normal, lightDir);\n" + "                        if(ndotl > 0.0f){\n" + "                            return;\n" + "                        }\n" + "                    }\n" + "                #endif\n" + "\n" + "                #if !defined(Context.PointLightShadows)\n" + "                    #if !defined(Context.Pssm)\n" + "                        if( dot(Context.LightDir, lightDir) < 0.0f){\n" + "                            return;\n" + "                        }\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                // 将坐标转换到光源空间\n" + "                vec4 projCoord0 = biasMat * Context.LightViewProjectMatrix0 * wPosition;\n" + "                vec4 projCoord1 = biasMat * Context.LightViewProjectMatrix1 * wPosition;\n" + "                vec4 projCoord2 = biasMat * Context.LightViewProjectMatrix2 * wPosition;\n" + "                vec4 projCoord3 = biasMat * Context.LightViewProjectMatrix3 * wPosition;\n" + "                #ifdef Context.PointLightShadows\n" + "                   vec4 projCoord4 = biasMat * Context.LightViewProjectMatrix4 * wPosition;\n" + "                   vec4 projCoord5 = biasMat * Context.LightViewProjectMatrix5 * wPosition;\n" + "                #endif\n" + "\n" + "                // 计算阴影\n" + "                float shadow = 1.0f;\n" + "\n" + "                #if defined(Context.Pssm)\n" + "                    float shadowPosition = pvRow2.x * wPosition.x +  pvRow2.y * wPosition.y +  pvRow2.z * wPosition.z +  pvRow2.w;\n" + "                #else\n" + "                    #if defined(Params.fadeInfo)\n" + "                        float shadowPosition = pvRow2.x * wPosition.x +  pvRow2.y * wPosition.y +  pvRow2.z * wPosition.z +  pvRow2.w;\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Context.PointLightShadows\n" + "                    // pointLight shadow\n" + "                    shadow = getPointLightShadows(wPosition, Context.LightPos, Context.InShadowMap0, Context.InShadowMap1, Context.InShadowMap2, Context.InShadowMap3, Context.InShadowMap4, Context.InShadowMap5, projCoord0, projCoord1, projCoord2, projCoord3, projCoord4, projCoord5);\n" + "                #else\n" + "                    #ifdef Context.Pssm\n" + "                        // directionalLight shadow\n" + "                        shadow = getDirectionalLightShadows(Context.Splits, shadowPosition, Context.InShadowMap0, Context.InShadowMap1, Context.InShadowMap2, Context.InShadowMap3, projCoord0, projCoord1, projCoord2, projCoord3);\n" + "                    #else\n" + "                        #ifdef Context.SpotLightShadows\n" + "                            // spotLight shadow\n" + "                            shadow = getSpotLightShadows(Context.InShadowMap0, projCoord0);\n" + "                        #endif\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.fadeInfo\n" + "                    shadow = clamp(max(0.0f, mix(shadow, 1.0f,(shadowPosition - Params.fadeInfo.x) * Params.fadeInfo.y)), 0.0f, 1.0f);\n" + "                #endif\n" + "                #ifdef Params.shadowIntensity\n" + "                    shadow = shadow * Params.shadowIntensity + (1.0f - Params.shadowIntensity);\n" + "                #else\n" + "                    shadow = shadow * 0.7f + 0.3f;\n" + "                #endif\n" + "                Context.OutColor = Context.OutColor * vec4(shadow, shadow, shadow, 1.0f);\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass PostFilter{\n" + "            Pass PostShadowPass{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_PRE_SHADOW_DEF_DATA", "// PreShadowDef\n" + "// 这个材质定义用于捕获ShadowMap,因此,它很简单,只是简单的将深度信息渲染到指定缓冲中\n" + "Def PreShadowDef{\n" + "    Params{\n" + "        bool debug;\n" + "    }\n" + "    SubTechnology PreShadowPass{\n" + "        Vars{\n" + "            vec2 wUv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "                wUv0 = Context.InUv0;\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                #ifdef Params.debug\n" + "                    if(Params.debug){\n" + "                        Context.OutColor = vec4(vec3(gl_FragCoord.z), 1.0f);\n" + "                    }\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass PreFrame{\n" + "            Pass PreShadowPass{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_FOG_FILTER_DEF_DATA", "// 雾化\n" + "Def FogFilterDef{\n" + "    Params{\n" + "        // 雾化距离(默认1000.0f)\n" + "        float fogDistance;\n" + "        // 通常为1.0\n" + "        float fogDensity;\n" + "        // 视锥near\n" + "        float vNear;\n" + "        // 视锥far\n" + "        float vFar;\n" + "        // 雾化near\n" + "        float fogNear;\n" + "        // 雾化far\n" + "        float fogFar;\n" + "        // 雾化颜色\n" + "        vec4 fogColor;\n" + "    }\n" + "    SubTechnology Fog{\n" + "        Vars{\n" + "            vec2 wUv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wUv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            const float LOG2 = 1.442695f;\n" + "            void main(){\n" + "                Context.OutColor = texture(Context.InScreen, wUv0);\n" + "                float depth = texture(Context.InDepth, wUv0).r;\n" + "\n" + "                #ifdef Params.fogDistance\n" + "                    float _fogDistance = Params.fogDistance;\n" + "                #else\n" + "                    float _fogDistance = 1000.0f;\n" + "                #endif\n" + "                #ifdef Params.fogDensity\n" + "                    float _fogDensity = Params.fogDensity;\n" + "                #else\n" + "                    float _fogDensity = 1.0f;\n" + "                #endif\n" + "                #ifdef Params.fogColor\n" + "                    vec4 _fogColor = Params.fogColor;\n" + "                #else\n" + "                    vec4 _fogColor = vec4(1.0f);\n" + "                #endif\n" + "\n" + "                // 可以简单的将视锥范围作为雾化过渡范围，如下：\n" + "                // 此时，越靠近相机，dis越接近0，fog越接近1.0f，最终混合下Context.OutColor越清晰，远离相机时，dis小于0，fog逐渐变小，最终混合下_fogColor逐渐清晰\n" + "                // 但是这种雾化计算dis在一个很小的非线性范围内变化\n" + "                // float dis = (0.5f * depth + 0.5f);\n" + "                // 所以这里变化到线性深度范围(假设near恒定为1.0)\n" + "                float dis = 2.0f / (_fogDistance + 1.0f - depth * (_fogDistance - 1.0f));\n" + "\n" + "                // 一个经典的浓度过渡方程\n" + "                float fog = exp2(-_fogDensity * _fogDensity * dis * dis * LOG2);\n" + "                // 雾化规范到(0.0f,1.0f)\n" + "                fog = clamp(fog, 0.0f, 1.0f);\n" + "\n" + "                // 混合结果\n" + "                Context.OutColor = mix(_fogColor, Context.OutColor, fog);\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology LinearFog{\n" + "        Vars{\n" + "            vec2 wUv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wUv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            const float LOG2 = 1.442695f;\n" + "            void main(){\n" + "                Context.OutColor = texture(Context.InScreen, wUv0);\n" + "                float depth = texture(Context.InDepth, wUv0).r;\n" + "\n" + "                #ifdef Params.vNear\n" + "                    float _vNear = Params.vNear;\n" + "                #else\n" + "                    float _vNear = 0.1f;\n" + "                #endif\n" + "                #ifdef Params.vFar\n" + "                    float _vFar = Params.vFar;\n" + "                #else\n" + "                    float _vFar = 1000.0f;\n" + "                #endif\n" + "                #ifdef Params.fogNear\n" + "                    float _fogNear = Params.fogNear;\n" + "                #else\n" + "                    float _fogNear = 1.0f;\n" + "                #endif\n" + "                #ifdef Params.fogFar\n" + "                    float _fogFar = Params.fogFar;\n" + "                #else\n" + "                    float _fogFar = 1000.0f;\n" + "                #endif\n" + "                #ifdef Params.fogColor\n" + "                    vec4 _fogColor = Params.fogColor;\n" + "                #else\n" + "                    vec4 _fogColor = vec4(1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                // 线性雾化相对来说比较简单,仅考虑指定near,far内的过渡\n" + "                float dis = (2.0f * _vNear) / (_vFar + _vNear - depth * (_vFar - _vNear));\n" + "\n" + "                // 雾化规范到(0.0f,1.0f)\n" + "                float fog = smoothstep(_fogNear, _fogFar, dis * (_vFar - _vNear));\n" + "\n" + "                // 混合结果\n" + "                Context.OutColor = mix(Context.OutColor, _fogColor, fog);\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass PostFilter{\n" + "            Pass Fog{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology LinearFog{\n" + "\n" + "        Sub_Pass PostFilter{\n" + "            Pass LinearFog{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_PICTURE_DEF_DATA", "// 颜色材质,提供指定颜色或颜色纹理并渲染\n" + "Def PictureDef{\n" + "    Params{\n" + "        vec4 color;\n" + "        sampler2D colorMap;\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology DefaultPass{\n" + "        Vars{\n" + "            vec2 uv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                uv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                // 使用自定义颜色输出\n" + "                #ifdef Params.color\n" + "                    Context.OutColor = Params.color;\n" + "                #else\n" + "                    // 使用纹理\n" + "                    #ifdef Params.colorMap\n" + "                        Context.OutColor = texture(Params.colorMap, uv0);\n" + "                        #ifdef Params.alphaDiscard\n" + "                            if(Context.OutColor.a < Params.alphaDiscard){\n" + "                                discard;\n" + "                            }\n" + "                        #endif\n" + "                    #else\n" + "                        Context.OutColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n" + "                    #endif\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass DefaultPass{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_GAMMA_CORRECTION_DEF_DATA", "// gamma矫正\n" + "// 由于webGL不支持硬件gamma矫正,只能通过后处理进行\n" + "Def GammaCorrectionFilterDef{\n" + "    Params{\n" + "        float gammaFactor;\n" + "        bool toneMapping;\n" + "    }\n" + "    SubTechnology GammaCorrectionFilter{\n" + "        Vars{\n" + "            vec2 uv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                uv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                Context.OutColor = texture(Context.InScreen, uv0);\n" + "                #ifdef Params.toneMapping\n" + "                    if(Params.toneMapping){\n" + "                        Context.OutColor.rgb = Context.OutColor.rgb / (Context.OutColor.rgb + vec3(1.0f));\n" + "                    }\n" + "                #endif\n" + "                #ifdef Params.gammaFactor\n" + "                    Context.OutColor.rgb = pow(Context.OutColor.rgb, vec3(Params.gammaFactor));\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass PostFilter{\n" + "            Pass GammaCorrectionFilter{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_DEFAULT_OUT_COLOR_DEF_DATA", "// 输出颜色缓冲材质\n" + "Def DefaultOutColorDef{\n" + "    Params{\n" + "        float gammaFactor;\n" + "        bool toneMapping;\n" + "    }\n" + "    SubTechnology DefaultOutColor{\n" + "        Vars{\n" + "            vec2 uv0;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                uv0 = Context.InUv0;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                Context.OutColor = texture(Context.InForwardColorMap, uv0);\n" + "                #ifdef Params.toneMapping\n" + "                    if(Params.toneMapping){\n" + "                        Context.OutColor.rgb = Context.OutColor.rgb / (Context.OutColor.rgb + vec3(1.0f));\n" + "                    }\n" + "                #endif\n" + "                #ifdef Params.gammaFactor\n" + "                    Context.OutColor.rgb = pow(Context.OutColor.rgb, vec3(Params.gammaFactor));\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass DefaultOutColor{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_DEFAULT_SKY_BOX_DEF", "// 天空盒材质定义\n" + "Def SkyBoxDef{\n" + "    Params{\n" + "        // 启用cubeMap通道\n" + "        bool useCubeMap;\n" + "        // 启用envMap通道\n" + "        bool useEnvMap;\n" + "        // 启用高动态映射\n" + "        bool useHDR;\n" + "        samplerCube cubeMap;\n" + "        sampler2D envMap;\n" + "    }\n" + "    SubTechnology SkyBox{\n" + "        Vars{\n" + "            vec3 wPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                wPosition = Context.InPosition;\n" + "                // 只需要旋转部分\n" + "                vec4 pos = Context.ViewMatrix * vec4(Context.InPosition, 0.0f);\n" + "                // 应用投影变换\n" + "                pos.w = 1.0f;\n" + "                pos = Context.ProjectMatrix * pos;\n" + "                Context.OutPosition = pos.xyww;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec2 Optics_SphereCoord(in vec3 dir){\n" + "                float dzplus1 = dir.z + 1.0f;\n" + "\n" + "                // 计算 1/2p\n" + "                // NOTE: 仅当dir归一化时，此简化才有效。\n" + "                float inv_two_p = 1.414f * sqrt(dzplus1);\n" + "                //float inv_two_p = sqrt(dir.x * dir.x + dir.y * dir.y + dzplus1 * dzplus1);\n" + "                inv_two_p *= 2.0f;\n" + "                inv_two_p = 1.0f / inv_two_p;\n" + "\n" + "                // 计算texcoord\n" + "                return (dir.xy * vec2(inv_two_p)) + vec2(0.5f);\n" + "            }\n" + "            const vec2 invAtan = vec2(0.159154943091895f, 0.318309886183790f);\n" + "            #define PI 3.14159265358979323846264\n" + "            // 转换环境纹理映射纹理坐标\n" + "            vec2 fractTexcoord(const in vec3 v)\n" + "            {\n" + "                vec2 uv = vec2(atan(v.z, v.x) + PI, acos(v.y));\n" + "                uv *= invAtan;\n" + "                return uv;\n" + "            }\n" + "            void main(){\n" + "                #ifdef Params.useCubeMap\n" + "                    // 立方体纹理\n" + "                    Context.OutColor = texture( Params.cubeMap, normalize( wPosition ) );\n" + "                #else\n" + "                    #ifdef Params.useEnvMap\n" + "                        // 环境纹理\n" + "                        vec2 uv = fractTexcoord( normalize( wPosition ) );\n" + "                        #ifdef Params.useHDR\n" + "                            // 解码hdr数据,也可以使用硬件RGB9_E5\n" + "                            vec4 rgbe = texture( Params.envMap, uv );\n" + "                            //rgbe.rgb *= pow(2.0f,rgbe.a*255.0f-128.0f);\n" + "                            // 色调映射(后续在后处理统一进行)\n" + "                            //rgbe.rgb = rgbe.rgb / (rgbe.rgb + vec3(1.0f));\n" + "                            // 伽马(后续在后处理统一进行)\n" + "                            //rgbe.rgb = pow(rgbe.rgb, vec3(1.0f / 2.2f));\n" + "                            Context.OutColor.rgb = rgbe.rgb;\n" + "                            Context.OutColor.a = 1.0f;\n" + "                        #else\n" + "                            Context.OutColor = texture( Params.envMap, uv );\n" + "                        #endif\n" + "                    #endif\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass SkyBox{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_PREFILTER_DEF", "// 预过滤EnvMap\n" + "Def PrefilterDef{\n" + "    Params{\n" + "        float roughness;\n" + "        float resolution;\n" + "        samplerCube envMap;\n" + "    }\n" + "    SubTechnology Prefilter{\n" + "        Vars{\n" + "            vec3 wPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                wPosition = Context.InPosition;\n" + "                // 只需要旋转部分\n" + "                vec4 pos = Context.ViewMatrix * vec4(Context.InPosition, 0.0f);\n" + "                // 应用投影变换\n" + "                pos.w = 1.0f;\n" + "                pos = Context.ProjectMatrix * pos;\n" + "                Context.OutPosition = pos.xyww;\n" + "            }\n" + "        }\n" + "\n" + "        Fs_Shader{\n" + "            const float PI = 3.14159265359f;\n" + "            // ----------------------------------------------------------------------------\n" + "            float DistributionGGX(vec3 N, vec3 H, float roughness)\n" + "            {\n" + "                float a = roughness*roughness;\n" + "                float a2 = a*a;\n" + "                float NdotH = max(dot(N, H), 0.0f);\n" + "                float NdotH2 = NdotH*NdotH;\n" + "\n" + "                float nom   = a2;\n" + "                float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);\n" + "                denom = PI * denom * denom;\n" + "\n" + "                return nom / denom;\n" + "            }\n" + "            // ----------------------------------------------------------------------------\n" + "            // http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n" + "            // 高效的VanDerCorpus计算。\n" + "            float RadicalInverse_VdC(uint bits)\n" + "            {\n" + "                 bits = (bits << 16u) | (bits >> 16u);\n" + "                 bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n" + "                 bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n" + "                 bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n" + "                 bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n" + "                 return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n" + "            }\n" + "            // ----------------------------------------------------------------------------\n" + "            vec2 Hammersley(uint i, uint N)\n" + "            {\n" + "                return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n" + "            }\n" + "            // ----------------------------------------------------------------------------\n" + "            vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n" + "            {\n" + "                float a = roughness*roughness;\n" + "\n" + "                float phi = 2.0f * PI * Xi.x;\n" + "                float cosTheta = sqrt((1.0 - Xi.y) / (1.0f + (a*a - 1.0f) * Xi.y));\n" + "                float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n" + "\n" + "                // 从球坐标到笛卡尔坐标-半角向量\n" + "                vec3 H;\n" + "                H.x = cos(phi) * sinTheta;\n" + "                H.y = sin(phi) * sinTheta;\n" + "                H.z = cosTheta;\n" + "\n" + "                // 从切线空间H向量到世界空间样本向量\n" + "                vec3 up          = abs(N.z) < 0.999 ? vec3(0.0f, 0.0f, 1.0f) : vec3(1.0f, 0.0f, 0.0f);\n" + "                vec3 tangent   = normalize(cross(up, N));\n" + "                vec3 bitangent = cross(N, tangent);\n" + "\n" + "                vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n" + "                return normalize(sampleVec);\n" + "            }\n" + "            void main(){\n" + "                vec3 N = normalize(wPosition);\n" + "\n" + "                // 做出简化的假设，即V等于R等于法线\n" + "                vec3 R = N;\n" + "                vec3 V = R;\n" + "\n" + "                const uint SAMPLE_COUNT = 1024u;\n" + "                vec3 prefilteredColor = vec3(0.0f);\n" + "                float totalWeight = 0.0f;\n" + "\n" + "                for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n" + "                {\n" + "                    // 生成偏向首选对齐方向的采样矢量（重要性采样）。\n" + "                    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n" + "                    vec3 H = ImportanceSampleGGX(Xi, N, Params.roughness);\n" + "                    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n" + "\n" + "                    float NdotL = max(dot(N, L), 0.0f);\n" + "                    if(NdotL > 0.0)\n" + "                    {\n" + "                        // 基于粗糙度/ pdf从环境的mip级别采样\n" + "                        float D   = DistributionGGX(N, H, Params.roughness);\n" + "                        float NdotH = max(dot(N, H), 0.0f);\n" + "                        float HdotV = max(dot(H, V), 0.0f);\n" + "                        float pdf = D * NdotH / (4.0f * HdotV) + 0.0001f;\n" + "\n" + "                        float saTexel  = 4.0f * PI / (6.0f * Params.resolution * Params.resolution);\n" + "                        float saSample = 1.0f / (float(SAMPLE_COUNT) * pdf + 0.0001f);\n" + "\n" + "                        float mipLevel = Params.roughness == 0.0f ? 0.0f : 0.5f * log2(saSample / saTexel);\n" + "\n" + "                        prefilteredColor += textureLod(Params.envMap, L, mipLevel).rgb * NdotL;\n" + "                        totalWeight      += NdotL;\n" + "                    }\n" + "                }\n" + "\n" + "                prefilteredColor = prefilteredColor / totalWeight;\n" + "\n" + "                Context.OutColor = vec4(prefilteredColor, 1.0f);\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass Prefilter{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_ENV_CAPTURE_OUT_DEF", "// 将环境捕捉数据渲染并查看\n" + "// 同时,也支持将IBL作为SkyEnv进行场景环境渲染\n" + "Def EnvCaptureOutDef{\n" + "    Params{\n" + "        samplerCube envCaptureMap;\n" + "        float lod;\n" + "    }\n" + "    SubTechnology EnvCaptureOut{\n" + "        Vars{\n" + "            vec3 wPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                wPosition = Context.InPosition;\n" + "                Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                #ifdef Params.envCaptureMap\n" + "                    #ifdef Params.lod\n" + "                        Context.OutColor = textureLod(Params.envCaptureMap, normalize(wPosition), Params.lod);\n" + "                    #else\n" + "                        Context.OutColor = texture(Params.envCaptureMap, normalize(wPosition));\n" + "                    #endif\n" + "                #else\n" + "                    Context.OutColor = vec4(1.0f);\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology EnvSkyOut{\n" + "        Vars{\n" + "            vec3 wPosition;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                wPosition = Context.InPosition;\n" + "                // 只需要旋转部分\n" + "                vec4 pos = Context.ViewMatrix * vec4(Context.InPosition, 0.0f);\n" + "                // 应用投影变换\n" + "                pos.w = 1.0f;\n" + "                pos = Context.ProjectMatrix * pos;\n" + "                Context.OutPosition = pos.xyww;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                #ifdef Params.envCaptureMap\n" + "                    #ifdef Params.lod\n" + "                        Context.OutColor = textureLod(Params.envCaptureMap, normalize(wPosition), Params.lod);\n" + "                    #else\n" + "                        Context.OutColor = texture(Params.envCaptureMap, normalize(wPosition));\n" + "                    #endif\n" + "                #else\n" + "                    Context.OutColor = vec4(1.0f);\n" + "                #endif\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass EnvCaptureOut{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology EnvSky{\n" + "        Sub_Pass{\n" + "            Pass EnvSkyOut{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_BASIC_LIGHTING_DEF_DATA", "// 基础光照材质定义\n" + "Def BasicLightingDef{\n" + "    Params{\n" + "        sampler2D diffuseMap;\n" + "        sampler2D normalMap;\n" + "        sampler2D specularMap;\n" + "        sampler2D normalMap;\n" + "        vec4 ambientColor;\n" + "        vec4 diffuseColor;\n" + "        vec4 specularColor;\n" + "        float shininess;\n" + "        // 完全透明剔除因子(0-1),低于该值的透明片段被完全剔除而不进行混合\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology MultiPassBlinnPhongLighting{\n" + "        Vars{\n" + "            vec3 wNormal;\n" + "            vec4 wTangent;\n" + "            vec3 wPosition;\n" + "            vec2 wUv0;\n" + "            // 三种成分用于调和光照,可来自材质颜色的定义,也可以来自vertex_light\n" + "            vec3 ambientSumAdjust;\n" + "            vec4 diffuseSumAdjust;\n" + "            vec3 specularSumAdjust;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram MultiPassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;\n" + "                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));\n" + "                vec3 norm = normalize(nMat * Context.InNormal);\n" + "                wTangent = vec4(normalize(nMat * Context.InTangent.xyz), Context.InTangent.w);\n" + "                //t = normalize(t - dot(t, norm) * norm);\n" + "                //vec3 b = cross(norm, t);\n" + "                //tbnMat = mat3(t, b, norm);\n" + "                wNormal = norm;\n" + "                wUv0 = Context.InUv0;\n" + "\n" + "\n" + "                // 如果是顶点光照,则在这里将光源变化到切线空间\n" + "                ambientSumAdjust = Params.ambientColor.rgb * Context.AmbientLightColor;\n" + "                diffuseSumAdjust = vec4(1.0f);\n" + "                specularSumAdjust = vec3(1.0f);\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                vec4 _diffuseColor = vec4(1.0f);\n" + "                vec4 _specularColor = vec4(1.0f);\n" + "\n" + "                #ifdef Params.diffuseColor\n" + "                    _diffuseColor = Params.diffuseColor;\n" + "                #endif\n" + "                #ifdef Params.diffuseMap\n" + "                    _diffuseColor = _diffuseColor * texture(Params.diffuseMap, wUv0);\n" + "                    #ifdef Params.alphaDiscard\n" + "                        // discard性能比较差,建议还是使用半透明渲染比较合适s\n" + "                        if(_diffuseColor.a < Params.alphaDiscard){\n" + "                            discard;\n" + "                        }\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.specularColor\n" + "                    _specularColor = Params.specularColor;\n" + "                #endif\n" + "                #ifdef Params.specularMap\n" + "                    _specularColor = _specularColor * texture(Params.specularMap, wUv0);\n" + "                #endif\n" + "\n" + "                vec3 normal = normalize( wNormal );\n" + "                #ifdef Params.normalMap\n" + "                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;\n" + "                    vec3 tangent = normalize(wTangent.xyz);\n" + "                    mat3 tbnMat = mat3(tangent, wTangent.w * cross(normal, tangent), normal);\n" + "                    normal = normalize(tbnMat * ( normalHeight * 2.0f - 1.0f ));\n" + "                #endif\n" + "\n" + "                float _shininess = 32.0;\n" + "                #ifdef Params.shininess\n" + "                    _shininess = Params.shininess;\n" + "                #endif\n" + "\n" + "\n" + "                Context.OutColor.rgb = _diffuseColor.rgb * ambientSumAdjust;\n" + "\n" + "\n" + "                // 不必担心这个分支，不会影响性能\n" + "                if(Context.MultiId == 0){\n" + "                    for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                        // 后期改为Context.GetLightDir(Context.LightData[i]);\n" + "                        lightColor = Context.WLightData[i];\n" + "                        lightData1 = Context.WLightData[i + 1];\n" + "                        ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                        //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                        // BlinnPhongLighting\n" + "                        //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                        // 标准PhongLighting\n" + "                        //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                        // 计算SpotLight的衰减\n" + "                        float spotFallOff = 1.0;\n" + "                        if( lightColor.w > 1.0f )\n" + "                        {\n" + "                            // 计算SpotLight的范围衰减\n" + "                            spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                        }\n" + "\n" + "                        // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                        // 计算反射率\n" + "                        ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                        // 最终光照值\n" + "                        //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb * diffuseSumAdjust.rgb + vec3(lightBRDF.y) * _specularColor.rgb * specularSumAdjust.rgb);\n" + "                        Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * diffuseSumAdjust.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * specularSumAdjust.rgb * vec3( lightBRDF.y ));\n" + "                        //Context.OutColor.rgb = vec3(spotFallOff);\n" + "                    }\n" + "                }\n" + "                else{\n" + "                    // point和spot\n" + "                    vec4 lightColor = Context.WLight_Data_0;\n" + "                    vec4 lightData1 = Context.WLight_Data_1;\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                    //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                    // BlinnPhongLighting\n" + "                    //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                    // 标准PhongLighting\n" + "                    //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                    // 计算SpotLight的衰减\n" + "                    float spotFallOff = 1.0;\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLight_Data_2, lightDir.xyz );\n" + "                    }\n" + "\n" + "                    // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                    // 计算反射率\n" + "                    ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                    // 最终光照值\n" + "                    //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb * diffuseSumAdjust.rgb + vec3(lightBRDF.y) * _specularColor.rgb * specularSumAdjust.rgb);\n" + "                    Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * diffuseSumAdjust.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * specularSumAdjust.rgb * vec3( lightBRDF.y ));\n" + "                }\n" + "                Context.OutColor.a = diffuseSumAdjust.a * _diffuseColor.a;\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    SubTechnology SingleBlinnPhongLighting{\n" + "        Vars{\n" + "            vec3 wNormal;\n" + "            vec4 wTangent;\n" + "            vec3 wPosition;\n" + "            vec2 wUv0;\n" + "            // 三种成分用于调和光照,可来自材质颜色的定义,也可以来自vertex_light\n" + "            vec3 ambientSumAdjust;\n" + "            vec4 diffuseSumAdjust;\n" + "            vec3 specularSumAdjust;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram SinglePassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;\n" + "                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));\n" + "                vec3 norm = normalize(nMat * Context.InNormal);\n" + "                wTangent = vec4(normalize(nMat * Context.InTangent.xyz), Context.InTangent.w);\n" + "                //t = normalize(t - dot(t, norm) * norm);\n" + "                //vec3 b = cross(norm, t);\n" + "                //tbnMat = mat3(t, b, norm);\n" + "                wNormal = norm;\n" + "                wUv0 = Context.InUv0;\n" + "\n" + "\n" + "                // 如果是顶点光照,则在这里将光源变化到切线空间\n" + "                ambientSumAdjust = Params.ambientColor.rgb * Context.AmbientLightColor;\n" + "                diffuseSumAdjust = vec4(1.0f);\n" + "                specularSumAdjust = vec3(1.0f);\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "                float falloff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f);\n" + "                //if(curAngleCos > innerMinusOuter)\n" + "                //    falloff = 1.0f;\n" + "                //else\n" + "                //    falloff = 0.0f;\n" + "\n" + "                #ifdef SRGB\n" + "                    // Use quadratic falloff (notice the ^4)\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0), 4.0);\n" + "                #else\n" + "                    // Use linear falloff\n" + "                    return falloff;\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                vec4 _diffuseColor = vec4(1.0f);\n" + "                vec4 _specularColor = vec4(1.0f);\n" + "\n" + "                #ifdef Params.diffuseColor\n" + "                    _diffuseColor = Params.diffuseColor;\n" + "                #endif\n" + "                #ifdef Params.diffuseMap\n" + "                    _diffuseColor = _diffuseColor * texture(Params.diffuseMap, wUv0);\n" + "                    #ifdef Params.alphaDiscard\n" + "                        // discard性能比较差,建议还是使用半透明渲染比较合适s\n" + "                        if(_diffuseColor.a < Params.alphaDiscard){\n" + "                            discard;\n" + "                        }\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.specularColor\n" + "                    _specularColor = Params.specularColor;\n" + "                #endif\n" + "                #ifdef Params.specularMap\n" + "                    _specularColor = _specularColor * texture(Params.specularMap, wUv0);\n" + "                #endif\n" + "\n" + "                vec3 normal = normalize( wNormal );\n" + "                #ifdef Params.normalMap\n" + "                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;\n" + "                    vec3 tangent = normalize(wTangent.xyz);\n" + "                    mat3 tbnMat = mat3(tangent, wTangent.w * cross(normal, tangent), normal);\n" + "                    normal = normalize(tbnMat * ( normalHeight * 2.0f - 1.0f ));\n" + "                #endif\n" + "\n" + "                float _shininess = 32.0;\n" + "                #ifdef Params.shininess\n" + "                    _shininess = Params.shininess;\n" + "                #endif\n" + "\n" + "\n" + "                Context.OutColor.rgb = _diffuseColor.rgb * ambientSumAdjust;\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    // 后期改为Context.GetLightDir(Context.LightData[i]);\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                    //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                    // BlinnPhongLighting\n" + "                    //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                    // 标准PhongLighting\n" + "                    //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                    // 计算SpotLight的衰减\n" + "                    float spotFallOff = 1.0;\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                    // 计算反射率\n" + "                    ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                    // 最终光照值\n" + "                    //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb * diffuseSumAdjust.rgb + vec3(lightBRDF.y) * _specularColor.rgb * specularSumAdjust.rgb);\n" + "                    Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * diffuseSumAdjust.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * specularSumAdjust.rgb * vec3( lightBRDF.y ));\n" + "                    //Context.OutColor.rgb = vec3(spotFallOff);\n" + "                }\n" + "                Context.OutColor.a = diffuseSumAdjust.a * _diffuseColor.a;\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    SubTechnology ColorSubTechnology{\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = Context.ProjectViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "                Context.OutColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n" + "            }\n" + "        }\n" + "    }\n" + "    // 默认为SinglePass\n" + "    Technology {\n" + "        Sub_Pass Forward{\n" + "            Pass SingleBlinnPhongLighting{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology MultiPass{\n" + "        Sub_Pass Forward{\n" + "            Pass MultiPassBlinnPhongLighting{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology Color{\n" + "        Sub_Pass Forward{\n" + "            Pass ColorSubTechnology{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_DEFERRED_LIGHTING_DEF_DATA", "// 默认的延迟光照材质定义\n" + "Def DeferredLightingDef{\n" + "    Params{\n" + "        sampler2D diffuseMap;\n" + "        sampler2D normalMap;\n" + "        sampler2D specularMap;\n" + "        sampler2D normalMap;\n" + "        vec4 ambientColor;\n" + "        vec4 diffuseColor;\n" + "        vec4 specularColor;\n" + "        float shininess;\n" + "        // 完全透明剔除因子(0-1),低于该值的透明片段被完全剔除而不进行混合\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology GBufferPass{\n" + "        Vars{\n" + "            vec3 wNormal;\n" + "            vec4 wTangent;\n" + "            vec3 wPosition;\n" + "            vec2 wUv0;\n" + "            // 三种成分用于调和光照,可来自材质颜色的定义,也可以来自vertex_light\n" + "            vec3 ambientSumAdjust;\n" + "            vec4 diffuseSumAdjust;\n" + "            vec3 specularSumAdjust;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;\n" + "                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));\n" + "                vec3 norm = normalize(nMat * Context.InNormal);\n" + "                wTangent = vec4(normalize(nMat * Context.InTangent.xyz), Context.InTangent.w);\n" + "                //t = normalize(t - dot(t, norm) * norm);\n" + "                //vec3 b = cross(norm, t);\n" + "                //tbnMat = mat3(t, b, norm);\n" + "                wNormal = norm;\n" + "                wUv0 = Context.InUv0;\n" + "\n" + "\n" + "                // 如果是顶点光照,则在这里将光源变化到切线空间\n" + "                ambientSumAdjust = Params.ambientColor.rgb;\n" + "                diffuseSumAdjust = vec4(1.0f);\n" + "                specularSumAdjust = vec3(1.0f);\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            void main(){\n" + "\n" + "                vec4 _diffuseColor = vec4(1.0f);\n" + "                vec4 _specularColor = vec4(1.0f);\n" + "\n" + "                #ifdef Params.diffuseColor\n" + "                    _diffuseColor = Params.diffuseColor;\n" + "                #endif\n" + "                #ifdef Params.diffuseMap\n" + "                    _diffuseColor = _diffuseColor * texture(Params.diffuseMap, wUv0);\n" + "                    #ifdef Params.alphaDiscard\n" + "                        // discard性能比较差,建议还是使用半透明渲染比较合适s\n" + "                        if(_diffuseColor.a < Params.alphaDiscard){\n" + "                            discard;\n" + "                        }\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.specularColor\n" + "                    _specularColor = Params.specularColor;\n" + "                #endif\n" + "                #ifdef Params.specularMap\n" + "                    _specularColor = _specularColor * texture(Params.specularMap, wUv0);\n" + "                #endif\n" + "\n" + "                vec3 normal = normalize( wNormal );\n" + "                #ifdef Params.normalMap\n" + "                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;\n" + "                    vec3 tangent = normalize(wTangent.xyz);\n" + "                    mat3 tbnMat = mat3(tangent, wTangent.w * cross(normal, tangent), normal);\n" + "                    normal = normalize(tbnMat * ( normalHeight * 2.0f - 1.0f ));\n" + "                #endif\n" + "\n" + "                float _shininess = 32.0;\n" + "                #ifdef Params.shininess\n" + "                    _shininess = Params.shininess;\n" + "                #endif\n" + "\n" + "\n" + "\n" + "\n" + "                Context.OutGBuffer0.xyz = _diffuseColor.rgb * diffuseSumAdjust.rgb;\n" + "                Context.OutGBuffer0.w   = diffuseSumAdjust.a * _diffuseColor.a * 0.1f + _shininess;\n" + "                Context.OutGBuffer1.xyz = normal.xyz;\n" + "                Context.OutGBuffer2.rgb = _specularColor.rgb * specularSumAdjust.rgb * 10.0f + ambientSumAdjust * 0.1f;\n" + "                Context.OutGBuffer2.a = _shininess;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology DeferredShadingPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram SinglePassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 _diffuseColor = texture(Context.InGBuffer0, uv0);\n" + "                vec4 _specularColorDecode = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _specularColor = floor(_specularColorDecode.rgb) * 0.1f;\n" + "                vec3 _ambientColor = min(fract(_specularColorDecode.rgb) * 10.0f, vec3(1.0f));\n" + "                float _shininess = floor(_diffuseColor.w);\n" + "                float alpha     = min(fract(_diffuseColor.w) * 10.0f, 1.0f);\n" + "                vec3 normal = texture(Context.InGBuffer1, uv0).xyz;\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                Context.OutColor.rgb = _diffuseColor.rgb * Context.AmbientLightColor * _ambientColor;\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    // 后期改为Context.GetLightDir(Context.LightData[i]);\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                    //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                    // BlinnPhongLighting\n" + "                    //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                    // 标准PhongLighting\n" + "                    //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                    // 计算SpotLight的衰减\n" + "                    float spotFallOff = 1.0;\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                    // 计算反射率\n" + "                    ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                    // 最终光照值\n" + "                    //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb + vec3(lightBRDF.y) * _specularColor.rgb);\n" + "                    Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));\n" + "                    //Context.OutColor.rgb = vec3(spotFallOff);\n" + "                }\n" + "                Context.OutColor.a = alpha;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology DeferredShadingPass2{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram MultiPassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 _diffuseColor = texture(Context.InGBuffer0, uv0);\n" + "                vec4 _specularColorDecode = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _specularColor = floor(_specularColorDecode.rgb) * 0.1f;\n" + "                vec3 _ambientColor = min(fract(_specularColorDecode.rgb) * 10.0f, vec3(1.0f));\n" + "                float _shininess = floor(_diffuseColor.w);\n" + "                float alpha     = min(fract(_diffuseColor.w) * 10.0f, 1.0f);\n" + "                vec3 normal = texture(Context.InGBuffer1, uv0).xyz;\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                Context.OutColor.rgb = _diffuseColor.rgb * Context.AmbientLightColor * _ambientColor;\n" + "\n" + "\n" + "                // 不必担心这个分支，不会影响性能\n" + "                if(Context.MultiId == 0){\n" + "                    for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                        // 后期改为Context.GetLightDir(Context.LightData[i]);\n" + "                        lightColor = Context.WLightData[i];\n" + "                        lightData1 = Context.WLightData[i + 1];\n" + "                        ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                        //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                        // BlinnPhongLighting\n" + "                        //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                        // 标准PhongLighting\n" + "                        //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                        // 计算SpotLight的衰减\n" + "                        float spotFallOff = 1.0;\n" + "                        if( lightColor.w > 1.0f )\n" + "                        {\n" + "                            // 计算SpotLight的范围衰减\n" + "                            spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                        }\n" + "\n" + "                        // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                        // 计算反射率\n" + "                        ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                        // 最终光照值\n" + "                        //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb + vec3(lightBRDF.y) * _specularColor.rgb);\n" + "                        Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));\n" + "                        //Context.OutColor.rgb = vec3(spotFallOff);\n" + "                    }\n" + "                }\n" + "                else{\n" + "                    // point和spot\n" + "                    lightColor = Context.WLight_Data_0;\n" + "                    lightData1 = Context.WLight_Data_1;\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                    //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                    // BlinnPhongLighting\n" + "                    //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                    // 标准PhongLighting\n" + "                    //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                    // 计算SpotLight的衰减\n" + "                    float spotFallOff = 1.0;\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLight_Data_2, lightDir.xyz );\n" + "                    }\n" + "\n" + "                    // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                    // 计算反射率\n" + "                    ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                    // 最终光照值\n" + "                    //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb + vec3(lightBRDF.y) * _specularColor.rgb);\n" + "                    Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));\n" + "                }\n" + "\n" + "\n" + "                Context.OutColor.a = alpha;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology GlobalPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram TilePassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "                float falloff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f);\n" + "                //if(curAngleCos > innerMinusOuter)\n" + "                //    falloff = 1.0f;\n" + "                //else\n" + "                //    falloff = 0.0f;\n" + "\n" + "                #ifdef SRGB\n" + "                    // Use quadratic falloff (notice the ^4)\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0), 4.0);\n" + "                #else\n" + "                    // Use linear falloff\n" + "                    return falloff;\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 _diffuseColor = texture(Context.InGBuffer0, uv0);\n" + "                vec4 _specularColorDecode = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _specularColor = floor(_specularColorDecode.rgb) * 0.1f;\n" + "                vec3 _ambientColor = min(fract(_specularColorDecode.rgb) * 10.0f, vec3(1.0f));\n" + "                float _shininess = floor(_diffuseColor.w);\n" + "                float alpha     = min(fract(_diffuseColor.w) * 10.0f, 1.0f);\n" + "                vec3 normal = texture(Context.InGBuffer1, uv0).xyz;\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                Context.OutColor.rgb = _diffuseColor.rgb * Context.AmbientLightColor * _ambientColor;\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    // 后期改为Context.GetLightDir(Context.LightData[i]);\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                    //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                    // BlinnPhongLighting\n" + "                    //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                    // 标准PhongLighting\n" + "                    //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                    //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                    // 计算SpotLight的衰减\n" + "                    float spotFallOff = 1.0;\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                    // 计算反射率\n" + "                    ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                    // 最终光照值\n" + "                    //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb + vec3(lightBRDF.y) * _specularColor.rgb);\n" + "                    Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));\n" + "                    //Context.OutColor.rgb = vec3(spotFallOff);\n" + "                }\n" + "                Context.OutColor.a = alpha;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology TilePass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram TilePassLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                // 对于DirLight,lightDir.w = 1.0f\n" + "                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "\n" + "                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            // 基于BlinnPhong光照模型计算光照因子\n" + "            // brdf.x保存漫反射部分;brdf.y保存镜面反射部分\n" + "            void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){\n" + "                // diffuse部分\n" + "                float diffuseBRDF = max(0.0f, dot(normal, lightDir));\n" + "                // specular部分\n" + "                // 半角向量代替viewDir参与光照计算\n" + "                vec3 H = normalize(viewDir + lightDir);\n" + "                float HdotN = max(0.0f, dot(H, normal));\n" + "                float specularBRDF = pow( HdotN, shininess );\n" + "\n" + "                // 衰减,对于PointLight和SpotLight来说有效,对于DirLight而言,attenuation一直为1\n" + "                brdf.x = diffuseBRDF * attenuation;\n" + "                brdf.y = specularBRDF * attenuation;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "                float falloff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f);\n" + "                //if(curAngleCos > innerMinusOuter)\n" + "                //    falloff = 1.0f;\n" + "                //else\n" + "                //    falloff = 0.0f;\n" + "\n" + "                #ifdef SRGB\n" + "                    // Use quadratic falloff (notice the ^4)\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0), 4.0);\n" + "                #else\n" + "                    // Use linear falloff\n" + "                    return falloff;\n" + "                #endif\n" + "            }\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 _diffuseColor = texture(Context.InGBuffer0, uv0);\n" + "                vec4 _specularColorDecode = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _specularColor = floor(_specularColorDecode.rgb) * 0.1f;\n" + "                vec3 _ambientColor = min(fract(_specularColorDecode.rgb) * 10.0f, vec3(1.0f));\n" + "                float _shininess = floor(_diffuseColor.w);\n" + "                float alpha     = min(fract(_diffuseColor.w) * 10.0f, 1.0f);\n" + "                vec3 normal = texture(Context.InGBuffer1, uv0).xyz;\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec2 lightBRDF = vec2(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                Context.OutColor.rgb = vec3(0.0f);\n" + "                // Tile Based Shading\n" + "                // 获取tile信息\n" + "                vec3 tile = texture(Context.InTileLightDecode, uv0).xyz;\n" + "                int uoffset = int(tile.x);\n" + "                int voffset = int(tile.z);\n" + "                int count = int(tile.y);\n" + "                if(count > 0){\n" + "                    int lightId;\n" + "                    float temp;\n" + "                    int offset;\n" + "                    // lightIndex采样范围规范化单位\n" + "                    float uvSize = 1.0f / (Context.TileLightOffsetSize - 1.0f);\n" + "                    vec2 lightUV;\n" + "                    // lightData采样范围规范单位\n" + "                    float lightUVSize = 1.0f / (float(Context.TileLightNum) - 1.0f);\n" + "                    vec2 lightDataUV;\n" + "                    for(int i = 0;i < count;i++){\n" + "                        temp = float(uoffset + i);\n" + "                        offset = 0;\n" + "\n" + "                        if(temp >= Context.TileLightOffsetSize){\n" + "                            temp -= Context.TileLightOffsetSize;\n" + "                            offset++;\n" + "                        }\n" + "                        if(temp == Context.TileLightOffsetSize){\n" + "                            temp = 0.0f;\n" + "                        }\n" + "\n" + "                        // lightIndexUV\n" + "                        lightUV = vec2(temp * uvSize, float(voffset + offset) * uvSize);\n" + "                        lightId = int(texture(Context.InTileLightIndex, lightUV).x);\n" + "\n" + "                        // 光源信息\n" + "                        lightDataUV = vec2(float(lightId) * lightUVSize);\n" + "                        lightColor = texture(Context.InTileWLightData0, lightDataUV);\n" + "                        lightData1 = texture(Context.InTileWLightData1, lightDataUV);\n" + "\n" + "                        // point和spot\n" + "                        ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "                        //lightBRDF.x = max( 0.0f, dot( normal, lightDir.xyz ) );\n" + "\n" + "                        // BlinnPhongLighting\n" + "                        //vec3 h = normalize( viewDir + lightDir.xzy );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( normal, h ) ), 32.0f );\n" + "                        // 标准PhongLighting\n" + "                        //vec3 refDir = reflect( lightData1.xyz, normal );\n" + "                        //lightBRDF.y = pow( max( 0.0f, dot( viewDir, refDir ) ), 32.0f);\n" + "\n" + "                        // 计算SpotLight的衰减\n" + "                        float spotFallOff = 1.0;\n" + "                        if( lightColor.w > 1.0f )\n" + "                        {\n" + "                            // 计算SpotLight的范围衰减\n" + "                            spotFallOff = ComputeSpotFalloff( texture(Context.InTileWLightData2, lightDataUV), lightDir.xyz );\n" + "                        }\n" + "\n" + "                        // 如果存在法线纹理,则进一步计算lightDir\n" + "\n" + "                        // 计算反射率\n" + "                        ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);\n" + "\n" + "                        // 最终光照值\n" + "                        //Context.OutColor.rgb += lightColor.rgb * (vec3(lightBRDF.x) * _diffuseColor.rgb + vec3(lightBRDF.y) * _specularColor.rgb);\n" + "                        Context.OutColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));\n" + "                    }\n" + "                }\n" + "                Context.OutColor.a = alpha;\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass DeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass DeferredShadingPass{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology MultiPassDeferred{\n" + "        Sub_Pass DeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass DeferredShadingPass2{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology TileDeferred{\n" + "        Sub_Pass TileDeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass GlobalPass{\n" + "            }\n" + "            Pass TilePass{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_PRINCIPLED_DEFERRED_LIGHTING_DEF_DATA", "// 默认的延迟光照材质定义,实现PBR材质\n" + "Def DeferredLightingDef{\n" + "    Params{\n" + "        // 基础参数\n" + "        vec4 baseColor;\n" + "        sampler2D baseColorMap;\n" + "        sampler2D normalMap;\n" + "\n" + "        // lightMap或AO\n" + "        sampler2D lightMap;\n" + "        bool aoMap;\n" + "        bool lightMapTexCoord;\n" + "\n" + "        // 自发光\n" + "        vec4 emissive;\n" + "        float emissivePower;\n" + "        float emissiveIntensity;\n" + "\n" + "        // metallic管线\n" + "        float metallic;\n" + "        float roughness;\n" + "        sampler2D metallicRoughnessMap;\n" + "        sampler2D metallicMap;\n" + "        sampler2D roughnessMap;\n" + "\n" + "        // specular管线\n" + "        bool useSpecGloss;\n" + "        sampler2D specularGlossinessMap;\n" + "        sampler2D specularMap;\n" + "        sampler2D glossinessMap;\n" + "        vec4 specular;\n" + "        float glossiness;\n" + "\n" + "        // alphaDiscard\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology GBufferPass{\n" + "        Vars{\n" + "            vec3 wNormal;\n" + "            vec4 wTangent;\n" + "            vec3 wPosition;\n" + "            vec2 wUv0;\n" + "            vec2 wUv1;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;\n" + "                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));\n" + "                vec3 norm = normalize(nMat * Context.InNormal);\n" + "                //vec3 t = normalize(nMat * Context.InTangent);\n" + "                wTangent = vec4(normalize(nMat * Context.InTangent.xyz), Context.InTangent.w);\n" + "                //t = normalize(t - dot(t, norm) * norm);\n" + "                //vec3 b = cross(norm, t);\n" + "                //tbnMat = mat3(t, b, norm);\n" + "                wNormal = norm;\n" + "                wUv0 = Context.InUv0;\n" + "                #ifdef Params.lightMapTexCoord\n" + "                    wUv1 = Context.InUv1;\n" + "                #endif\n" + "\n" + "\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            #define GAMMA 2.2f\n" + "            void main(){\n" + "\n" + "                #ifdef Params.baseColor\n" + "                    #ifdef Params.baseColorMap\n" + "                        vec4 albedo = texture(Params.baseColorMap, wUv0) * Params.baseColor;\n" + "                    #else\n" + "                        vec4 albedo = Params.baseColor;\n" + "                    #endif\n" + "                #else\n" + "                    #ifdef Params.baseColorMap\n" + "                        vec4 albedo = texture(Params.baseColorMap, wUv0);\n" + "                    #else\n" + "                        vec4 albedo = vec4(1.0f);\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.alphaDiscard\n" + "                    if(albedo.a < Params.alphaDiscard){\n" + "                        discard;\n" + "                    }\n" + "                #endif\n" + "\n" + "                vec3 normal = wNormal;\n" + "                #ifdef Params.normalMap\n" + "                    // 这里做了一种简化,理论上应该在fs阶段计算tbn,但是从插值的角度来看,可以简化为tbn插值,减少在fs阶段计算tbn开销(虽然这么做不精确,但是折中下可以接受)\n" + "                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;\n" + "                    vec3 tangent = normalize(wTangent.xyz);\n" + "                    mat3 tbnMat = mat3(tangent, wTangent.w * cross(normal, tangent), normal);\n" + "                    normal = normalize(tbnMat * ( normalHeight * 2.0f - 1.0f ));\n" + "                #endif\n" + "\n" + "                #ifdef Params.metallicRoughnessMap\n" + "                    vec2 rm = texture(Params.metallicRoughnessMap, wUv0).gb;\n" + "                    #ifdef Params.roughness\n" + "                        float _roughness = rm.x * max(Params.roughness, 1e-4);\n" + "                    #else\n" + "                        float _roughness = rm.x;\n" + "                    #endif\n" + "                    #ifdef Params.metallic\n" + "                        float _metallic = rm.y * max(Params.metallic, 0.0f);\n" + "                    #else\n" + "                        float _metallic = rm.y;\n" + "                    #endif\n" + "                #else\n" + "                    #ifdef Params.roughnessMap\n" + "                        #ifdef Params.roughness\n" + "                            float _roughness = texture(Params.roughnessMap, wUv0).r * max(Params.roughness, 1e-4);\n" + "                        #else\n" + "                            float _roughness = texture(Params.roughnessMap, wUv0).r;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.roughness\n" + "                            float _roughness = max(Params.roughness, 1e-4);\n" + "                        #else\n" + "                            float _roughness = 1.0f;\n" + "                        #endif\n" + "                    #endif\n" + "                    #ifdef Params.metallicMap\n" + "                        #ifdef Params.metallic\n" + "                            float _metallic = texture(Params.metallicMap, wUv0).r * max(Params.metallic, 0.0f);\n" + "                        #else\n" + "                            float _metallic = texture(Params.metallicMap, wUv0).r;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.metallic\n" + "                            float _metallic = max(Params.metallic, 0.0f);\n" + "                        #else\n" + "                            float _metallic = 1.0f;\n" + "                        #endif\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.useSpecGloss\n" + "                    #ifdef Params.specularGlossinessMap\n" + "                        vec4 _specularColor = texture(Params.specularGlossinessMap, wUv0);\n" + "                        #ifdef Params.glossiness\n" + "                            float _glossiness = _specularColor.a * Params.glossiness;\n" + "                        #else\n" + "                            float _glossiness = _specularColor.a;\n" + "                        #endif\n" + "                        #ifdef Params.specular\n" + "                            _specularColor *= Params.specular;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.specularMap\n" + "                            vec4 _specularColor = texture(Params.specularMap, wUv0);\n" + "                        #else\n" + "                            vec4 _specularColor = vec4(1.0f);\n" + "                        #endif\n" + "                        #ifdef Params.specular\n" + "                            _specularColor *= Params.specular;\n" + "                        #endif\n" + "                        #ifdef Params.glossinessMap\n" + "                            #ifdef Params.glossiness\n" + "                                float _glossiness = texture(Params.glossinessMap, wUv0).r * Params.glossiness;\n" + "                            #else\n" + "                                float _glossiness = texture(Params.glossinessMap, wUv0).r;\n" + "                            #endif\n" + "                        #else\n" + "                            #ifdef Params.glossiness\n" + "                                float _glossiness = Params.glossiness;\n" + "                            #else\n" + "                                float _glossiness = 1.0f;\n" + "                            #endif\n" + "                        #endif\n" + "                    #endif\n" + "                    vec4 _diffuseColor = albedo;\n" + "                    _roughness = 1.0f - _glossiness;\n" + "                    vec3 fZero = _specularColor.rgb;\n" + "                #else\n" + "                    float nonMetalSpec = 0.04f;\n" + "                    vec4 _specularColor = (nonMetalSpec - nonMetalSpec * _metallic) + albedo * _metallic;\n" + "                    vec4 _diffuseColor = albedo - albedo * _metallic;\n" + "                    vec3 fZero = vec3( 0.5f );\n" + "                #endif\n" + "\n" + "                #ifdef Params.lightMap\n" + "                    vec3 _lightMapColor;\n" + "                    #ifdef Params.lightMapTexCoord\n" + "                        _lightMapColor = texture(Params.lightMap, wUv1).rgb;\n" + "                    #else\n" + "                        _lightMapColor = texture(Params.lightMap, wUv0).rgb;\n" + "                    #endif\n" + "                    #ifdef Params.aoMap\n" + "                        _lightMapColor.gb = _lightMapColor.rr;\n" + "                        vec3 ao = _lightMapColor;\n" + "                    #else\n" + "                        _specularColor.rgb *= _lightMapColor;\n" + "                        _diffuseColor.rgb  *= _lightMapColor;\n" + "                        vec3 ao = vec3(1.0f);\n" + "                    #endif\n" + "                #else\n" + "                    vec3 ao = vec3(1.0f);\n" + "                #endif\n" + "\n" + "\n" + "\n" + "\n" + "                Context.OutGBuffer0.xyz = floor(_diffuseColor.rgb * 100.0f) + ao * 0.1f;\n" + "                Context.OutGBuffer0.w   = albedo.a;\n" + "                Context.OutGBuffer1.xyz = floor(normal.xyz * 1000.0f) + wNormal * 0.001f;\n" + "                Context.OutGBuffer2.rgb = floor(_specularColor.rgb * 100.0f) + fZero * 0.1f;\n" + "                Context.OutGBuffer2.a = floor(_roughness * 100.0f) + _metallic * 0.1f;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology DeferredShadingPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram SinglePassIBLLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                #ifdef Context.Srgb\n" + "                    lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                    lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "                #else\n" + "                    // 对于DirLight,lightDir.w = 1.0f\n" + "                    lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "                #endif\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            #define PI 3.14159265358979323846264\n" + "            // 镜面反射菲涅尔计算\n" + "            vec3 F_Shlick(float vh,\tvec3 F0){\n" + "                float fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);\n" + "                return mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);\n" + "            }\n" + "            vec3 F_Schlick2(float cosTheta, vec3 F0)\n" + "            {\n" + "                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n" + "            }\n" + "            // 计算直接光照\n" + "            void ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){\n" + "                vec3 h = normalize(lightDir + viewDir);\n" + "                float ndotl = max( dot( normal, lightDir ), 0.0f );\n" + "                float ndoth = max( dot( normal, h), 0.0f );\n" + "                float hdotv = max( dot( h, viewDir ), 0.0f );\n" + "\n" + "                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)\n" + "                // 而假设恒定\n" + "                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;\n" + "\n" + "                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n" + "                float alpha = roughness * roughness;\n" + "\n" + "                // D, GGX 法线分布函数\n" + "                float alpha2 = alpha * alpha;\n" + "                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);\n" + "                float denom = PI * sum * sum;\n" + "                float D = alpha2 / denom;\n" + "\n" + "                // F, 菲涅尔项\n" + "                vec3 F = F_Shlick( hdotv, fZero );\n" + "\n" + "                // G, 几何遮挡项\n" + "                float k = alpha * 0.5f;\n" + "                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );\n" + "                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );\n" + "                float G = 1.0f / max( G_V * G_L ,0.01f );\n" + "\n" + "                // specularBRDF\n" + "                float t = D * G * ndotl;\n" + "                vec3 specular =  vec3( t ) * F * lightColor;\n" + "\n" + "                directLighting = diffuse + specular;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            // 球谐函数\n" + "            vec3 sphericalHarmonics( const in vec3 normal, const vec3 sph[9] ){\n" + "                float x = normal.x;\n" + "                float y = normal.y;\n" + "                float z = normal.z;\n" + "\n" + "                vec3 result = (\n" + "                    sph[0] +\n" + "\n" + "                    sph[1] * y +\n" + "                    sph[2] * z +\n" + "                    sph[3] * x +\n" + "\n" + "                    sph[4] * y * x +\n" + "                    sph[5] * y * z +\n" + "                    sph[6] * (3.0f * z * z - 1.0f) +\n" + "                    sph[7] * (z * x) +\n" + "                    sph[8] * (x*x - y*y)\n" + "                );\n" + "\n" + "                return max(result, vec3(0.0f));\n" + "            }\n" + "            // 镜面反射趋势朝向\n" + "            vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness){\n" + "\n" + "                float smoothness = 1.0f - realRoughness;\n" + "                float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n" + "                // 当我们在立方体贴图中获取时，结果未规范化\n" + "                vec3 dominant = mix(N, R, lerpFactor);\n" + "\n" + "                return dominant;\n" + "            }\n" + "            // 拟合方程\n" + "            // 关于镜面部分，有很多优化地方，除了常见的优化，还有很多可以替代方案，几乎可以在保证画质的前提下，在移动端35帧率提升到60帧率，详细可参考我的笔记:https://www.cnblogs.com/JhonKkk/p/14313882.html\n" + "            vec3 integrateBRDFApprox( const in vec3 specular, in float roughness, in float NoV ){\n" + "                const vec4 c0 = vec4( -1.0f, -0.0275f, -0.572f, 0.022f );\n" + "                const vec4 c1 = vec4( 1.0f, 0.0425f, 1.04f, -0.04f );\n" + "                vec4 r = roughness * c0 + c1;\n" + "                float a004 = min( r.x * r.x, exp2( -9.28f * NoV ) ) * r.x + r.y;\n" + "                vec2 ab = vec2( -1.04f, 1.04f ) * a004 + r.zw;\n" + "                return specular * ab.x + ab.y;\n" + "            }\n" + "            // 近似镜面IBL多项式\n" + "            vec3 approximateSpecularIBLPolynomial(in samplerCube envMap, in vec3 specularColor , in float roughness, in float ndotv, in vec3 refVec, in float mipMaps){\n" + "                float lod = sqrt( roughness ) * (mipMaps - 1.0f);\n" + "                vec3 prefilteredColor = textureLod(envMap, refVec.xyz, lod).rgb;\n" + "                return prefilteredColor * integrateBRDFApprox(specularColor, roughness, ndotv);\n" + "            }\n" + "            #define GAMMA 2.2f\n" + "            #define GAMMA_T 1.0f / GAMMA\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 buff0 = texture(Context.InGBuffer0, uv0);\n" + "                vec4 buff2 = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _diffuseColor = floor(buff0.rgb) * 0.01f * Context.AmbientLightColor;\n" + "                vec3 _specularColor = floor(buff2.rgb) * 0.01f;\n" + "                vec3 ao = min(fract(buff0.rgb) * 10.0f, vec3(1.0f));\n" + "                vec3 fZero = min(fract(buff2.rgb) * 10.0f, vec3(0.5f));\n" + "                float _roughness = floor(buff2.w) * 0.01f;\n" + "                vec3 n = texture(Context.InGBuffer1, uv0).xyz;\n" + "                vec3 normal = normalize(floor(n) * 0.001f);\n" + "                vec3 wNormal = normalize(fract(n) * 1000.0f);\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec3 directLighting = vec3(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                float ndotv = max( dot( normal, viewDir ), 0.0f );\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                    // 计算PointLight的衰减\n" + "                    float spotFallOff = 1.0 * lightDir.w;\n" + "                    // 计算SpotLight的衰减\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                    Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                }\n" + "\n" + "                if(Context.BlendGiProbes){\n" + "                    #ifdef Context.GIProbes\n" + "                        // 作为webGL项目,暂时不实现探针混合(但作为可拓展,仍然加结尾s命名)\n" + "\n" + "                        // 计算反射视线\n" + "                        vec3 _rv = reflect( -viewDir.xyz, normal.xyz );\n" + "                        float _r = fract( Context.WGIProbe.w );\n" + "                        float _mipMaps = Context.WGIProbe.w - _r;\n" + "                        _rv = _r * ( wPosition.xyz - Context.WGIProbe.xyz ) + _rv;\n" + "\n" + "                        // 使用球谐计算diffuse( 避免Irr采样 )\n" + "                        vec3 giLighting = sphericalHarmonics(normal.xyz, Context.ShCoeffs) * _diffuseColor.rgb;\n" + "\n" + "                        float horiz = dot(_rv, wNormal);\n" + "                        float horizFadePower = 1.0f - _roughness;\n" + "                        horiz = clamp( 1.0f + horizFadePower * horiz, 0.0f, 1.0f );\n" + "                        horiz *= horiz;\n" + "\n" + "                        vec3 _dominantR = getSpecularDominantDir( normal, _rv.xyz, _roughness * _roughness );\n" + "                        giLighting += approximateSpecularIBLPolynomial(Context.InPrefEnvMap, _specularColor.rgb, _roughness, ndotv, _dominantR, _mipMaps) * vec3( horiz );\n" + "                        giLighting *= ao;\n" + "\n" + "                        Context.OutColor.rgb += giLighting * step( 0.0f, Context.WGIProbe.w );\n" + "                        // Context.OutColor.rgb = textureLod(Context.InPrefEnvMap, normal.xyz, 0.0f).rgb;\n" + "                    #endif\n" + "                }\n" + "\n" + "                Context.OutColor.a = buff0.a;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology DeferredShadingPass2{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram MultiPassIBLLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                #ifdef Context.Srgb\n" + "                    lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                    lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "                #else\n" + "                    // 对于DirLight,lightDir.w = 1.0f\n" + "                    lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "                #endif\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            #define PI 3.14159265358979323846264\n" + "            // 镜面反射菲涅尔计算\n" + "            vec3 F_Shlick(float vh,\tvec3 F0){\n" + "                float fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);\n" + "                return mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);\n" + "            }\n" + "            vec3 F_Schlick2(float cosTheta, vec3 F0)\n" + "            {\n" + "                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n" + "            }\n" + "            // 计算直接光照\n" + "            void ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){\n" + "                vec3 h = normalize(lightDir + viewDir);\n" + "                float ndotl = max( dot( normal, lightDir ), 0.0f );\n" + "                float ndoth = max( dot( normal, h), 0.0f );\n" + "                float hdotv = max( dot( h, viewDir ), 0.0f );\n" + "\n" + "                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)\n" + "                // 而假设恒定\n" + "                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;\n" + "\n" + "                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n" + "                float alpha = roughness * roughness;\n" + "\n" + "                // D, GGX 法线分布函数\n" + "                float alpha2 = alpha * alpha;\n" + "                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);\n" + "                float denom = PI * sum * sum;\n" + "                float D = alpha2 / denom;\n" + "\n" + "                // F, 菲涅尔项\n" + "                vec3 F = F_Shlick( hdotv, fZero );\n" + "\n" + "                // G, 几何遮挡项\n" + "                float k = alpha * 0.5f;\n" + "                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );\n" + "                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );\n" + "                float G = 1.0f / max( G_V * G_L ,0.01f );\n" + "\n" + "                // specularBRDF\n" + "                float t = D * G * ndotl;\n" + "                vec3 specular =  vec3( t ) * F * lightColor;\n" + "\n" + "                directLighting = diffuse + specular;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            // 球谐函数\n" + "            vec3 sphericalHarmonics( const in vec3 normal, const vec3 sph[9] ){\n" + "                float x = normal.x;\n" + "                float y = normal.y;\n" + "                float z = normal.z;\n" + "\n" + "                vec3 result = (\n" + "                    sph[0] +\n" + "\n" + "                    sph[1] * y +\n" + "                    sph[2] * z +\n" + "                    sph[3] * x +\n" + "\n" + "                    sph[4] * y * x +\n" + "                    sph[5] * y * z +\n" + "                    sph[6] * (3.0f * z * z - 1.0f) +\n" + "                    sph[7] * (z * x) +\n" + "                    sph[8] * (x*x - y*y)\n" + "                );\n" + "\n" + "                return max(result, vec3(0.0f));\n" + "            }\n" + "            // 镜面反射趋势朝向\n" + "            vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness){\n" + "\n" + "                float smoothness = 1.0f - realRoughness;\n" + "                float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n" + "                // 当我们在立方体贴图中获取时，结果未规范化\n" + "                vec3 dominant = mix(N, R, lerpFactor);\n" + "\n" + "                return dominant;\n" + "            }\n" + "            // 拟合方程\n" + "            // 关于镜面部分，有很多优化地方，除了常见的优化，还有很多可以替代方案，几乎可以在保证画质的前提下，在移动端35帧率提升到60帧率，详细可参考我的笔记:https://www.cnblogs.com/JhonKkk/p/14313882.html\n" + "            vec3 integrateBRDFApprox( const in vec3 specular, in float roughness, in float NoV ){\n" + "                const vec4 c0 = vec4( -1.0f, -0.0275f, -0.572f, 0.022f );\n" + "                const vec4 c1 = vec4( 1.0f, 0.0425f, 1.04f, -0.04f );\n" + "                vec4 r = roughness * c0 + c1;\n" + "                float a004 = min( r.x * r.x, exp2( -9.28f * NoV ) ) * r.x + r.y;\n" + "                vec2 ab = vec2( -1.04f, 1.04f ) * a004 + r.zw;\n" + "                return specular * ab.x + ab.y;\n" + "            }\n" + "            // 近似镜面IBL多项式\n" + "            vec3 approximateSpecularIBLPolynomial(in samplerCube envMap, in vec3 specularColor , in float roughness, in float ndotv, in vec3 refVec, in float mipMaps){\n" + "                float lod = sqrt( roughness ) * (mipMaps - 1.0f);\n" + "                vec3 prefilteredColor = textureLod(envMap, refVec.xyz, lod).rgb;\n" + "                return prefilteredColor * integrateBRDFApprox(specularColor, roughness, ndotv);\n" + "            }\n" + "            #define GAMMA 2.2f\n" + "            #define GAMMA_T 1.0f / GAMMA\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 buff0 = texture(Context.InGBuffer0, uv0);\n" + "                vec4 buff2 = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _diffuseColor = floor(buff0.rgb) * 0.01f * Context.AmbientLightColor;\n" + "                vec3 _specularColor = floor(buff2.rgb) * 0.01f;\n" + "                vec3 ao = min(fract(buff0.rgb) * 10.0f, vec3(1.0f));\n" + "                vec3 fZero = min(fract(buff2.rgb) * 10.0f, vec3(1.0f));\n" + "                float _roughness = floor(buff2.w) * 0.01f;\n" + "                vec3 n = texture(Context.InGBuffer1, uv0).xyz;\n" + "                vec3 normal = normalize(floor(n) * 0.001f);\n" + "                vec3 wNormal = normalize(fract(n) * 1000.0f);\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec3 directLighting = vec3(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                float ndotv = max( dot( normal, viewDir ), 0.0f );\n" + "                if(Context.MultiId == 0){\n" + "                    for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                        lightColor = Context.WLightData[i];\n" + "                        lightData1 = Context.WLightData[i + 1];\n" + "                        ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                        // 计算PointLight的衰减\n" + "                        float spotFallOff = 1.0 * lightDir.w;\n" + "                        // 计算SpotLight的衰减\n" + "                        if( lightColor.w > 1.0f )\n" + "                        {\n" + "                            // 计算SpotLight的范围衰减\n" + "                            spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                        }\n" + "\n" + "                        ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                        Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                    }\n" + "                }\n" + "                else{\n" + "                    lightColor = Context.WLight_Data_0;\n" + "                    lightData1 = Context.WLight_Data_1;\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                    // 计算PointLight的衰减\n" + "                    float spotFallOff = 1.0 * lightDir.w;\n" + "                    // 计算SpotLight的衰减\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLight_Data_2, lightDir.xyz );\n" + "                    }\n" + "\n" + "                    ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                    Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                }\n" + "\n" + "                if(Context.BlendGiProbes){\n" + "                    #ifdef Context.GIProbes\n" + "                        // 作为webGL项目,暂时不实现探针混合(但作为可拓展,仍然加结尾s命名)\n" + "\n" + "                        // 计算反射视线\n" + "                        vec3 _rv = reflect( -viewDir.xyz, normal.xyz );\n" + "                        float _r = fract( Context.WGIProbe.w );\n" + "                        float _mipMaps = Context.WGIProbe.w - _r;\n" + "                        _rv = _r * ( wPosition.xyz - Context.WGIProbe.xyz ) + _rv;\n" + "\n" + "                        // 使用球谐计算diffuse( 避免Irr采样 )\n" + "                        vec3 giLighting = sphericalHarmonics(normal.xyz, Context.ShCoeffs) * _diffuseColor.rgb;\n" + "\n" + "                        float horiz = dot(_rv, wNormal);\n" + "                        float horizFadePower = 1.0f - _roughness;\n" + "                        horiz = clamp( 1.0f + horizFadePower * horiz, 0.0f, 1.0f );\n" + "                        horiz *= horiz;\n" + "\n" + "                        vec3 _dominantR = getSpecularDominantDir( normal, _rv.xyz, _roughness * _roughness );\n" + "                        giLighting += approximateSpecularIBLPolynomial(Context.InPrefEnvMap, _specularColor.rgb, _roughness, ndotv, _dominantR, _mipMaps) * vec3( horiz );\n" + "                        giLighting *= ao;\n" + "\n" + "                        Context.OutColor.rgb += giLighting * step( 0.0f, Context.WGIProbe.w );\n" + "                        // Context.OutColor.rgb = textureLod(Context.InPrefEnvMap, normal.xyz, 0.0f).rgb;\n" + "                    #endif\n" + "                }\n" + "\n" + "                Context.OutColor.a = buff0.a;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology GlobalPass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram TilePassIBLLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                #ifdef Context.Srgb\n" + "                    lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                    lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "                #else\n" + "                    // 对于DirLight,lightDir.w = 1.0f\n" + "                    lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "                #endif\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            #define PI 3.14159265358979323846264\n" + "            // 镜面反射菲涅尔计算\n" + "            vec3 F_Shlick(float vh,\tvec3 F0){\n" + "                float fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);\n" + "                return mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);\n" + "            }\n" + "            vec3 F_Schlick2(float cosTheta, vec3 F0)\n" + "            {\n" + "                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n" + "            }\n" + "            // 计算直接光照\n" + "            void ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){\n" + "                vec3 h = normalize(lightDir + viewDir);\n" + "                float ndotl = max( dot( normal, lightDir ), 0.0f );\n" + "                float ndoth = max( dot( normal, h), 0.0f );\n" + "                float hdotv = max( dot( h, viewDir ), 0.0f );\n" + "\n" + "                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)\n" + "                // 而假设恒定\n" + "                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;\n" + "\n" + "                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n" + "                float alpha = roughness * roughness;\n" + "\n" + "                // D, GGX 法线分布函数\n" + "                float alpha2 = alpha * alpha;\n" + "                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);\n" + "                float denom = PI * sum * sum;\n" + "                float D = alpha2 / denom;\n" + "\n" + "                // F, 菲涅尔项\n" + "                vec3 F = F_Shlick( hdotv, fZero );\n" + "\n" + "                // G, 几何遮挡项\n" + "                float k = alpha * 0.5f;\n" + "                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );\n" + "                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );\n" + "                float G = 1.0f / max( G_V * G_L ,0.01f );\n" + "\n" + "                // specularBRDF\n" + "                float t = D * G * ndotl;\n" + "                vec3 specular =  vec3( t ) * F * lightColor;\n" + "\n" + "                directLighting = diffuse + specular;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            // 球谐函数\n" + "            vec3 sphericalHarmonics( const in vec3 normal, const vec3 sph[9] ){\n" + "                float x = normal.x;\n" + "                float y = normal.y;\n" + "                float z = normal.z;\n" + "\n" + "                vec3 result = (\n" + "                    sph[0] +\n" + "\n" + "                    sph[1] * y +\n" + "                    sph[2] * z +\n" + "                    sph[3] * x +\n" + "\n" + "                    sph[4] * y * x +\n" + "                    sph[5] * y * z +\n" + "                    sph[6] * (3.0f * z * z - 1.0f) +\n" + "                    sph[7] * (z * x) +\n" + "                    sph[8] * (x*x - y*y)\n" + "                );\n" + "\n" + "                return max(result, vec3(0.0f));\n" + "            }\n" + "            // 镜面反射趋势朝向\n" + "            vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness){\n" + "\n" + "                float smoothness = 1.0f - realRoughness;\n" + "                float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n" + "                // 当我们在立方体贴图中获取时，结果未规范化\n" + "                vec3 dominant = mix(N, R, lerpFactor);\n" + "\n" + "                return dominant;\n" + "            }\n" + "            // 拟合方程\n" + "            // 关于镜面部分，有很多优化地方，除了常见的优化，还有很多可以替代方案，几乎可以在保证画质的前提下，在移动端35帧率提升到60帧率，详细可参考我的笔记:https://www.cnblogs.com/JhonKkk/p/14313882.html\n" + "            vec3 integrateBRDFApprox( const in vec3 specular, in float roughness, in float NoV ){\n" + "                const vec4 c0 = vec4( -1.0f, -0.0275f, -0.572f, 0.022f );\n" + "                const vec4 c1 = vec4( 1.0f, 0.0425f, 1.04f, -0.04f );\n" + "                vec4 r = roughness * c0 + c1;\n" + "                float a004 = min( r.x * r.x, exp2( -9.28f * NoV ) ) * r.x + r.y;\n" + "                vec2 ab = vec2( -1.04f, 1.04f ) * a004 + r.zw;\n" + "                return specular * ab.x + ab.y;\n" + "            }\n" + "            // 近似镜面IBL多项式\n" + "            vec3 approximateSpecularIBLPolynomial(in samplerCube envMap, in vec3 specularColor , in float roughness, in float ndotv, in vec3 refVec, in float mipMaps){\n" + "                float lod = sqrt( roughness ) * (mipMaps - 1.0f);\n" + "                vec3 prefilteredColor = textureLod(envMap, refVec.xyz, lod).rgb;\n" + "                return prefilteredColor * integrateBRDFApprox(specularColor, roughness, ndotv);\n" + "            }\n" + "            #define GAMMA 2.2f\n" + "            #define GAMMA_T 1.0f / GAMMA\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 buff0 = texture(Context.InGBuffer0, uv0);\n" + "                vec4 buff2 = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _diffuseColor = floor(buff0.rgb) * 0.01f * Context.AmbientLightColor;\n" + "                vec3 _specularColor = floor(buff2.rgb) * 0.01f;\n" + "                vec3 ao = min(fract(buff0.rgb) * 10.0f, vec3(1.0f));\n" + "                vec3 fZero = min(fract(buff2.rgb) * 10.0f, vec3(0.5f));\n" + "                float _roughness = floor(buff2.w) * 0.01f;\n" + "                vec3 n = texture(Context.InGBuffer1, uv0).xyz;\n" + "                vec3 normal = normalize(floor(n) * 0.001f);\n" + "                vec3 wNormal = normalize(fract(n) * 1000.0f);\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec3 directLighting = vec3(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                float ndotv = max( dot( normal, viewDir ), 0.0f );\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                    // 计算PointLight的衰减\n" + "                    float spotFallOff = 1.0 * lightDir.w;\n" + "                    // 计算SpotLight的衰减\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                    Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                }\n" + "\n" + "                if(Context.BlendGiProbes){\n" + "                    #ifdef Context.GIProbes\n" + "                        // 作为webGL项目,暂时不实现探针混合(但作为可拓展,仍然加结尾s命名)\n" + "\n" + "                        // 计算反射视线\n" + "                        vec3 _rv = reflect( -viewDir.xyz, normal.xyz );\n" + "                        float _r = fract( Context.WGIProbe.w );\n" + "                        float _mipMaps = Context.WGIProbe.w - _r;\n" + "                        _rv = _r * ( wPosition.xyz - Context.WGIProbe.xyz ) + _rv;\n" + "\n" + "                        // 使用球谐计算diffuse( 避免Irr采样 )\n" + "                        vec3 giLighting = sphericalHarmonics(normal.xyz, Context.ShCoeffs) * _diffuseColor.rgb;\n" + "\n" + "                        float horiz = dot(_rv, wNormal);\n" + "                        float horizFadePower = 1.0f - _roughness;\n" + "                        horiz = clamp( 1.0f + horizFadePower * horiz, 0.0f, 1.0f );\n" + "                        horiz *= horiz;\n" + "\n" + "                        vec3 _dominantR = getSpecularDominantDir( normal, _rv.xyz, _roughness * _roughness );\n" + "                        giLighting += approximateSpecularIBLPolynomial(Context.InPrefEnvMap, _specularColor.rgb, _roughness, ndotv, _dominantR, _mipMaps) * vec3( horiz );\n" + "                        giLighting *= ao;\n" + "\n" + "                        Context.OutColor.rgb += giLighting * step( 0.0f, Context.WGIProbe.w );\n" + "                        // Context.OutColor.rgb = textureLod(Context.InPrefEnvMap, normal.xyz, 0.0f).rgb;\n" + "                    #endif\n" + "                }\n" + "                Context.OutColor.a = buff0.a;\n" + "            }\n" + "        }\n" + "    }\n" + "    SubTechnology TilePass{\n" + "        Vars{\n" + "            vec4 wordPosition;\n" + "            vec2 uv0;\n" + "            mat4 pvInverse;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram TilePassIBLLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                Context.OutPosition = vec4(Context.InPosition, 1.0f);\n" + "                wordPosition = Context.OutPosition;\n" + "                uv0 = Context.InUv0;\n" + "                pvInverse = inverse(Context.ProjectViewMatrix);\n" + "            }\n" + "        }\n" + "        Fs_Shader{\n" + "            vec3 getPosition(in float depth, in vec2 newTexCoord){\n" + "\n" + "                vec4 pos;\n" + "                pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);\n" + "                pos.z  = depth * 2.0 - 1.0;\n" + "                pos.w  = 1.0;\n" + "                pos    = pvInverse * pos;\n" + "                pos.xyz /= pos.w;\n" + "                return pos.xyz;\n" + "            }\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                #ifdef Context.Srgb\n" + "                    lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                    lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "                #else\n" + "                    // 对于DirLight,lightDir.w = 1.0f\n" + "                    lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "                #endif\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            #define PI 3.14159265358979323846264\n" + "            // 镜面反射菲涅尔计算\n" + "            vec3 F_Shlick(float vh,\tvec3 F0){\n" + "                float fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);\n" + "                return mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);\n" + "            }\n" + "            vec3 F_Schlick2(float cosTheta, vec3 F0)\n" + "            {\n" + "                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n" + "            }\n" + "            // 计算直接光照\n" + "            void ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){\n" + "                vec3 h = normalize(lightDir + viewDir);\n" + "                float ndotl = max( dot( normal, lightDir ), 0.0f );\n" + "                float ndoth = max( dot( normal, h), 0.0f );\n" + "                float hdotv = max( dot( h, viewDir ), 0.0f );\n" + "\n" + "                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)\n" + "                // 而假设恒定\n" + "                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;\n" + "\n" + "                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n" + "                float alpha = roughness * roughness;\n" + "\n" + "                // D, GGX 法线分布函数\n" + "                float alpha2 = alpha * alpha;\n" + "                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);\n" + "                float denom = PI * sum * sum;\n" + "                float D = alpha2 / denom;\n" + "\n" + "                // F, 菲涅尔项\n" + "                vec3 F = F_Shlick( hdotv, fZero );\n" + "\n" + "                // G, 几何遮挡项\n" + "                float k = alpha * 0.5f;\n" + "                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );\n" + "                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );\n" + "                float G = 1.0f / max( G_V * G_L ,0.01f );\n" + "\n" + "                // specularBRDF\n" + "                float t = D * G * ndotl;\n" + "                vec3 specular =  vec3( t ) * F * lightColor;\n" + "\n" + "                directLighting = diffuse + specular;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            // 球谐函数\n" + "            vec3 sphericalHarmonics( const in vec3 normal, const vec3 sph[9] ){\n" + "                float x = normal.x;\n" + "                float y = normal.y;\n" + "                float z = normal.z;\n" + "\n" + "                vec3 result = (\n" + "                    sph[0] +\n" + "\n" + "                    sph[1] * y +\n" + "                    sph[2] * z +\n" + "                    sph[3] * x +\n" + "\n" + "                    sph[4] * y * x +\n" + "                    sph[5] * y * z +\n" + "                    sph[6] * (3.0f * z * z - 1.0f) +\n" + "                    sph[7] * (z * x) +\n" + "                    sph[8] * (x*x - y*y)\n" + "                );\n" + "\n" + "                return max(result, vec3(0.0f));\n" + "            }\n" + "            // 镜面反射趋势朝向\n" + "            vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness){\n" + "\n" + "                float smoothness = 1.0f - realRoughness;\n" + "                float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n" + "                // 当我们在立方体贴图中获取时，结果未规范化\n" + "                vec3 dominant = mix(N, R, lerpFactor);\n" + "\n" + "                return dominant;\n" + "            }\n" + "            // 拟合方程\n" + "            // 关于镜面部分，有很多优化地方，除了常见的优化，还有很多可以替代方案，几乎可以在保证画质的前提下，在移动端35帧率提升到60帧率，详细可参考我的笔记:https://www.cnblogs.com/JhonKkk/p/14313882.html\n" + "            vec3 integrateBRDFApprox( const in vec3 specular, in float roughness, in float NoV ){\n" + "                const vec4 c0 = vec4( -1.0f, -0.0275f, -0.572f, 0.022f );\n" + "                const vec4 c1 = vec4( 1.0f, 0.0425f, 1.04f, -0.04f );\n" + "                vec4 r = roughness * c0 + c1;\n" + "                float a004 = min( r.x * r.x, exp2( -9.28f * NoV ) ) * r.x + r.y;\n" + "                vec2 ab = vec2( -1.04f, 1.04f ) * a004 + r.zw;\n" + "                return specular * ab.x + ab.y;\n" + "            }\n" + "            // 近似镜面IBL多项式\n" + "            vec3 approximateSpecularIBLPolynomial(in samplerCube envMap, in vec3 specularColor , in float roughness, in float ndotv, in vec3 refVec, in float mipMaps){\n" + "                float lod = sqrt( roughness ) * (mipMaps - 1.0f);\n" + "                vec3 prefilteredColor = textureLod(envMap, refVec.xyz, lod).rgb;\n" + "                return prefilteredColor * integrateBRDFApprox(specularColor, roughness, ndotv);\n" + "            }\n" + "            #define GAMMA 2.2f\n" + "            #define GAMMA_T 1.0f / GAMMA\n" + "            void main(){\n" + "                float depth = texture(Context.InGDepth, uv0).r;\n" + "                if(depth >= 1.0){\n" + "                    Context.OutColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n" + "                    return;\n" + "                }\n" + "                vec3 wPosition = getPosition(depth, uv0);\n" + "                vec4 buff0 = texture(Context.InGBuffer0, uv0);\n" + "                vec4 buff2 = texture(Context.InGBuffer2, uv0);\n" + "                vec3 _diffuseColor = floor(buff0.rgb) * 0.01f * Context.AmbientLightColor;\n" + "                vec3 _specularColor = floor(buff2.rgb) * 0.01f;\n" + "                vec3 ao = min(fract(buff0.rgb) * 10.0f, vec3(1.0f));\n" + "                vec3 fZero = min(fract(buff2.rgb) * 10.0f, vec3(0.5f));\n" + "                float _roughness = floor(buff2.w) * 0.01f;\n" + "                vec3 n = texture(Context.InGBuffer1, uv0).xyz;\n" + "                vec3 normal = normalize(floor(n) * 0.001f);\n" + "                vec3 wNormal = normalize(fract(n) * 1000.0f);\n" + "                // 计算光照\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec3 directLighting = vec3(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                Context.OutColor.rgb = vec3(0.0f);\n" + "                // Tile Based Shading\n" + "                // 获取tile信息\n" + "                vec3 tile = texture(Context.InTileLightDecode, uv0).xyz;\n" + "                int uoffset = int(tile.x);\n" + "                int voffset = int(tile.z);\n" + "                int count = int(tile.y);\n" + "                if(count > 0){\n" + "                    int lightId;\n" + "                    float temp;\n" + "                    int offset;\n" + "                    // lightIndex采样范围规范化单位\n" + "                    float uvSize = 1.0f / (Context.TileLightOffsetSize - 1.0f);\n" + "                    vec2 lightUV;\n" + "                    // lightData采样范围规范单位\n" + "                    float lightUVSize = 1.0f / (float(Context.TileLightNum) - 1.0f);\n" + "                    vec2 lightDataUV;\n" + "                    for(int i = 0;i < count;i++){\n" + "                        temp = float(uoffset + i);\n" + "                        offset = 0;\n" + "\n" + "                        if(temp >= Context.TileLightOffsetSize){\n" + "                            temp -= Context.TileLightOffsetSize;\n" + "                            offset++;\n" + "                        }\n" + "                        if(temp == Context.TileLightOffsetSize){\n" + "                            temp = 0.0f;\n" + "                        }\n" + "\n" + "                        // lightIndexUV\n" + "                        lightUV = vec2(temp * uvSize, float(voffset + offset) * uvSize);\n" + "                        lightId = int(texture(Context.InTileLightIndex, lightUV).x);\n" + "\n" + "                        // 光源信息\n" + "                        lightDataUV = vec2(float(lightId) * lightUVSize);\n" + "                        lightColor = texture(Context.InTileWLightData0, lightDataUV);\n" + "                        lightData1 = texture(Context.InTileWLightData1, lightDataUV);\n" + "\n" + "                        float ndotv = max( dot( normal, viewDir ), 0.0f );\n" + "                        ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                        // 计算PointLight的衰减\n" + "                        float spotFallOff = 1.0 * lightDir.w;\n" + "                        // 计算SpotLight的衰减\n" + "                        if( lightColor.w > 1.0f )\n" + "                        {\n" + "                            // 计算SpotLight的范围衰减\n" + "                            spotFallOff = ComputeSpotFalloff( texture(Context.InTileWLightData2, lightDataUV), lightDir.xyz );\n" + "                        }\n" + "\n" + "                        ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                        Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                    }\n" + "                }\n" + "                Context.OutColor.a = buff0.a;\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology{\n" + "        Sub_Pass DeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass DeferredShadingPass{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology MultiPassDeferred{\n" + "        Sub_Pass DeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass DeferredShadingPass2{\n" + "            }\n" + "        }\n" + "    }\n" + "    Technology TileDeferred{\n" + "        Sub_Pass TileDeferredShading{\n" + "            Pass GBufferPass{\n" + "            }\n" + "            Pass GlobalPass{\n" + "            }\n" + "            Pass TilePass{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

_defineProperty(Internal, "S_PRINCIPLED_LIGHTING_DEF", "// 原理化光照材质定义\n" + "Def PrincipledLightingDef{\n" + "    Params{\n" + "        // 基础参数\n" + "        vec4 baseColor;\n" + "        sampler2D baseColorMap;\n" + "        sampler2D normalMap;\n" + "\n" + "        // lightMap或AO\n" + "        sampler2D lightMap;\n" + "        bool aoMap;\n" + "        bool lightMapTexCoord;\n" + "\n" + "        // 自发光\n" + "        sampler2D emissiveMap;\n" + "        vec4 emissive;\n" + "        float emissivePower;\n" + "        float emissiveIntensity;\n" + "\n" + "        // metallic管线\n" + "        float metallic;\n" + "        float roughness;\n" + "        sampler2D metallicRoughnessMap;\n" + "        sampler2D metallicMap;\n" + "        sampler2D roughnessMap;\n" + "\n" + "        // specular管线\n" + "        bool useSpecGloss;\n" + "        sampler2D specularGlossinessMap;\n" + "        sampler2D specularMap;\n" + "        sampler2D glossinessMap;\n" + "        vec4 specular;\n" + "        float glossiness;\n" + "\n" + "        // alphaDiscard\n" + "        float alphaDiscard;\n" + "    }\n" + "    SubTechnology SPPrincipledLighting{\n" + "        Vars{\n" + "            vec3 wNormal;\n" + "            vec4 wTangent;\n" + "            vec3 wPosition;\n" + "            vec2 wUv0;\n" + "            vec2 wUv1;\n" + "        }\n" + "        Advanced{\n" + "            RenderProgram SinglePassIBLLighting;\n" + "        }\n" + "        Vs_Shader{\n" + "            void main(){\n" + "                #ifdef Context.Skins\n" + "                    mat4 skinMat =\n" + "                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +\n" + "                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +\n" + "                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +\n" + "                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];\n" + "                    // vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);\n" + "                    vec4 pos = skinMat * vec4(Context.InPosition, 1.0f);\n" + "                #else\n" + "                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);\n" + "                #endif\n" + "\n" + "\n" + "                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;\n" + "                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));\n" + "                vec3 norm = normalize(nMat * Context.InNormal);\n" + "                //vec3 t = normalize(nMat * Context.InTangent);\n" + "                wTangent = vec4(normalize(nMat * Context.InTangent.xyz), Context.InTangent.w);\n" + "                //t = normalize(t - dot(t, norm) * norm);\n" + "                //vec3 b = cross(norm, t);\n" + "                //tbnMat = mat3(t, b, norm);\n" + "                wNormal = norm;\n" + "                wUv0 = Context.InUv0;\n" + "                #ifdef Params.lightMapTexCoord\n" + "                    wUv1 = Context.InUv1;\n" + "                #endif\n" + "\n" + "\n" + "                Context.OutPosition = Context.ProjectViewMatrix * pos;\n" + "            }\n" + "        }\n" + "\n" + "        Fs_Shader{\n" + "            // 计算光照方向\n" + "            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0\n" + "            // 输出光照方向\n" + "            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)\n" + "            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){\n" + "                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0\n" + "                float posLight = step(0.5f, lightType);\n" + "\n" + "                // 计算光照位置\n" + "                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向\n" + "                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置\n" + "                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);\n" + "                float dist = length(lightVec);\n" + "\n" + "                #ifdef Context.Srgb\n" + "                    lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);\n" + "                    lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);\n" + "                #else\n" + "                    // 对于DirLight,lightDir.w = 1.0f\n" + "                    lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);\n" + "                #endif\n" + "\n" + "                // 归一化\n" + "                lightDir.xyz = lightVec / vec3(dist);\n" + "            }\n" + "            #define PI 3.14159265358979323846264\n" + "            // 镜面反射菲涅尔计算\n" + "            vec3 F_Shlick(float vh,\tvec3 F0){\n" + "            \tfloat fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);\n" + "            \treturn mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);\n" + "            }\n" + "            vec3 F_Schlick2(float cosTheta, vec3 F0)\n" + "            {\n" + "                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);\n" + "            }\n" + "            // 计算直接光照\n" + "            void ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){\n" + "                vec3 h = normalize(lightDir + viewDir);\n" + "                float ndotl = max( dot( normal, lightDir ), 0.0f );\n" + "                float ndoth = max( dot( normal, h), 0.0f );\n" + "                float hdotv = max( dot( h, viewDir ), 0.0f );\n" + "\n" + "                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)\n" + "                // 而假设恒定\n" + "                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;\n" + "\n" + "                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n" + "                float alpha = roughness * roughness;\n" + "\n" + "                // D, GGX 法线分布函数\n" + "                float alpha2 = alpha * alpha;\n" + "                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);\n" + "                float denom = PI * sum * sum;\n" + "                float D = alpha2 / denom;\n" + "\n" + "                // F, 菲涅尔项\n" + "                vec3 F = F_Shlick( hdotv, fZero );\n" + "\n" + "                // G, 几何遮挡项\n" + "                float k = alpha * 0.5f;\n" + "                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );\n" + "                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );\n" + "                float G = 1.0f / max( G_V * G_L ,0.01f );\n" + "\n" + "                // specularBRDF\n" + "                float t = D * G * ndotl;\n" + "                vec3 specular =  vec3( t ) * F * lightColor;\n" + "\n" + "                directLighting = diffuse + specular;\n" + "            }\n" + "            // 返回Spot范围衰减\n" + "            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){\n" + "                float curAngleCos = dot(lightDir, -spotDirection.xyz);\n" + "                float innerAngleCos = floor(spotDirection.w) * 0.001f;\n" + "                float outerAngleCos = fract(spotDirection.w);\n" + "                float innerMinusOuter = innerAngleCos - outerAngleCos;\n" + "\n" + "                #ifndef Context.Srgb\n" + "                    // 使用二次衰减（请注意^ 4）\n" + "                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f), 4.0f);\n" + "                #else\n" + "                    // 线性空间衰减\n" + "                    return clamp((curAngleCos - outerAngleCos) / innerMinusOuter, step(spotDirection.w, 0.001f), 1.0f);\n" + "                #endif\n" + "            }\n" + "            // 球谐函数\n" + "            vec3 sphericalHarmonics( const in vec3 normal, const vec3 sph[9] ){\n" + "                float x = normal.x;\n" + "                float y = normal.y;\n" + "                float z = normal.z;\n" + "\n" + "                vec3 result = (\n" + "                    sph[0] +\n" + "\n" + "                    sph[1] * y +\n" + "                    sph[2] * z +\n" + "                    sph[3] * x +\n" + "\n" + "                    sph[4] * y * x +\n" + "                    sph[5] * y * z +\n" + "                    sph[6] * (3.0f * z * z - 1.0f) +\n" + "                    sph[7] * (z * x) +\n" + "                    sph[8] * (x*x - y*y)\n" + "                );\n" + "\n" + "                return max(result, vec3(0.0f));\n" + "            }\n" + "            // 镜面反射趋势朝向\n" + "            vec3 getSpecularDominantDir(const in vec3 N, const in vec3 R, const in float realRoughness){\n" + "\n" + "                float smoothness = 1.0f - realRoughness;\n" + "                float lerpFactor = smoothness * (sqrt(smoothness) + realRoughness);\n" + "                // 当我们在立方体贴图中获取时，结果未规范化\n" + "                vec3 dominant = mix(N, R, lerpFactor);\n" + "\n" + "                return dominant;\n" + "            }\n" + "            // 拟合方程\n" + "            // 关于镜面部分，有很多优化地方，除了常见的优化，还有很多可以替代方案，几乎可以在保证画质的前提下，在移动端35帧率提升到60帧率，详细可参考我的笔记:https://www.cnblogs.com/JhonKkk/p/14313882.html\n" + "            vec3 integrateBRDFApprox( const in vec3 specular, in float roughness, in float NoV ){\n" + "                const vec4 c0 = vec4( -1.0f, -0.0275f, -0.572f, 0.022f );\n" + "                const vec4 c1 = vec4( 1.0f, 0.0425f, 1.04f, -0.04f );\n" + "                vec4 r = roughness * c0 + c1;\n" + "                float a004 = min( r.x * r.x, exp2( -9.28f * NoV ) ) * r.x + r.y;\n" + "                vec2 ab = vec2( -1.04f, 1.04f ) * a004 + r.zw;\n" + "                return specular * ab.x + ab.y;\n" + "            }\n" + "            // 近似镜面IBL多项式\n" + "            vec3 approximateSpecularIBLPolynomial(in samplerCube envMap, in vec3 specularColor , in float roughness, in float ndotv, in vec3 refVec, in float mipMaps){\n" + "                float lod = sqrt( roughness ) * (mipMaps - 1.0f);\n" + "                vec3 prefilteredColor = textureLod(envMap, refVec.xyz, lod).rgb;\n" + "                return prefilteredColor * integrateBRDFApprox(specularColor, roughness, ndotv);\n" + "            }\n" + "            #define GAMMA 2.2f\n" + "            #define GAMMA_T 1.0f / GAMMA\n" + "            void main(){\n" + "                vec4 lightColor;\n" + "                vec4 lightData1;\n" + "                vec4 lightDir = vec4(0.0f);\n" + "                vec3 lightVec = vec3(0.0f);\n" + "                vec3 directLighting = vec3(0.0f);\n" + "                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);\n" + "\n" + "                #ifdef Params.baseColor\n" + "                    #ifdef Params.baseColorMap\n" + "                        vec4 albedo = texture(Params.baseColorMap, wUv0) * Params.baseColor * vec4(Context.AmbientLightColor, 1.0);\n" + "                    #else\n" + "                        vec4 albedo = Params.baseColor * vec4(Context.AmbientLightColor, 1.0);\n" + "                    #endif\n" + "                #else\n" + "                    #ifdef Params.baseColorMap\n" + "                        vec4 albedo = texture(Params.baseColorMap, wUv0) * vec4(Context.AmbientLightColor, 1.0);\n" + "                    #else\n" + "                        vec4 albedo = vec4(1.0f) * vec4(Context.AmbientLightColor, 1.0);\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.alphaDiscard\n" + "                    if(albedo.a < Params.alphaDiscard){\n" + "                        discard;\n" + "                    }\n" + "                #endif\n" + "\n" + "                vec3 normal = wNormal;\n" + "                #ifdef Params.normalMap\n" + "                    // 这里做了一种简化,理论上应该在fs阶段计算tbn,但是从插值的角度来看,可以简化为tbn插值,减少在fs阶段计算tbn开销(虽然这么做不精确,但是折中下可以接受)\n" + "                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;\n" + "                    vec3 tangent = normalize(wTangent.xyz);\n" + "                    mat3 tbnMat = mat3(tangent, wTangent.w * cross(normal, tangent), normal);\n" + "                    normal = normalize(tbnMat * ( normalHeight * 2.0f - 1.0f ));\n" + "                #endif\n" + "\n" + "                #ifdef Params.metallicRoughnessMap\n" + "                    vec2 rm = texture(Params.metallicRoughnessMap, wUv0).gb;\n" + "                    #ifdef Params.roughness\n" + "                        float _roughness = rm.x * max(Params.roughness, 1e-4);\n" + "                    #else\n" + "                        float _roughness = rm.x;\n" + "                    #endif\n" + "                    #ifdef Params.metallic\n" + "                        float _metallic = rm.y * max(Params.metallic, 0.0f);\n" + "                    #else\n" + "                        float _metallic = rm.y;\n" + "                    #endif\n" + "                #else\n" + "                    #ifdef Params.roughnessMap\n" + "                        #ifdef Params.roughness\n" + "                            float _roughness = texture(Params.roughnessMap, wUv0).r * max(Params.roughness, 1e-4);\n" + "                        #else\n" + "                            float _roughness = texture(Params.roughnessMap, wUv0).r;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.roughness\n" + "                            float _roughness = max(Params.roughness, 1e-4);\n" + "                        #else\n" + "                            float _roughness = 1.0f;\n" + "                        #endif\n" + "                    #endif\n" + "                    #ifdef Params.metallicMap\n" + "                        #ifdef Params.metallic\n" + "                            float _metallic = texture(Params.metallicMap, wUv0).r * max(Params.metallic, 0.0f);\n" + "                        #else\n" + "                            float _metallic = texture(Params.metallicMap, wUv0).r;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.metallic\n" + "                            float _metallic = max(Params.metallic, 0.0f);\n" + "                        #else\n" + "                            float _metallic = 1.0f;\n" + "                        #endif\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                #ifdef Params.useSpecGloss\n" + "                    #ifdef Params.specularGlossinessMap\n" + "                        vec4 _specularColor = texture(Params.specularGlossinessMap, wUv0);\n" + "                        #ifdef Params.glossiness\n" + "                            float _glossiness = _specularColor.a * Params.glossiness;\n" + "                        #else\n" + "                            float _glossiness = _specularColor.a;\n" + "                        #endif\n" + "                        #ifdef Params.specular\n" + "                            _specularColor *= Params.specular;\n" + "                        #endif\n" + "                    #else\n" + "                        #ifdef Params.specularMap\n" + "                            vec4 _specularColor = texture(Params.specularMap, wUv0);\n" + "                        #else\n" + "                            vec4 _specularColor = vec4(1.0f);\n" + "                        #endif\n" + "                        #ifdef Params.specular\n" + "                            _specularColor *= Params.specular;\n" + "                        #endif\n" + "                        #ifdef Params.glossinessMap\n" + "                            #ifdef Params.glossiness\n" + "                                float _glossiness = texture(Params.glossinessMap, wUv0).r * Params.glossiness;\n" + "                            #else\n" + "                                float _glossiness = texture(Params.glossinessMap, wUv0).r;\n" + "                            #endif\n" + "                        #else\n" + "                            #ifdef Params.glossiness\n" + "                                float _glossiness = Params.glossiness;\n" + "                            #else\n" + "                                float _glossiness = 1.0f;\n" + "                            #endif\n" + "                        #endif\n" + "                    #endif\n" + "                    vec4 _diffuseColor = albedo;\n" + "                    _roughness = 1.0f - _glossiness;\n" + "                    vec3 fZero = _specularColor.rgb;\n" + "                #else\n" + "                    float nonMetalSpec = 0.04f;\n" + "                    vec4 _specularColor = (nonMetalSpec - nonMetalSpec * _metallic) + albedo * _metallic;\n" + "                    vec4 _diffuseColor = albedo - albedo * _metallic;\n" + "                    vec3 fZero = vec3( 0.5f );\n" + "                #endif\n" + "\n" + "                #ifdef Params.lightMap\n" + "                    vec3 _lightMapColor;\n" + "                    #ifdef Params.lightMapTexCoord\n" + "                        _lightMapColor = texture(Params.lightMap, wUv1).rgb;\n" + "                    #else\n" + "                        _lightMapColor = texture(Params.lightMap, wUv0).rgb;\n" + "                    #endif\n" + "                    #ifdef Params.aoMap\n" + "                        _lightMapColor.gb = _lightMapColor.rr;\n" + "                        vec3 ao = _lightMapColor;\n" + "                    #else\n" + "                        _specularColor.rgb *= _lightMapColor;\n" + "                        _diffuseColor.rgb  *= _lightMapColor;\n" + "                        vec3 ao = vec3(1.0f);\n" + "                    #endif\n" + "                #else\n" + "                    vec3 ao = vec3(1.0f);\n" + "                #endif\n" + "\n" + "                float ndotv = max( dot( normal, viewDir ), 0.0f );\n" + "                for( int i = 0;i < Context.CurLightCount;i+=3 ){\n" + "                    lightColor = Context.WLightData[i];\n" + "                    lightData1 = Context.WLightData[i + 1];\n" + "                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);\n" + "\n" + "                    // 计算PointLight的衰减\n" + "                    float spotFallOff = 1.0 * lightDir.w;\n" + "                    // 计算SpotLight的衰减\n" + "                    if( lightColor.w > 1.0f )\n" + "                    {\n" + "                        // 计算SpotLight的范围衰减\n" + "                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );\n" + "                    }\n" + "\n" + "                    ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);\n" + "                    Context.OutColor.rgb += directLighting * spotFallOff;\n" + "                }\n" + "\n" + "                if(Context.BlendGiProbes){\n" + "                    #ifdef Context.GIProbes\n" + "                        // 作为webGL项目,暂时不实现探针混合(但作为可拓展,仍然加结尾s命名)\n" + "\n" + "                        // 计算反射视线\n" + "                        vec3 _rv = reflect( -viewDir.xyz, normal.xyz );\n" + "                        float _r = fract( Context.WGIProbe.w );\n" + "                        float _mipMaps = Context.WGIProbe.w - _r;\n" + "                        _rv = _r * ( wPosition.xyz - Context.WGIProbe.xyz ) + _rv;\n" + "\n" + "                        // 使用球谐计算diffuse( 避免Irr采样 )\n" + "                        vec3 giLighting = sphericalHarmonics(normal.xyz, Context.ShCoeffs) * _diffuseColor.rgb;\n" + "\n" + "                        float horiz = dot(_rv, wNormal);\n" + "                        float horizFadePower = 1.0f - _roughness;\n" + "                        horiz = clamp( 1.0f + horizFadePower * horiz, 0.0f, 1.0f );\n" + "                        horiz *= horiz;\n" + "\n" + "                        vec3 _dominantR = getSpecularDominantDir( normal, _rv.xyz, _roughness * _roughness );\n" + "                        giLighting += approximateSpecularIBLPolynomial(Context.InPrefEnvMap, _specularColor.rgb, _roughness, ndotv, _dominantR, _mipMaps) * vec3( horiz );\n" + "                        giLighting *= ao;\n" + "\n" + "                        Context.OutColor.rgb += giLighting * step( 0.0f, Context.WGIProbe.w );\n" + "                        // Context.OutColor.rgb = textureLod(Context.InPrefEnvMap, normal.xyz, 0.0f).rgb;\n" + "                    #endif\n" + "                }\n" + "\n" + "                #ifdef Params.emissive\n" + "                    float _emissivePower = 3.0f;\n" + "                    #ifdef Params.emissivePower\n" + "                        _emissivePower = Params.emissivePower;\n" + "                    #endif\n" + "                    float _emissiveIntensity = 2.0f;\n" + "                    #ifdef Params.emissiveIntensity\n" + "                        _emissiveIntensity = Params.emissiveIntensity;\n" + "                    #endif\n" + "                    #ifdef Params.emissiveMap\n" + "                        vec4 eMap = texture(Params.emissiveMap, wUv0);\n" + "                        Context.OutColor.rgb += Params.emissive.rgb * eMap.rgb * pow(Params.emissive.a * eMap.a, _emissivePower) * _emissiveIntensity;\n" + "                    #else\n" + "                        Context.OutColor.rgb += Params.emissive.rgb * pow(Params.emissive.a, _emissivePower) * _emissiveIntensity;\n" + "                    #endif\n" + "                #else\n" + "                    #ifdef Params.emissiveMap\n" + "                        float _emissivePower = 3.0f;\n" + "                        #ifdef Params.emissivePower\n" + "                            _emissivePower = Params.emissivePower;\n" + "                        #endif\n" + "                        float _emissiveIntensity = 2.0f;\n" + "                        #ifdef Params.emissiveIntensity\n" + "                            _emisiveIntensity = Params.emissiveIntensity;\n" + "                        #endif\n" + "                        vec4 eMap = texture(Params.emissiveMap, wUv0);\n" + "                        Context.OutColor.rgb += eMap.rgb * pow(eMap.a, _emissivePower) * _emissiveIntensity;\n" + "                    #endif\n" + "                #endif\n" + "\n" + "                Context.OutColor.a = albedo.a;\n" + "\n" + "            }\n" + "        }\n" + "    }\n" + "\n" + "    Technology{\n" + "        Sub_Pass{\n" + "            Pass SPPrincipledLighting{\n" + "            }\n" + "        }\n" + "    }\n" + "}\n");

/***/ }),

/***/ 512:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Base。<br/>
 * @author JhonKkk
 * @date 2021年8月30日20点30分
 */
var Base = /*#__PURE__*/function () {
  function Base(props) {
    _classCallCheck(this, Base);

    _defineProperty(this, "_m_Render", null);

    this._m_Render = props.render;
  }

  _createClass(Base, [{
    key: "render",
    value: function render(cfg) {}
  }]);

  return Base;
}();

exports["default"] = Base;

/***/ }),

/***/ 6528:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Deferred2 = _interopRequireDefault(__webpack_require__(870));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Clustered = /*#__PURE__*/function (_Deferred) {
  _inherits(Clustered, _Deferred);

  var _super = _createSuper(Clustered);

  function Clustered(props) {
    _classCallCheck(this, Clustered);

    return _super.call(this, props);
  }

  _createClass(Clustered, [{
    key: "render",
    value: function render(cfg) {}
  }]);

  return Clustered;
}(_Deferred2.default);

exports["default"] = Clustered;

/***/ }),

/***/ 870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Base2 = _interopRequireDefault(__webpack_require__(512));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _Render = _interopRequireDefault(__webpack_require__(3061));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * DeferredShading。<br/>
 * @author Kkk
 * @update 2021年9月7日20点25分
 */
var Deferred = /*#__PURE__*/function (_Base) {
  _inherits(Deferred, _Base);

  var _super = _createSuper(Deferred);

  function Deferred(props) {
    _classCallCheck(this, Deferred);

    return _super.call(this, props);
  }

  _createClass(Deferred, [{
    key: "render",
    value: function render(cfg) {
      var _this = this;

      var frameContext = cfg.frameContext;
      var gl = cfg.gl;
      var scene = cfg.scene;
      var lights = cfg.lights;
      var stateChange = false;
      var subShaders = null;
      var renderInDeferredShading = false;
      var deferredShadingPass = null;
      var useBackForwardFrameBuffer = false;

      var _loop = function _loop(matId) {
        frameContext.getRenderState().store();
        var subShader = null;
        cfg.bucket[matId].forEach(function (geo) {
          stateChange = false; // 获取当前选中的技术

          var mat = scene.getComponent(matId);
          var currentTechnology = mat.getCurrentTechnology(); // 获取当前技术所有DeferredShading路径下的SubShaders

          var deferredShadingSubPasss = currentTechnology.getSubPasss(_Render.default.DEFERRED_SHADING); // 如果该物体存在DeferredShading路径渲染的需要,则执行DeferredShading渲染

          if (deferredShadingSubPasss) {
            subShaders = deferredShadingSubPasss.getSubShaderMaps(); // 获取GBuffPass
            // 检测是否需要切换FrameBuffer

            subShader = Deferred.S_DEFERRED_SHADING_PASS_GROUP[0];

            if (subShaders[subShader] == null) {
              subShader = Deferred.S_DEFERRED_SHADING_PASS_GROUP_2[0];
            }

            if (!renderInDeferredShading) {
              renderInDeferredShading = true; // 获取deferredShadingSubPasss使用的延迟frameBuffer

              var _dfb = frameContext.getFrameBuffer(subShaders[subShader].subShader.getFBId() || _Render.default.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER);

              gl.bindFramebuffer(gl.FRAMEBUFFER, _dfb.getFrameBuffer());
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
              frameContext.m_LastFrameBuffer = _dfb;
            } else if (frameContext.m_LastFrameBuffer != frameContext.getFrameBuffer(subShaders[subShader].subShader.getFBId() || _Render.default.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER)) {
              // 报错,因为必须所有延迟渲染都使用同一个frameBuffer
              console.error("使用了不同的dfb>>>");
            } // 检测是否需要更新渲染状态


            if (subShaders[subShader].renderState) {
              // 依次检测所有项
              stateChange = _this._m_Render._checkRenderState(gl, subShaders[subShader].renderState, frameContext.getRenderState());
            } // 指定subShader


            mat._selectSubShader(subShaders[subShader].subShader);

            geo.draw(frameContext); // deferredShadingPass

            subShader = Deferred.S_DEFERRED_SHADING_PASS_GROUP[1];
            deferredShadingPass = subShaders[subShader] ? subShaders[subShader] : subShaders[Deferred.S_DEFERRED_SHADING_PASS_GROUP_2[1]];
          }

          if (stateChange) {
            _this._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
          }
        });
      };

      for (var matId in cfg.bucket) {
        _loop(matId);
      }

      if (renderInDeferredShading && deferredShadingPass) {
        useBackForwardFrameBuffer = true;
        var dfb = frameContext.m_LastFrameBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameContext._m_DefaultFrameBuffer);
        frameContext.m_LastFrameBuffer = frameContext._m_DefaultFrameBuffer;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 下面是待实现的内容---------------------↓
        // DeferredShadingPass
        // 1.先检测是否需要切换subShader(根据shader种类)(这里检测可能与理论不一样，打印出id来调试...)

        if (frameContext.m_LastSubShaderId != deferredShadingPass.subShader.getDefId()) {
          // 此时可能未编译,所以需要检测
          // 检测是否需要重新编译subShader
          if (deferredShadingPass.subShader.needCompile()) {
            deferredShadingPass.subShader._compile(gl, frameContext);
          }

          deferredShadingPass.subShader.use(gl);
          frameContext.m_LastSubShaderId = deferredShadingPass.subShader.getDefId();
        } // 2.检测是否需要更新参数到subShader中(同种类型subShaderId,但存在不同具体实力化subShader对象,所以参数不同需要更新)


        if (frameContext.m_LastSubShader != deferredShadingPass.subShader) {
          frameContext.m_LastSubShader = deferredShadingPass.subShader;
        } // 检测是否需要更新渲染状态


        if (deferredShadingPass.renderState) {
          // 依次检测所有项
          this._m_Render._checkRenderState(gl, deferredShadingPass.renderState, frameContext.getRenderState());
        }

        var dfbFramePicture = dfb.getFramePicture();
        var renderDatas = deferredShadingPass.subShader.getRenderDatas(); // 绑定renderData
        // dfb.getTextures().forEach(texture=>{
        //     if(renderDatas[texture.getName()]){
        //         gl.activeTexture(gl.TEXTURE0 + renderDatas[texture.getName()].loc);
        //         gl.bindTexture(gl.TEXTURE_2D, texture.getLoc());
        //     }
        // });

        for (var k in renderDatas) {
          gl.activeTexture(gl.TEXTURE0 + renderDatas[k].loc);
          gl.bindTexture(gl.TEXTURE_2D, frameContext.getFrameBuffer(renderDatas[k].refId).getTexture(renderDatas[k].dataId).getLoc());
        } // 关闭深度测试然后进行渲染dfbFramePicture(因为渲染的是一个Picture,深度永远最小,如果不关闭,则后续的前向渲染所有物体都无法通过测试)
        // draw call


        if (frameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.disable(gl.DEPTH_TEST); // gl.depthMask(false);
        }

        this._m_Render._m_RenderPrograms[deferredShadingPass.subShader.getRenderProgramType()].draw(gl, scene, frameContext, dfbFramePicture, lights); // dfbFramePicture.draw(this._m_FrameContext);


        if (frameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.enable(gl.DEPTH_TEST); // gl.depthMask(true);
        } // 绑定renderData
        // dfb.getTextures().forEach(texture=>{
        //     if(renderDatas[texture.getName()]){
        //         gl.activeTexture(gl.TEXTURE0 + renderDatas[texture.getName()].loc);
        //         gl.bindTexture(gl.TEXTURE_2D, null);
        //     }
        // });
        // 获取所有可见灯光并进行提交数据
        // (判断材质是否需要灯光?)
        // ...
        // 渲染light
        // 获取默认的GUI元素(id为deferredShadingQuad)
        // gl.bindVertexArray(deferredShadingQuadVAO);
        // gl.drawElements(gl.TRIANGLES, 4, gl.UNSIGNED_SHORT, 0);
        // gl.bindVertexArray(null);
        // 上面是待实现的内容---------------------↑
        // 复制geometry深度到下一个渲染缓存(默认缓存)并继续后续渲染
        // 设置写入默认缓存


        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, dfb.getFrameBuffer());
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frameContext._m_DefaultFrameBuffer); // 复制数据到默认缓存
        // 请注意，这可能会也可能不会，因为FBO和默认帧缓冲区的内部格式必须匹配。
        // 内部格式由实现定义。 这适用于我的所有系统，但是如果您的系统不适用，则可能必须在另一个着色器阶段写入深度缓冲区（或以某种方式将默认帧缓冲区的内部格式与FBO的内部格式进行匹配）。

        gl.blitFramebuffer(0, 0, scene.getCanvas().getWidth(), scene.getCanvas().getHeight(), 0, 0, scene.getCanvas().getWidth(), scene.getCanvas().getHeight(), gl.DEPTH_BUFFER_BIT, gl.NEAREST); // 切换回默认fb1

        gl.bindFramebuffer(gl.FRAMEBUFFER, frameContext._m_DefaultFrameBuffer);
      }

      return useBackForwardFrameBuffer;
    }
  }]);

  return Deferred;
}(_Base2.default);

exports["default"] = Deferred;

_defineProperty(Deferred, "S_DEFERRED_SHADING_G_BUFFER_PASS", "GBufferPass");

_defineProperty(Deferred, "S_DEFERRED_SHADING_DEFERRED_SHADING_PASS", "DeferredShadingPass");

_defineProperty(Deferred, "S_DEFERRED_SHADING_PASS_GROUP", [Deferred.S_DEFERRED_SHADING_G_BUFFER_PASS, Deferred.S_DEFERRED_SHADING_DEFERRED_SHADING_PASS]);

_defineProperty(Deferred, "S_DEFERRED_SHADING_PASS_GROUP_2", [0, 1]);

/***/ }),

/***/ 5734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Base2 = _interopRequireDefault(__webpack_require__(512));

var _Render = _interopRequireDefault(__webpack_require__(3061));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Forward Pipeline。<br/>
 * @author Kkk
 * @update 2021年9月7日20点26分
 */
var Forward = /*#__PURE__*/function (_Base) {
  _inherits(Forward, _Base);

  var _super = _createSuper(Forward);

  function Forward(props) {
    _classCallCheck(this, Forward);

    return _super.call(this, props);
  }

  _createClass(Forward, [{
    key: "render",
    value: function render(cfg) {
      var _this = this;

      var frameContext = cfg.frameContext;
      var gl = cfg.gl;
      var scene = cfg.scene;
      var lights = cfg.lights;
      var stateChange = false;
      var subShaders = null;
      frameContext.getRenderState().store();

      if (cfg.opaque) {
        for (var matId in cfg.bucket) {
          stateChange = false; // 获取当前选中的技术

          var mat = scene.getComponent(matId);
          var currentTechnology = mat.getCurrentTechnology(); // 获取当前技术所有Forward路径下的SubShaders

          var forwardSubPasss = currentTechnology.getSubPasss(_Render.default.FORWARD); // 如果该物体存在Forward路径渲染的需要,则执行Forward渲染

          if (forwardSubPasss) {
            subShaders = forwardSubPasss.getSubShaders(); // 执行渲染

            for (var subShader in subShaders) {
              // 检测是否需要更新渲染状态
              if (subShaders[subShader].renderState) {
                // 依次检测所有项
                stateChange = this._m_Render._checkRenderState(gl, subShaders[subShader].renderState, frameContext.getRenderState());
              } // 指定subShader


              mat._selectSubShader(subShaders[subShader].subShader);

              this._m_Render._m_RenderPrograms[subShaders[subShader].subShader.getRenderProgramType()].drawArrays(gl, scene, frameContext, cfg.bucket[matId], lights);
            }
          }

          if (stateChange) {
            this._m_Render._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
          }
        }
      } // 由于半透明按照次序相关渲染，所以无法使用mat合并
      else if (cfg.translucent) {
        cfg.bucket.forEach(function (geo) {
          stateChange = false;
          var mat = geo.getMaterial();
          var currentTechnology = mat.getCurrentTechnology(); // 获取当前技术所有Forward路径下的SubShaders

          var forwardSubPasss = currentTechnology.getSubPasss(_Render.default.FORWARD); // 如果该物体存在Forward路径渲染的需要,则执行Forward渲染

          if (forwardSubPasss) {
            subShaders = forwardSubPasss.getSubShaders(); // 执行渲染

            for (var _subShader in subShaders) {
              // 检测是否需要更新渲染状态
              if (subShaders[_subShader].renderState) {
                // 依次检测所有项
                stateChange = _this._checkRenderState(gl, subShaders[_subShader].renderState, frameContext.getRenderState());
              } // 指定subShader


              mat._selectSubShader(subShaders[_subShader].subShader);

              _this._m_Render._m_RenderPrograms[subShaders[_subShader].subShader.getRenderProgramType()].draw(gl, scene, frameContext, geo, lights); // geo.draw(this._m_FrameContext);

            }
          }

          if (stateChange) {
            _this._m_Render._checkRenderState(gl, frameContext.restore(), frameContext.getRenderState());
          }
        });
      }
    }
  }]);

  return Forward;
}(_Base2.default);

exports["default"] = Forward;

/***/ }),

/***/ 9526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Base2 = _interopRequireDefault(__webpack_require__(512));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ForwardPlus = /*#__PURE__*/function (_Base) {
  _inherits(ForwardPlus, _Base);

  var _super = _createSuper(ForwardPlus);

  function ForwardPlus(props) {
    _classCallCheck(this, ForwardPlus);

    return _super.call(this, props);
  }

  return ForwardPlus;
}(_Base2.default);

exports["default"] = ForwardPlus;

/***/ }),

/***/ 6987:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _Deferred2 = _interopRequireDefault(__webpack_require__(870));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tile Based Deferred。<br/>
 * @author Kkk
 * @date 2021年9月7日20点45分
 */
var TileDeferred = /*#__PURE__*/function (_Deferred) {
  _inherits(TileDeferred, _Deferred);

  var _super = _createSuper(TileDeferred);

  function TileDeferred(props) {
    var _this;

    _classCallCheck(this, TileDeferred);

    _this = _super.call(this, props);

    _this._init();

    return _this;
  }

  _createClass(TileDeferred, [{
    key: "_init",
    value: function _init() {}
  }, {
    key: "render",
    value: function render(cfg) {
      var _this2 = this;

      var frameContext = cfg.frameContext;
      var gl = cfg.gl;
      var scene = cfg.scene;
      var lights = cfg.lights;
      var stateChange = false;
      var subShaders = null;
      var renderInDeferredShading = false;
      var globalPass = null;
      var tilePass = null;
      var useBackForwardFrameBuffer = false;

      var _loop = function _loop(matId) {
        frameContext.getRenderState().store();
        var subShader = null;
        cfg.bucket[matId].forEach(function (geo) {
          stateChange = false; // 获取当前选中的技术

          var mat = scene.getComponent(matId);
          var currentTechnology = mat.getCurrentTechnology(); // 获取当前技术所有DeferredShading路径下的SubShaders

          var deferredShadingSubPasss = currentTechnology.getSubPasss(_Render.default.TILE_DEFERRED_SHADING); // 如果该物体存在DeferredShading路径渲染的需要,则执行DeferredShading渲染

          if (deferredShadingSubPasss) {
            subShaders = deferredShadingSubPasss.getSubShaderMaps(); // 获取GBuffPass
            // 检测是否需要切换FrameBuffer

            subShader = TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP[0];

            if (subShaders[subShader] == null) {
              subShader = TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP_2[0];
            }

            if (!renderInDeferredShading) {
              renderInDeferredShading = true; // 获取deferredShadingSubPasss使用的延迟frameBuffer

              var _dfb = frameContext.getFrameBuffer(subShaders[subShader].subShader.getFBId() || _Render.default.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER);

              gl.bindFramebuffer(gl.FRAMEBUFFER, _dfb.getFrameBuffer());
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
              frameContext.m_LastFrameBuffer = _dfb;
            } else if (frameContext.m_LastFrameBuffer != frameContext.getFrameBuffer(subShaders[subShader].subShader.getFBId() || _Render.default.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER)) {
              // 报错,因为必须所有延迟渲染都使用同一个frameBuffer
              console.error("使用了不同的dfb>>>");
            } // 检测是否需要更新渲染状态


            if (subShaders[subShader].renderState) {
              // 依次检测所有项
              stateChange = _this2._m_Render._checkRenderState(gl, subShaders[subShader].renderState, frameContext.getRenderState());
            } // 指定subShader


            mat._selectSubShader(subShaders[subShader].subShader);

            geo.draw(frameContext); // globalPass

            subShader = TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP[1];
            globalPass = subShaders[subShader] ? subShaders[subShader] : subShaders[TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP_2[1]]; // tilePass

            subShader = TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP[2];
            tilePass = subShaders[subShader] ? subShaders[subShader] : subShaders[TileDeferred.S_TILE_DEFERRED_SHADING_PASS_GROUP_2[2]];
          }

          if (stateChange) {
            _this2._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
          }
        });
      };

      for (var matId in cfg.bucket) {
        _loop(matId);
      }

      if (renderInDeferredShading && globalPass && tilePass) {
        useBackForwardFrameBuffer = true;
        var dfb = frameContext.m_LastFrameBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameContext._m_DefaultFrameBuffer);
        frameContext.m_LastFrameBuffer = frameContext._m_DefaultFrameBuffer;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 关闭深度测试然后进行渲染dfbFramePicture(因为渲染的是一个Picture,深度永远最小,如果不关闭,则后续的前向渲染所有物体都无法通过测试)
        // draw call

        if (frameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.disable(gl.DEPTH_TEST); // gl.depthMask(false);
        } // 首先将dir light部分取出来


        var dirLights = [];
        var otherLights = [];
        var type = null;
        lights.forEach(function (light) {
          type = light.getType();

          if (type == 'DirectionalLight') {
            dirLights.push(light);
          } else if (type == 'PointLight' || type == 'SpotLight') {
            otherLights.push(light);
          }
        }); // Global Pass
        // 1.先检测是否需要切换subShader(根据shader种类)(这里检测可能与理论不一样，打印出id来调试...)

        if (frameContext.m_LastSubShaderId != globalPass.subShader.getDefId()) {
          // 此时可能未编译,所以需要检测
          // 检测是否需要重新编译subShader
          if (globalPass.subShader.needCompile()) {
            globalPass.subShader._compile(gl, frameContext);
          }

          globalPass.subShader.use(gl);
          frameContext.m_LastSubShaderId = globalPass.subShader.getDefId();
        } // 2.检测是否需要更新参数到subShader中(同种类型subShaderId,但存在不同具体实力化subShader对象,所以参数不同需要更新)


        if (frameContext.m_LastSubShader != globalPass.subShader) {
          frameContext.m_LastSubShader = globalPass.subShader;
        } // 检测是否需要更新渲染状态


        if (globalPass.renderState) {
          // 依次检测所有项
          this._m_Render._checkRenderState(gl, globalPass.renderState, frameContext.getRenderState());
        }

        var dfbFramePicture = dfb.getFramePicture();
        var renderDatas = globalPass.subShader.getRenderDatas();

        for (var k in renderDatas) {
          gl.activeTexture(gl.TEXTURE0 + renderDatas[k].loc);
          gl.bindTexture(gl.TEXTURE_2D, frameContext.getFrameBuffer(renderDatas[k].refId).getTexture(renderDatas[k].dataId).getLoc());
        }

        this._m_Render._m_RenderPrograms[globalPass.subShader.getRenderProgramType()].draw(gl, scene, frameContext, dfbFramePicture, dirLights, 0); // Tile Pass
        // 1.先检测是否需要切换subShader(根据shader种类)(这里检测可能与理论不一样，打印出id来调试...)


        if (frameContext.m_LastSubShaderId != tilePass.subShader.getDefId()) {
          // 此时可能未编译,所以需要检测
          // 检测是否需要重新编译subShader
          if (tilePass.subShader.needCompile()) {
            tilePass.subShader._compile(gl, frameContext);
          }

          tilePass.subShader.use(gl);
          frameContext.m_LastSubShaderId = tilePass.subShader.getDefId();
        } // 2.检测是否需要更新参数到subShader中(同种类型subShaderId,但存在不同具体实力化subShader对象,所以参数不同需要更新)


        if (frameContext.m_LastSubShader != tilePass.subShader) {
          frameContext.m_LastSubShader = tilePass.subShader;
        } // 检测是否需要更新渲染状态


        if (tilePass.renderState) {
          // 依次检测所有项
          this._m_Render._checkRenderState(gl, tilePass.renderState, frameContext.getRenderState());
        }

        for (var _k in renderDatas) {
          gl.activeTexture(gl.TEXTURE0 + renderDatas[_k].loc);
          gl.bindTexture(gl.TEXTURE_2D, frameContext.getFrameBuffer(renderDatas[_k].refId).getTexture(renderDatas[_k].dataId).getLoc());
        }

        this._m_Render._m_RenderPrograms[tilePass.subShader.getRenderProgramType()].draw(gl, scene, frameContext, dfbFramePicture, otherLights, 1); // dfbFramePicture.draw(this._m_FrameContext);


        if (frameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.enable(gl.DEPTH_TEST); // gl.depthMask(true);
        } // 复制geometry深度到下一个渲染缓存(默认缓存)并继续后续渲染
        // 设置写入默认缓存


        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, dfb.getFrameBuffer());
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frameContext._m_DefaultFrameBuffer); // 复制数据到默认缓存
        // 请注意，这可能会也可能不会，因为FBO和默认帧缓冲区的内部格式必须匹配。
        // 内部格式由实现定义。 这适用于我的所有系统，但是如果您的系统不适用，则可能必须在另一个着色器阶段写入深度缓冲区（或以某种方式将默认帧缓冲区的内部格式与FBO的内部格式进行匹配）。

        gl.blitFramebuffer(0, 0, scene.getCanvas().getWidth(), scene.getCanvas().getHeight(), 0, 0, scene.getCanvas().getWidth(), scene.getCanvas().getHeight(), gl.DEPTH_BUFFER_BIT, gl.NEAREST); // 切换回默认fb1

        gl.bindFramebuffer(gl.FRAMEBUFFER, frameContext._m_DefaultFrameBuffer);
      }

      return useBackForwardFrameBuffer;
    }
  }]);

  return TileDeferred;
}(_Deferred2.default);

exports["default"] = TileDeferred;

_defineProperty(TileDeferred, "S_TILE_DEFERRED_SHADING_G_BUFFER_PASS", "GBufferPass");

_defineProperty(TileDeferred, "S_TILE_DEFERRED_SHADING_GLOBAL_PASS", "GlobalPass");

_defineProperty(TileDeferred, "S_TILE_DEFERRED_SHADING_TILE_PASS", "TilePass");

_defineProperty(TileDeferred, "S_TILE_DEFERRED_SHADING_PASS_GROUP", [TileDeferred.S_TILE_DEFERRED_SHADING_G_BUFFER_PASS, TileDeferred.S_TILE_DEFERRED_SHADING_GLOBAL_PASS, TileDeferred.S_TILE_DEFERRED_SHADING_TILE_PASS]);

_defineProperty(TileDeferred, "S_TILE_DEFERRED_SHADING_PASS_GROUP_2", [0, 1, 2]);

/***/ }),

/***/ 1393:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 默认渲染程序,其他渲染程序继承该类。<br/>
 * 在该级别下直接渲染物体。<br/>
 * @author Kkk
 * @date 2021年2月17日15点58分
 */
var DefaultRenderProgram = /*#__PURE__*/function () {
  function DefaultRenderProgram(props) {
    _classCallCheck(this, DefaultRenderProgram);
  }
  /**
   * 渲染指定iDrawable。<br/>
   * @param {WebGLContext}[gl]
   * @param {Scene}[scene]
   * @param {FrameContext}[frameContext]
   * @param {IDrawable}[iDrawable]
   * @param {Light[]}[lights灯光信息列表]
   */


  _createClass(DefaultRenderProgram, [{
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights) {
      iDrawable.draw(frameContext);
    }
    /**
     * 渲染指定iDrawable列表。<br/>
     * @param {WebGLContext}[gl]
     * @param {Scene}[scene]
     * @param {FrameContext}[frameContext]
     * @param {IDrawable[]}[iDrawables]
     * @param {Light[]}[lights]
     */

  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights) {
      iDrawables.forEach(function (iDrawable) {
        iDrawable.draw(frameContext);
      });
    }
  }]);

  return DefaultRenderProgram;
}();

exports["default"] = DefaultRenderProgram;

_defineProperty(DefaultRenderProgram, "PROGRAM_TYPE", null);

/***/ }),

/***/ 8388:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _DirectionalLight = _interopRequireDefault(__webpack_require__(7539));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 光照通过多个Pass累计着色，为了性能考虑，这里采用了光锥裁剪进行逐光源Shading。<br/>
 * @author Kkk
 * @date 2021年9月7日13点46分
 * @update 2021年9月7日13点46分
 */
var MultiPassIBLLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(MultiPassIBLLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(MultiPassIBLLightingRenderProgram);

  // 临时变量
  function MultiPassIBLLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, MultiPassIBLLightingRenderProgram);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_m_PV", null);

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec3", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_2", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_3", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Center", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortWidth", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortHeight", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamLeftCoeff", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamTopCoeff", -1);

    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 使用SRC_ALPHA，ONE的原因在于，第一个pass总是dir或ambient


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['SRC_ALPHA', 'ONE']);

    _this._m_ClipLights = new _RenderState.default();

    _this._m_ClipLights.setFlag(_RenderState.default.S_STATES[6], 'On');

    _this._m_m_LastSubShader = null;
    return _this;
  }
  /**
   * 混合GI探头信息。<br/>
   * 暂时仅仅只是提交单个探头信息。<br/>
   * @param {WebGL}[gl]
   * @param {Scene}[scene]
   * @param {FrameContext}[frameContext]
   * @private
   */


  _createClass(MultiPassIBLLightingRenderProgram, [{
    key: "_blendGIProbes",
    value: function _blendGIProbes(gl, scene, frameContext) {
      var conVars = frameContext.m_LastSubShader.getContextVars(); // 探头信息

      var probeLoc = null;

      if (conVars[MultiPassIBLLightingRenderProgram.S_WGIPROBE_SRC] != null) {
        if (this._m_m_LastSubShader != frameContext.m_LastSubShader) {
          // 提取相交的探头
          // 并更新探头数据进行混合渲染(但这里未实现,先记录下)
          // Log.log('提交探头!');
          var giProbe = scene.getGIProbes()[0];
          var giData = _TempVars.default.S_TEMP_VEC4; // 探头位置

          giData.setToInXYZW(giProbe.getPosition()._m_X, giProbe.getPosition()._m_Y, giProbe.getPosition()._m_Z, 1.0 / giProbe.getRadius() + giProbe.getPrefilterMipmap());
          gl.uniform4fv(conVars[MultiPassIBLLightingRenderProgram.S_WGIPROBE_SRC].loc, giData.getBufferData(), 0, 4); // 球谐系数

          giData = giProbe.getShCoeffsBufferData();
          if (conVars[MultiPassIBLLightingRenderProgram.S_SH_COEFFS_SRC] != null) gl.uniform3fv(conVars[MultiPassIBLLightingRenderProgram.S_SH_COEFFS_SRC].loc, giData.getBufferData(), 0, 9 * 3); // prefilterEnvMap

          if (conVars[MultiPassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC] != null) giProbe.getPrefilterEnvMap()._upload(gl, conVars[MultiPassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC].loc);
          this._m_m_LastSubShader = frameContext.m_LastSubShader;
        } else {// 说明提交过探头数据
          // 这里,检测已经提交的探头数据,然后分析是否与之相交,否则关闭探头数据,避免错误的渲染和额外的渲染
        }
      } else {
        // 检测探头
        var giProbes = scene.getGIProbes();

        if (giProbes && giProbes.length > 0) {
          // 找出与之相交的探头
          // 首次,更新材质定义
          frameContext.m_LastMaterial.addDefine(_ShaderSource.default.S_GIPROBES_SRC, true);
        }
      }
    }
    /**
     * 光锥裁剪。<br/>
     * @param {GLContext}[gl]
     * @param {Light}[light 只能是PointLight或SpotLight]
     * @param {Boolean}[lightCvvTest true进行光锥裁剪测试]
     * @return {Boolean}[如果被剔除,则返回false]
     */

  }, {
    key: "_lightClip",
    value: function _lightClip(gl, light, lightCvvTest) {
      var bounding = light.getBoundingVolume();
      var r = bounding.getRadius();
      var lr = r * this._m_CamLeftCoeff;
      var tr = r * this._m_CamTopCoeff;
      var center = bounding.getCenter(this._m_Temp_Vec3);
      center = this._m_Temp_Vec4.setToInXYZW(center._m_X, center._m_Y, center._m_Z, 1.0);
      this._m_Temp_Vec4._m_W = 1.0;
      this._m_Temp_Vec4_2._m_W = 1.0;
      this._m_Temp_Vec4_3._m_W = 1.0; // 与其进行测试，不如直接进行光源裁剪，因为测试会增加cpu变换矩阵的次数
      // let lightFrustumLeftTop = this._m_LightCvv_LeftTop.multLength(r, this._m_Temp_Vec4_2).add(center);
      // let lightFrustumRightBtm = this._m_LightCvv_RightBottom.multLength(r, this._m_Temp_Vec4_3).add(center);
      // Matrix44.multiplyMV(this._m_Light_LeftTop, lightFrustumLeftTop, this._m_PV);
      // Matrix44.multiplyMV(this._m_Light_RightBottom, lightFrustumRightBtm, this._m_PV);
      // if(!lightCvvTest || !this._lightCvvTest(this._m_Light_LeftTop._m_X, this._m_Light_LeftTop._m_Y, this._m_Light_LeftTop._m_W, this._m_Light_RightBottom._m_X, this._m_Light_RightBottom._m_Y, this._m_Light_RightBottom._m_W)){
      //
      //     this._m_Light_LeftTop._m_X /= this._m_Light_LeftTop._m_W;
      //     this._m_Light_LeftTop._m_Y /= this._m_Light_LeftTop._m_W;
      //     this._m_Light_RightBottom._m_X /= this._m_Light_RightBottom._m_W;
      //     this._m_Light_RightBottom._m_Y /= this._m_Light_RightBottom._m_W;
      //     this._m_Light_LeftTop._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_LeftTop._m_X);
      //     this._m_Light_RightBottom._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_RightBottom._m_X);
      //     this._m_Light_LeftTop._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_LeftTop._m_Y);
      //     this._m_Light_RightBottom._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_RightBottom._m_Y);
      //
      //     // 计算光锥裁剪区
      //     let lw = this._m_Light_RightBottom._m_X - this._m_Light_LeftTop._m_X;
      //     let lh = this._m_Light_RightBottom._m_Y - this._m_Light_LeftTop._m_Y;
      //
      //     gl.scissor(this._m_Light_LeftTop._m_X, this._m_ViewPortHeight * 2.0 - this._m_Light_RightBottom._m_Y, lw, lh);
      //     return true;
      // }

      var lightFrustumLeft = this._m_Cam_Left.multLength(lr, this._m_Temp_Vec4_2).add(center);

      var lightFrustumUp = this._m_Cam_Up.multLength(tr, this._m_Temp_Vec4_3).add(center);

      _Matrix.default.multiplyMV(this._m_Light_Left, lightFrustumLeft, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Up, lightFrustumUp, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Center, center, this._m_PV);

      this._m_Light_Left._m_X /= this._m_Light_Left._m_W;
      this._m_Light_Left._m_Y /= this._m_Light_Left._m_W;
      this._m_Light_Up._m_X /= this._m_Light_Up._m_W;
      this._m_Light_Up._m_Y /= this._m_Light_Up._m_W;
      this._m_Light_Center._m_X /= this._m_Light_Center._m_W;
      this._m_Light_Center._m_Y /= this._m_Light_Center._m_W;
      this._m_Light_Left._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Left._m_X);
      this._m_Light_Up._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Up._m_X);
      this._m_Light_Center._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Center._m_X);
      this._m_Light_Left._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Left._m_Y);
      this._m_Light_Up._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Up._m_Y);
      this._m_Light_Center._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Center._m_Y); // 计算光锥裁剪区
      // 视口映射后原点在左上角

      var lw = Math.abs(this._m_Light_Left._m_X - this._m_Light_Center._m_X);
      var lh = Math.abs(this._m_Light_Center._m_Y - this._m_Light_Up._m_Y);
      var left = -1,
          btm = -1;

      if (this._m_Light_Center._m_Z < -this._m_Light_Center._m_W) {
        left = -this._m_Light_Center._m_X - lw;
        btm = -this._m_Light_Center._m_Y + lh;
      } else {
        left = this._m_Light_Center._m_X - lw;
        btm = this._m_Light_Center._m_Y + lh;
      }

      gl.scissor(left, this._m_ViewPortHeight * 2.0 - btm, lw * 2, lh * 2);
      return true;
    }
    /**
     *
     * @param gl
     * @param scene
     * @param {FrameContext}[frameContext]
     * @param lights
     * @param batchSize
     * @param lastIndex
     * @param lightIndex
     * @param passId
     * @param blendGiProbes
     * @private
     */

  }, {
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lightIndex, passId, blendGiProbes) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var enableGI = scene.enableGIProbes();

      if (conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC] != undefined) {
        gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC].loc, passId);
      }

      if (conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
        gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, blendGiProbes && enableGI);
      }

      if (passId == 0) {
        if (conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          if (lastIndex == 0) {
            // 提交合计的ambientColor(场景可能添加多个ambientLight)
            // 也可以设计为场景只能存在一个ambientColor
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          } else {
            // 开启累积缓存模式
            // 我们使用result = s * 1.0 + d * 1.0
            // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
            gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

            scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
          }
        } // 探头信息


        if (enableGI) this._blendGIProbes(gl, scene, frameContext); // 灯光信息

        var lightSpaceLoc = null;
        var lightSpace = null;

        if (conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA] != null) {
          lightSpace = 1;
          lightSpaceLoc = conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA].loc;
        } else if (conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA] != null) {
          lightSpace = 0;
          lightSpaceLoc = conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA].loc;
        } // 计算实际需要上载的灯光


        var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;

        if (lightSpaceLoc == null) {
          return curLightCount + lastIndex;
        }

        var light = null;
        var lightColor = null; // 灯光数据

        var lightData = _TempVars.default.S_LIGHT_DATA_4;
        var array = lightData.getArray();
        var tempVec4 = _TempVars.default.S_TEMP_VEC4;
        var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
        // 数据编码格式内容
        // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

        for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
          light = lights[i];
          lightColor = light.getColor();
          array[offset] = lightColor._m_X;
          array[offset + 1] = lightColor._m_Y;
          array[offset + 2] = lightColor._m_Z;
          array[offset + 3] = light.getTypeId();

          switch (light.getType()) {
            case 'DirectionalLight':
              // 提交灯光方向
              if (lightSpace) {
                // 在视图空间计算光源,避免在片段着色阶段计算viewDir
                tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

                _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

                array[offset + 4] = tempVec4._m_X;
                array[offset + 5] = tempVec4._m_Y;
                array[offset + 6] = tempVec4._m_Z;
                array[offset + 7] = -1;
              } else {
                // 在世界空间计算光源
                array[offset + 4] = light.getDirection()._m_X;
                array[offset + 5] = light.getDirection()._m_Y;
                array[offset + 6] = light.getDirection()._m_Z;
                array[offset + 7] = -1;
              } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


              array[offset + 8] = 0;
              array[offset + 9] = 0;
              array[offset + 10] = 0;
              array[offset + 11] = 0;
              break;
          }
        } // 上载数据
        // gl[conVars[MultiPassIBLLightingRenderProgram.S_LIGHT_DATA].fun]


        gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);
        if (conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
        return curLightCount + lastIndex;
      } else if (passId == 1) {
        var _light = null;
        var _lightColor = null;
        _light = lights[lightIndex]; // 对于第一个pass我们不需要进行光锥裁剪

        if (lastIndex > 0) {
          // 这里，另外一种光源裁剪方式是通过等效BoundingVolume来作为PointLight和SpotLight的Geometry进行一次绘制调用
          // 或者，使用模板缓存测试来完成光源裁剪
          if (!this._lightClip(gl, _light, true)) {
            // 如果lastIndex<=0,表示lightIndex为0或至今还没有一个光源被着色，则返回-1，以便至少一个光源执行ambientColor pass
            return lastIndex <= 0 ? -1 : 0;
          }
        }

        if (conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          if (lastIndex <= 0) {
            // 提交合计的ambientColor(场景可能添加多个ambientLight)
            // 也可以设计为场景只能存在一个ambientColor
            var _ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, _ambientLightColor._m_X, _ambientLightColor._m_Y, _ambientLightColor._m_Z);
          } else {
            // 开启累积缓存模式
            // 我们使用result = s * 1.0 + d * 1.0
            // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
            gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

            scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
          }
        } // 探头信息


        if (enableGI) this._blendGIProbes(gl, scene, frameContext);
        var _lightSpaceLoc = null;
        var lightSpaceLoc1 = null;
        var lightSpaceLoc2 = null;
        var _lightSpace = null;
        var _tempVec = _TempVars.default.S_TEMP_VEC4;
        var _tempVec2 = _TempVars.default.S_TEMP_VEC4_2;
        var tempVec43 = _TempVars.default.S_TEMP_VEC4_3;

        if (conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA0] != undefined) {
          _lightSpace = 1;
          _lightSpaceLoc = conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA0].loc;
          lightSpaceLoc1 = conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA1].loc;
          lightSpaceLoc2 = conVars[MultiPassIBLLightingRenderProgram.S_V_LIGHT_DATA2].loc;
        } else if (conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA0] != undefined) {
          _lightSpace = 0;
          _lightSpaceLoc = conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA0].loc;
          lightSpaceLoc1 = conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA1].loc;
          lightSpaceLoc2 = conVars[MultiPassIBLLightingRenderProgram.S_W_LIGHT_DATA2].loc;
        }

        if (_lightSpace == null) return 1;
        _lightColor = _light.getColor();

        _tempVec.setToInXYZW(_lightColor._m_X, _lightColor._m_Y, _lightColor._m_Z, _light.getTypeId());

        switch (_light.getType()) {
          case 'PointLight':
            if (_lightSpace) {// view空间
            } else {
              // 世界空间
              _tempVec2.setToInXYZW(_light.getPosition()._m_X, _light.getPosition()._m_Y, _light.getPosition()._m_Z, _light.getInRadius());
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            tempVec43.setToInXYZW(0, 0, 0, 0);
            break;

          case 'SpotLight':
            if (_lightSpace) {} else {
              // 世界空间
              _tempVec2.setToInXYZW(_light.getPosition()._m_X, _light.getPosition()._m_Y, _light.getPosition()._m_Z, _light.getInvSpotRange());
            } // 提交spotDir其他信息


            tempVec43.setToInXYZW(_light.getDirection()._m_X, _light.getDirection()._m_Y, _light.getDirection()._m_Z, _light.getPackedAngleCos());
            break;
        }

        if (_lightSpaceLoc != null) {
          gl.uniform4f(_lightSpaceLoc, _tempVec._m_X, _tempVec._m_Y, _tempVec._m_Z, _tempVec._m_W);
        }

        if (lightSpaceLoc1 != null) {
          gl.uniform4f(lightSpaceLoc1, _tempVec2._m_X, _tempVec2._m_Y, _tempVec2._m_Z, _tempVec2._m_W);
        }

        if (lightSpaceLoc2 != null) {
          gl.uniform4f(lightSpaceLoc2, tempVec43._m_X, tempVec43._m_Y, tempVec43._m_Z, tempVec43._m_W);
        } // 返回1表示渲染当前场景


        return 1;
      }

      return 0;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        var enableGI = scene.enableGIProbes();
        if (enableGI) this._blendGIProbes(gl, scene, frameContext);

        if (conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
          gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
        }

        if (conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC] != null) gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC].loc, 0);

        if (conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawable.draw(frameContext);
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过4


      var batchSize = scene.getRender().getBatchLightSize();
      frameContext.getRenderState().store(); // 首先将dir light部分取出来

      var dirLights = [];
      var otherLights = [];
      var type = null;
      lights.forEach(function (light) {
        type = light.getType();

        if (type == 'DirectionalLight') {
          dirLights.push(light);
        } else if (type == 'PointLight' || type == 'SpotLight') {
          otherLights.push(light);
        }
      }); // 在第一个pass中渲染dirLights

      var lastIndex = 0;

      while (lastIndex < dirLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, dirLights, batchSize, lastIndex, -1, 0, lastIndex == 0); // 最后draw

        iDrawable.draw(frameContext);
      } // 在第二个pass中渲染otherLights


      var index = 0;

      if (otherLights.length > 0) {
        scene.getRender()._checkRenderState(gl, this._m_ClipLights, frameContext.getRenderState());

        this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
        this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
        gl.scissor(0, 0, this._m_ViewPortWidth * 2, this._m_ViewPortHeight * 2);
        this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
        var v = scene.getMainCamera().getViewMatrix();

        this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

        this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

        this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

        this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

        this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

        this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
      }

      while (index < otherLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, otherLights, batchSize, lastIndex != 0 ? lastIndex : index, index, 1, lastIndex == 0 && index == 0);
        index++; // 最后draw

        if (lastIndex == 1) {
          iDrawable.draw(frameContext);
        }
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        var enableGI = scene.enableGIProbes();
        if (enableGI) this._blendGIProbes(gl, scene, frameContext);

        if (conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
          gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
        }

        if (conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC] != null) gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_MULTI_ID_SRC].loc, 0);

        if (conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[MultiPassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[MultiPassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过4


      var batchSize = scene.getRender().getBatchLightSize();
      frameContext.getRenderState().store(); // 首先将dir light部分取出来

      var dirLights = [];
      var otherLights = [];
      var type = null;
      lights.forEach(function (light) {
        type = light.getType();

        if (type == 'DirectionalLight') {
          dirLights.push(light);
        } else if (type == 'PointLight' || type == 'SpotLight') {
          otherLights.push(light);
        }
      }); // 在第一个pass中渲染dirLights

      var lastIndex = 0;

      while (lastIndex < dirLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, dirLights, batchSize, lastIndex, -1, 0, lastIndex == 0); // 最后draw

        iDrawable.draw(frameContext);
      } // 在第二个pass中渲染otherLights


      var index = 0;

      if (otherLights.length > 0) {
        scene.getRender()._checkRenderState(gl, this._m_ClipLights, frameContext.getRenderState());

        this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
        this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
        gl.scissor(0, 0, this._m_ViewPortWidth * 2, this._m_ViewPortHeight * 2);
        this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
        var v = scene.getMainCamera().getViewMatrix();

        this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

        this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

        this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

        this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

        this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

        this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
      }

      while (index < otherLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, otherLights, batchSize, lastIndex != 0 ? lastIndex : index, index, 1, lastIndex == 0 && index == 0);
        index++; // 最后draw

        if (lastIndex == 1) {
          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
        }
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }]);

  return MultiPassIBLLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = MultiPassIBLLightingRenderProgram;

_defineProperty(MultiPassIBLLightingRenderProgram, "PROGRAM_TYPE", 'MultiPassIBLLighting');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_BLEND_GI_PROBES", '_blend_gi_probes');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_MULTI_ID_SRC", '_multiId');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_V_LIGHT_DATA0", '_vLight_Data_0');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_V_LIGHT_DATA1", '_vLight_Data_1');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_V_LIGHT_DATA2", '_vLight_Data_2');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_W_LIGHT_DATA0", '_wLight_Data_0');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_W_LIGHT_DATA1", '_wLight_Data_1');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_W_LIGHT_DATA2", '_wLight_Data_2');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_PREF_ENV_MAP_SRC", '_prefEnvMap');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_WGIPROBE_SRC", '_wGIProbe');

_defineProperty(MultiPassIBLLightingRenderProgram, "S_SH_COEFFS_SRC", "_ShCoeffs");

/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _DirectionalLight = _interopRequireDefault(__webpack_require__(7539));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Vector = _interopRequireDefault(__webpack_require__(7141));

var _Vector2 = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 光照通过多个Pass累计着色，为了性能考虑，这里采用了光锥裁剪进行逐光源Shading。<br/>
 * @author Kkk
 * @date 2021年8月31日21点49分
 * @update 2021年9月1日17点46分
 */
var MultiPassLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(MultiPassLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(MultiPassLightingRenderProgram);

  // 临时变量
  function MultiPassLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, MultiPassLightingRenderProgram);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_m_PV", null);

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec3", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_2", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_3", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Up", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Left", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Left", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Up", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Center", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortWidth", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortHeight", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamLeftCoeff", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamTopCoeff", -1);

    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 使用SRC_ALPHA，ONE的原因在于，第一个pass总是dir


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['SRC_ALPHA', 'ONE']);

    _this._m_ClipLights = new _RenderState.default();

    _this._m_ClipLights.setFlag(_RenderState.default.S_STATES[6], 'On');

    return _this;
  }
  /**
   *
   * @param gl
   * @param scene
   * @param {FrameContext}[frameContext]
   * @param lights
   * @param batchSize
   * @param lastIndex
   * @param lightIndex
   * @param passId
   * @private
   */


  _createClass(MultiPassLightingRenderProgram, [{
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lightIndex, passId) {
      var conVars = frameContext.m_LastSubShader.getContextVars();

      if (conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC] != undefined) {
        gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC].loc, passId);
      }

      if (passId == 0) {
        if (conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != undefined) {
          if (lastIndex == 0) {
            // 提交合计的ambientColor(场景可能添加多个ambientLight)
            // 也可以设计为场景只能存在一个ambientColor
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          } else {
            // 开启累积缓存模式
            // 我们使用result = s * s_alpha + d * 1.0
            // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
            gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

            scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
          }
        }

        var lightSpaceLoc = null;
        var lightSpace = null;

        if (conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA] != undefined) {
          lightSpace = 1;
          lightSpaceLoc = conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA].loc;
        } else if (conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA] != undefined) {
          lightSpace = 0;
          lightSpaceLoc = conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA].loc;
        } // 计算实际需要上载的灯光


        var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;
        var light = null;
        var lightColor = null;
        if (lightSpaceLoc == null) return curLightCount + lastIndex; // 灯光数据

        var lightData = _TempVars.default.S_LIGHT_DATA;
        var array = lightData.getArray();
        var tempVec4 = _TempVars.default.S_TEMP_VEC4;
        var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
        // 数据编码格式内容
        // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

        for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
          light = lights[i];
          lightColor = light.getColor();
          array[offset] = lightColor._m_X;
          array[offset + 1] = lightColor._m_Y;
          array[offset + 2] = lightColor._m_Z;
          array[offset + 3] = light.getTypeId();

          switch (light.getType()) {
            case 'DirectionalLight':
              // 提交灯光方向
              if (lightSpace) {
                // 在视图空间计算光源,避免在片段着色阶段计算viewDir
                tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

                _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

                array[offset + 4] = tempVec4._m_X;
                array[offset + 5] = tempVec4._m_Y;
                array[offset + 6] = tempVec4._m_Z;
                array[offset + 7] = -1;
              } else {
                // 在世界空间计算光源
                array[offset + 4] = light.getDirection()._m_X;
                array[offset + 5] = light.getDirection()._m_Y;
                array[offset + 6] = light.getDirection()._m_Z;
                array[offset + 7] = -1;
              } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


              array[offset + 8] = 0;
              array[offset + 9] = 0;
              array[offset + 10] = 0;
              array[offset + 11] = 0;
              break;
          }
        } // 上载数据
        // gl[conVars[MultiPassLightingRenderProgram.S_LIGHT_DATA].fun]


        gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);

        if (conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT] != undefined) {
          gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
        }

        return curLightCount + lastIndex;
      } else if (passId == 1) {
        var _light = null;
        var _lightColor = null;
        _light = lights[lightIndex]; // 对于第一个pass我们不需要进行光锥裁剪

        if (lastIndex > 0) {
          // 这里，另外一种光源裁剪方式是通过等效BoundingVolume来作为PointLight和SpotLight的Geometry进行一次绘制调用
          // 或者，使用模板缓存测试来完成光源裁剪
          if (!this._lightClip(gl, _light, true)) {
            // 如果lastIndex<=0,表示lightIndex为0或至今还没有一个光源被着色，则返回-1，以便至少一个光源执行ambientColor pass
            return lastIndex <= 0 ? -1 : 0;
          }
        }

        if (conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != undefined) {
          if (lastIndex <= 0) {
            // 提交合计的ambientColor(场景可能添加多个ambientLight)
            // 也可以设计为场景只能存在一个ambientColor
            var _ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, _ambientLightColor._m_X, _ambientLightColor._m_Y, _ambientLightColor._m_Z);
          } else {
            // 开启累积缓存模式
            // 我们使用result = s * s_alpha + d * 1.0
            // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
            gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

            scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
          }
        }

        var _lightSpaceLoc = null;
        var lightSpaceLoc1 = null;
        var lightSpaceLoc2 = null;
        var _lightSpace = null;
        var _tempVec = _TempVars.default.S_TEMP_VEC4;
        var _tempVec2 = _TempVars.default.S_TEMP_VEC4_2;
        var tempVec43 = _TempVars.default.S_TEMP_VEC4_3;

        if (conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA0] != undefined) {
          _lightSpace = 1;
          _lightSpaceLoc = conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA0].loc;
          lightSpaceLoc1 = conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA1].loc;
          lightSpaceLoc2 = conVars[MultiPassLightingRenderProgram.S_V_LIGHT_DATA2].loc;
        } else if (conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA0] != undefined) {
          _lightSpace = 0;
          _lightSpaceLoc = conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA0].loc;
          lightSpaceLoc1 = conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA1].loc;
          lightSpaceLoc2 = conVars[MultiPassLightingRenderProgram.S_W_LIGHT_DATA2].loc;
        }

        if (_lightSpace == null) return 1;
        _lightColor = _light.getColor();

        _tempVec.setToInXYZW(_lightColor._m_X, _lightColor._m_Y, _lightColor._m_Z, _light.getTypeId());

        switch (_light.getType()) {
          case 'PointLight':
            if (_lightSpace) {// view空间
            } else {
              // 世界空间
              _tempVec2.setToInXYZW(_light.getPosition()._m_X, _light.getPosition()._m_Y, _light.getPosition()._m_Z, _light.getInRadius());
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            tempVec43.setToInXYZW(0, 0, 0, 0);
            break;

          case 'SpotLight':
            if (_lightSpace) {} else {
              // 世界空间
              _tempVec2.setToInXYZW(_light.getPosition()._m_X, _light.getPosition()._m_Y, _light.getPosition()._m_Z, _light.getInvSpotRange());
            } // 提交spotDir其他信息


            tempVec43.setToInXYZW(_light.getDirection()._m_X, _light.getDirection()._m_Y, _light.getDirection()._m_Z, _light.getPackedAngleCos());
            break;
        }

        if (_lightSpaceLoc != null) {
          gl.uniform4f(_lightSpaceLoc, _tempVec._m_X, _tempVec._m_Y, _tempVec._m_Z, _tempVec._m_W);
        }

        if (lightSpaceLoc1 != null) {
          gl.uniform4f(lightSpaceLoc1, _tempVec2._m_X, _tempVec2._m_Y, _tempVec2._m_Z, _tempVec2._m_W);
        }

        if (lightSpaceLoc2 != null) {
          gl.uniform4f(lightSpaceLoc2, tempVec43._m_X, tempVec43._m_Y, tempVec43._m_Z, tempVec43._m_W);
        } // 返回1表示渲染当前场景


        return 1;
      }

      return 0;
    }
    /**
     * 光锥裁剪。<br/>
     * @param {GLContext}[gl]
     * @param {Light}[light 只能是PointLight或SpotLight]
     * @param {Boolean}[lightCvvTest true进行光锥裁剪测试]
     * @return {Boolean}[如果被剔除,则返回false]
     */

  }, {
    key: "_lightClip",
    value: function _lightClip(gl, light, lightCvvTest) {
      var bounding = light.getBoundingVolume();
      var r = bounding.getRadius();
      var lr = r * this._m_CamLeftCoeff;
      var tr = r * this._m_CamTopCoeff;
      var center = bounding.getCenter(this._m_Temp_Vec3);
      center = this._m_Temp_Vec4.setToInXYZW(center._m_X, center._m_Y, center._m_Z, 1.0);
      this._m_Temp_Vec4._m_W = 1.0;
      this._m_Temp_Vec4_2._m_W = 1.0;
      this._m_Temp_Vec4_3._m_W = 1.0; // 与其进行测试，不如直接进行光源裁剪，因为测试会增加cpu变换矩阵的次数
      // let lightFrustumLeftTop = this._m_LightCvv_LeftTop.multLength(r, this._m_Temp_Vec4_2).add(center);
      // let lightFrustumRightBtm = this._m_LightCvv_RightBottom.multLength(r, this._m_Temp_Vec4_3).add(center);
      // Matrix44.multiplyMV(this._m_Light_LeftTop, lightFrustumLeftTop, this._m_PV);
      // Matrix44.multiplyMV(this._m_Light_RightBottom, lightFrustumRightBtm, this._m_PV);
      // if(!lightCvvTest || !this._lightCvvTest(this._m_Light_LeftTop._m_X, this._m_Light_LeftTop._m_Y, this._m_Light_LeftTop._m_W, this._m_Light_RightBottom._m_X, this._m_Light_RightBottom._m_Y, this._m_Light_RightBottom._m_W)){
      //
      //     this._m_Light_LeftTop._m_X /= this._m_Light_LeftTop._m_W;
      //     this._m_Light_LeftTop._m_Y /= this._m_Light_LeftTop._m_W;
      //     this._m_Light_RightBottom._m_X /= this._m_Light_RightBottom._m_W;
      //     this._m_Light_RightBottom._m_Y /= this._m_Light_RightBottom._m_W;
      //     this._m_Light_LeftTop._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_LeftTop._m_X);
      //     this._m_Light_RightBottom._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_RightBottom._m_X);
      //     this._m_Light_LeftTop._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_LeftTop._m_Y);
      //     this._m_Light_RightBottom._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_RightBottom._m_Y);
      //
      //     // 计算光锥裁剪区
      //     let lw = this._m_Light_RightBottom._m_X - this._m_Light_LeftTop._m_X;
      //     let lh = this._m_Light_RightBottom._m_Y - this._m_Light_LeftTop._m_Y;
      //
      //     gl.scissor(this._m_Light_LeftTop._m_X, this._m_ViewPortHeight * 2.0 - this._m_Light_RightBottom._m_Y, lw, lh);
      //     return true;
      // }

      var lightFrustumLeft = this._m_Cam_Left.multLength(lr, this._m_Temp_Vec4_2).add(center);

      var lightFrustumUp = this._m_Cam_Up.multLength(tr, this._m_Temp_Vec4_3).add(center);

      _Matrix.default.multiplyMV(this._m_Light_Left, lightFrustumLeft, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Up, lightFrustumUp, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Center, center, this._m_PV);

      this._m_Light_Left._m_X /= this._m_Light_Left._m_W;
      this._m_Light_Left._m_Y /= this._m_Light_Left._m_W;
      this._m_Light_Up._m_X /= this._m_Light_Up._m_W;
      this._m_Light_Up._m_Y /= this._m_Light_Up._m_W;
      this._m_Light_Center._m_X /= this._m_Light_Center._m_W;
      this._m_Light_Center._m_Y /= this._m_Light_Center._m_W;
      this._m_Light_Left._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Left._m_X);
      this._m_Light_Up._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Up._m_X);
      this._m_Light_Center._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Center._m_X);
      this._m_Light_Left._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Left._m_Y);
      this._m_Light_Up._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Up._m_Y);
      this._m_Light_Center._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Center._m_Y); // 计算光锥裁剪区
      // 视口映射后原点在左上角

      var lw = Math.abs(this._m_Light_Left._m_X - this._m_Light_Center._m_X);
      var lh = Math.abs(this._m_Light_Center._m_Y - this._m_Light_Up._m_Y);
      var left = -1,
          btm = -1;

      if (this._m_Light_Center._m_Z < -this._m_Light_Center._m_W) {
        left = -this._m_Light_Center._m_X - lw;
        btm = -this._m_Light_Center._m_Y + lh;
      } else {
        left = this._m_Light_Center._m_X - lw;
        btm = this._m_Light_Center._m_Y + lh;
      }

      gl.scissor(left, this._m_ViewPortHeight * 2.0 - btm, lw * 2, lh * 2);
      return true;
    }
    /**
     * 光锥测试。<br/>
     * @param xl
     * @param yl
     * @param wl
     * @param xb
     * @param yb
     * @param wb
     * @return {boolean}
     * @private
     */

  }, {
    key: "_lightCvvTest",
    value: function _lightCvvTest(xl, yl, wl, xb, yb, wb) {
      // 比较光锥而非点的CVV测试
      return xb < -wb || xl > wl || yb > wb || yl < -wl;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        if (conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC] != null) gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC].loc, 0); // 提交合计的ambientColor(场景可能添加多个ambientLight)
        // 也可以设计为场景只能存在一个ambientColor

        if (conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawable.draw(frameContext);
        return;
      } // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过batchSize


      var batchSize = scene.getRender().getBatchLightSize();
      frameContext.getRenderState().store(); // 首先将dir light部分取出来

      var dirLights = [];
      var otherLights = [];
      lights.forEach(function (light) {
        if (light.getType() == 'DirectionalLight') {
          dirLights.push(light);
        } else {
          otherLights.push(light);
        }
      }); // 在第一个pass中渲染dirLights

      var lastIndex = 0;

      while (lastIndex < dirLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, dirLights, batchSize, lastIndex, -1, 0); // 最后draw

        iDrawable.draw(frameContext);
      } // 在第二个pass中渲染otherLights


      var index = 0;

      if (otherLights.length > 0) {
        scene.getRender()._checkRenderState(gl, this._m_ClipLights, frameContext.getRenderState());

        this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
        this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
        gl.scissor(0, 0, this._m_ViewPortWidth * 2, this._m_ViewPortHeight * 2);
        this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
        var v = scene.getMainCamera().getViewMatrix();

        this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

        this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

        this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

        this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

        this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

        this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
      }

      while (index < otherLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, otherLights, batchSize, lastIndex != 0 ? lastIndex : index, index, 1);
        index++; // 最后draw

        if (lastIndex == 1) {
          iDrawable.draw(frameContext);
        }
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        if (conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC] != null) gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_MULTI_ID_SRC].loc, 0); // 提交合计的ambientColor(场景可能添加多个ambientLight)
        // 也可以设计为场景只能存在一个ambientColor

        if (conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[MultiPassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[MultiPassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
        return;
      } // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过batchSize


      var batchSize = scene.getRender().getBatchLightSize();
      frameContext.getRenderState().store(); // 首先将dir light部分取出来

      var dirLights = [];
      var otherLights = [];
      lights.forEach(function (light) {
        if (light.getType() == 'DirectionalLight') {
          dirLights.push(light);
        } else {
          otherLights.push(light);
        }
      }); // 在第一个pass中渲染dirLights

      var lastIndex = 0;

      while (lastIndex < dirLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, dirLights, batchSize, lastIndex, -1, 0); // 最后draw

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
      } // 在第二个pass中渲染otherLights


      var index = 0;

      if (otherLights.length > 0) {
        scene.getRender()._checkRenderState(gl, this._m_ClipLights, frameContext.getRenderState());

        this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
        this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
        gl.scissor(0, 0, this._m_ViewPortWidth * 2, this._m_ViewPortHeight * 2);
        this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
        var v = scene.getMainCamera().getViewMatrix();

        this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

        this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

        this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

        this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

        this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

        this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
      }

      while (index < otherLights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, otherLights, batchSize, lastIndex != 0 ? lastIndex : index, index, 1);
        index++; // 最后draw

        if (lastIndex == 1) {
          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
        }
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState()); // gl.disable(gl.SCISSOR_TEST);


      frameContext.BatchLightLastIndex = lastIndex;
    }
  }]);

  return MultiPassLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = MultiPassLightingRenderProgram;

_defineProperty(MultiPassLightingRenderProgram, "PROGRAM_TYPE", 'MultiPassLighting');

_defineProperty(MultiPassLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(MultiPassLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(MultiPassLightingRenderProgram, "S_MULTI_ID_SRC", '_multiId');

_defineProperty(MultiPassLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(MultiPassLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

_defineProperty(MultiPassLightingRenderProgram, "S_V_LIGHT_DATA0", '_vLight_Data_0');

_defineProperty(MultiPassLightingRenderProgram, "S_V_LIGHT_DATA1", '_vLight_Data_1');

_defineProperty(MultiPassLightingRenderProgram, "S_V_LIGHT_DATA2", '_vLight_Data_2');

_defineProperty(MultiPassLightingRenderProgram, "S_W_LIGHT_DATA0", '_wLight_Data_0');

_defineProperty(MultiPassLightingRenderProgram, "S_W_LIGHT_DATA1", '_wLight_Data_1');

_defineProperty(MultiPassLightingRenderProgram, "S_W_LIGHT_DATA2", '_wLight_Data_2');

/***/ }),

/***/ 8546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _DirectionalLight = _interopRequireDefault(__webpack_require__(7539));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 在单个pass中批量处理多个灯光。<br/>
 * @author Kkk
 * @date 2021年3月21日19点20分
 * @update 2021年8月28日21点44分
 */
var SinglePassIBLLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(SinglePassIBLLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(SinglePassIBLLightingRenderProgram);

  function SinglePassIBLLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, SinglePassIBLLightingRenderProgram);

    _this = _super.call(this, props);
    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 不使用SRC_ALPHA，ONE的原因在于，如果第一个光源是point或spot，则会导致累计光源渲染一个DirLight时，对于材质半透明的物体会出现累加错误的情况，因为混合了alpha


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['ONE', 'ONE']);

    _this._m_m_LastSubShader = null;
    return _this;
  }
  /**
   * 混合GI探头信息。<br/>
   * 暂时仅仅只是提交单个探头信息。<br/>
   * @param {WebGL}[gl]
   * @param {Scene}[scene]
   * @param {FrameContext}[frameContext]
   * @private
   */


  _createClass(SinglePassIBLLightingRenderProgram, [{
    key: "_blendGIProbes",
    value: function _blendGIProbes(gl, scene, frameContext) {
      var conVars = frameContext.m_LastSubShader.getContextVars(); // 探头信息

      var probeLoc = null;

      if (conVars[SinglePassIBLLightingRenderProgram.S_WGIPROBE_SRC] != null) {
        if (this._m_m_LastSubShader != frameContext.m_LastSubShader) {
          // 提取相交的探头
          // 并更新探头数据进行混合渲染(但这里未实现,先记录下)
          // Log.log('提交探头!');
          var giProbe = scene.getGIProbes()[0];
          var giData = _TempVars.default.S_TEMP_VEC4; // 探头位置

          giData.setToInXYZW(giProbe.getPosition()._m_X, giProbe.getPosition()._m_Y, giProbe.getPosition()._m_Z, 1.0 / giProbe.getRadius() + giProbe.getPrefilterMipmap());
          gl.uniform4fv(conVars[SinglePassIBLLightingRenderProgram.S_WGIPROBE_SRC].loc, giData.getBufferData(), 0, 4); // 球谐系数

          giData = giProbe.getShCoeffsBufferData();
          if (conVars[SinglePassIBLLightingRenderProgram.S_SH_COEFFS_SRC] != null) gl.uniform3fv(conVars[SinglePassIBLLightingRenderProgram.S_SH_COEFFS_SRC].loc, giData.getBufferData(), 0, 9 * 3); // prefilterEnvMap

          if (conVars[SinglePassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC] != null) giProbe.getPrefilterEnvMap()._upload(gl, conVars[SinglePassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC].loc);
          this._m_m_LastSubShader = frameContext.m_LastSubShader;
        } else {// 说明提交过探头数据
          // 这里,检测已经提交的探头数据,然后分析是否与之相交,否则关闭探头数据,避免错误的渲染和额外的渲染
        }
      } else {
        // 检测探头
        var giProbes = scene.getGIProbes();

        if (giProbes && giProbes.length > 0) {
          // 找出与之相交的探头
          // 首次,更新材质定义
          frameContext.m_LastMaterial.addDefine(_ShaderSource.default.S_GIPROBES_SRC, true);
        }
      }
    }
    /**
     *
     * @param gl
     * @param scene
     * @param {FrameContext}[frameContext]
     * @param lights
     * @param batchSize
     * @param lastIndex
     * @private
     */

  }, {
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, blendGiProbes) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var enableGI = scene.enableGIProbes();

      if (conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
        gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, blendGiProbes && enableGI);
      }

      if (conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
        if (lastIndex == 0) {
          // 提交合计的ambientColor(场景可能添加多个ambientLight)
          // 也可以设计为场景只能存在一个ambientColor
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        } else {
          // 开启累积缓存模式
          // 我们使用result = s * 1.0 + d * 1.0
          // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
          gl.uniform3f(conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        }
      } // 探头信息


      if (enableGI) this._blendGIProbes(gl, scene, frameContext); // 灯光信息

      var lightSpaceLoc = null;
      var lightSpace = null;

      if (conVars[SinglePassIBLLightingRenderProgram.S_V_LIGHT_DATA] != null) {
        lightSpace = 1;
        lightSpaceLoc = conVars[SinglePassIBLLightingRenderProgram.S_V_LIGHT_DATA].loc;
      } else if (conVars[SinglePassIBLLightingRenderProgram.S_W_LIGHT_DATA] != null) {
        lightSpace = 0;
        lightSpaceLoc = conVars[SinglePassIBLLightingRenderProgram.S_W_LIGHT_DATA].loc;
      } // 计算实际需要上载的灯光


      var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;

      if (lightSpaceLoc == null) {
        return curLightCount + lastIndex;
      }

      var light = null;
      var lightColor = null; // 灯光数据

      var lightData = _TempVars.default.S_LIGHT_DATA_4;
      var array = lightData.getArray();
      var tempVec4 = _TempVars.default.S_TEMP_VEC4;
      var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
      // 数据编码格式内容
      // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

      for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
        light = lights[i];
        lightColor = light.getColor();
        array[offset] = lightColor._m_X;
        array[offset + 1] = lightColor._m_Y;
        array[offset + 2] = lightColor._m_Z;
        array[offset + 3] = light.getTypeId();

        switch (light.getType()) {
          case 'DirectionalLight':
            // 提交灯光方向
            if (lightSpace) {
              // 在视图空间计算光源,避免在片段着色阶段计算viewDir
              tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

              _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

              array[offset + 4] = tempVec4._m_X;
              array[offset + 5] = tempVec4._m_Y;
              array[offset + 6] = tempVec4._m_Z;
              array[offset + 7] = -1;
            } else {
              // 在世界空间计算光源
              array[offset + 4] = light.getDirection()._m_X;
              array[offset + 5] = light.getDirection()._m_Y;
              array[offset + 6] = light.getDirection()._m_Z;
              array[offset + 7] = -1;
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;

          case 'PointLight':
            if (lightSpace) {// view空间
            } else {
              // 世界空间
              array[offset + 4] = light.getPosition()._m_X;
              array[offset + 5] = light.getPosition()._m_Y;
              array[offset + 6] = light.getPosition()._m_Z;
              array[offset + 7] = light.getInRadius();
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;

          case 'SpotLight':
            if (lightSpace) {} else {
              // 世界空间
              array[offset + 4] = light.getPosition()._m_X;
              array[offset + 5] = light.getPosition()._m_Y;
              array[offset + 6] = light.getPosition()._m_Z;
              array[offset + 7] = light.getInvSpotRange();
            } // 提交spotDir其他信息


            array[offset + 8] = light.getDirection()._m_X;
            array[offset + 9] = light.getDirection()._m_Y;
            array[offset + 10] = light.getDirection()._m_Z;
            array[offset + 11] = light.getPackedAngleCos();
            break;
        }
      } // 上载数据
      // gl[conVars[SinglePassLightingRenderProgram.S_LIGHT_DATA].fun]


      gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);
      if (conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
      return curLightCount + lastIndex;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        var enableGI = scene.enableGIProbes();
        if (enableGI) this._blendGIProbes(gl, scene, frameContext);

        if (conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
          gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
        }

        if (conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);

        if (conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        iDrawable.draw(frameContext);
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过4


      var batchSize = scene.getRender().getBatchLightSize();
      var lastIndex = 0;
      frameContext.getRenderState().store();

      while (lastIndex < lights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lastIndex == 0); // 最后draw

        iDrawable.draw(frameContext);
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();
        var enableGI = scene.enableGIProbes();
        if (enableGI) this._blendGIProbes(gl, scene, frameContext);

        if (conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
          gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
        }

        if (conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);

        if (conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过4


      var batchSize = scene.getRender().getBatchLightSize();
      var lastIndex = 0;
      frameContext.getRenderState().store();

      while (lastIndex < lights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lastIndex == 0); // 最后draw

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }]);

  return SinglePassIBLLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = SinglePassIBLLightingRenderProgram;

_defineProperty(SinglePassIBLLightingRenderProgram, "PROGRAM_TYPE", 'SinglePassIBLLighting');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_BLEND_GI_PROBES", '_blend_gi_probes');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_PREF_ENV_MAP_SRC", '_prefEnvMap');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_WGIPROBE_SRC", '_wGIProbe');

_defineProperty(SinglePassIBLLightingRenderProgram, "S_SH_COEFFS_SRC", "_ShCoeffs");

/***/ }),

/***/ 6148:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _DirectionalLight = _interopRequireDefault(__webpack_require__(7539));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 在单个pass中批量处理多个灯光。<br/>
 * @author Kkk
 * @date 2021年2月17日16点09分
 * @update 2021年8月28日20点24分
 */
var SinglePassLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(SinglePassLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(SinglePassLightingRenderProgram);

  function SinglePassLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, SinglePassLightingRenderProgram);

    _this = _super.call(this, props);
    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 不使用SRC_ALPHA，ONE的原因在于，如果第一个光源是point或spot，则会导致累计光源渲染一个DirLight时，对于材质半透明的物体会出现累加错误的情况，因为混合了alpha


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['ONE', 'ONE']);

    return _this;
  }
  /**
   *
   * @param gl
   * @param scene
   * @param {FrameContext}[frameContext]
   * @param lights
   * @param batchSize
   * @param lastIndex
   * @private
   */


  _createClass(SinglePassLightingRenderProgram, [{
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex) {
      var conVars = frameContext.m_LastSubShader.getContextVars();

      if (conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
        if (lastIndex == 0) {
          // 提交合计的ambientColor(场景可能添加多个ambientLight)
          // 也可以设计为场景只能存在一个ambientColor
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        } else {
          // 开启累积缓存模式
          // 我们使用result = s * 1.0 + d * 1.0
          // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
          gl.uniform3f(conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        }
      }

      var lightSpaceLoc = null;
      var lightSpace = null;

      if (conVars[SinglePassLightingRenderProgram.S_V_LIGHT_DATA] != null) {
        lightSpace = 1;
        lightSpaceLoc = conVars[SinglePassLightingRenderProgram.S_V_LIGHT_DATA].loc;
      } else if (conVars[SinglePassLightingRenderProgram.S_W_LIGHT_DATA] != null) {
        lightSpace = 0;
        lightSpaceLoc = conVars[SinglePassLightingRenderProgram.S_W_LIGHT_DATA].loc;
      } // 计算实际需要上载的灯光


      var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;

      if (lightSpaceLoc == null) {
        return curLightCount + lastIndex;
      }

      var light = null;
      var lightColor = null; // 灯光数据

      var lightData = _TempVars.default.S_LIGHT_DATA;
      var array = lightData.getArray();
      var tempVec4 = _TempVars.default.S_TEMP_VEC4;
      var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
      // 数据编码格式内容
      // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

      for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
        light = lights[i];
        lightColor = light.getColor();
        array[offset] = lightColor._m_X;
        array[offset + 1] = lightColor._m_Y;
        array[offset + 2] = lightColor._m_Z;
        array[offset + 3] = light.getTypeId();

        switch (light.getType()) {
          case 'DirectionalLight':
            // 提交灯光方向
            if (lightSpace) {
              // 在视图空间计算光源,避免在片段着色阶段计算viewDir
              tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

              _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

              array[offset + 4] = tempVec4._m_X;
              array[offset + 5] = tempVec4._m_Y;
              array[offset + 6] = tempVec4._m_Z;
              array[offset + 7] = -1;
            } else {
              // 在世界空间计算光源
              array[offset + 4] = light.getDirection()._m_X;
              array[offset + 5] = light.getDirection()._m_Y;
              array[offset + 6] = light.getDirection()._m_Z;
              array[offset + 7] = -1;
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;

          case 'PointLight':
            if (lightSpace) {// view空间
            } else {
              // 世界空间
              array[offset + 4] = light.getPosition()._m_X;
              array[offset + 5] = light.getPosition()._m_Y;
              array[offset + 6] = light.getPosition()._m_Z;
              array[offset + 7] = light.getInRadius();
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;

          case 'SpotLight':
            if (lightSpace) {} else {
              // 世界空间
              array[offset + 4] = light.getPosition()._m_X;
              array[offset + 5] = light.getPosition()._m_Y;
              array[offset + 6] = light.getPosition()._m_Z;
              array[offset + 7] = light.getInvSpotRange();
            } // 提交spotDir其他信息


            array[offset + 8] = light.getDirection()._m_X;
            array[offset + 9] = light.getDirection()._m_Y;
            array[offset + 10] = light.getDirection()._m_Z;
            array[offset + 11] = light.getPackedAngleCos();
            break;
        }
      } // 上载数据
      // gl[conVars[SinglePassLightingRenderProgram.S_LIGHT_DATA].fun]


      gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);
      if (conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
      return curLightCount + lastIndex;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();

        if (conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawable.draw(frameContext);
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过batchSize


      var batchSize = scene.getRender().getBatchLightSize();
      var lastIndex = 0;

      while (lastIndex < lights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex); // 最后draw

        iDrawable.draw(frameContext);
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights) {
      // 如果灯光数量为0,则直接执行渲染
      if (lights.length == 0) {
        var conVars = frameContext.m_LastSubShader.getContextVars();

        if (conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[SinglePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        }

        if (conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[SinglePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
        return;
      } // 计算灯光是否处于iDrawable可见范围
      // 批量提交灯光
      // 应该根据引擎获取每次提交的灯光批次数量
      // 但是每个批次不应该超过batchSize


      var batchSize = scene.getRender().getBatchLightSize();
      var lastIndex = 0;
      frameContext.getRenderState().store();

      while (lastIndex < lights.length) {
        // 更新灯光信息
        lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex); // 最后draw

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());

      frameContext.BatchLightLastIndex = lastIndex;
    }
  }]);

  return SinglePassLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = SinglePassLightingRenderProgram;

_defineProperty(SinglePassLightingRenderProgram, "PROGRAM_TYPE", 'SinglePassLighting');

_defineProperty(SinglePassLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(SinglePassLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(SinglePassLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(SinglePassLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

/***/ }),

/***/ 2987:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

var _Texture2DVars = _interopRequireDefault(__webpack_require__(5141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * TilePassIBLLightingRenderProgram。<br/>
 * @author Kkk
 * @date 2021年9月10日10点14分
 */
var TilePassIBLLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(TilePassIBLLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(TilePassIBLLightingRenderProgram);

  // Global
  // Tile
  // Tile中ppx编码的光源检索
  // Tile中ppx编码的光源id
  // Tile中采样偏移大小
  // Tile中光源编码信息0
  // Tile中光源编码信息1
  // Tile中光源编码信息2
  // IBL
  // 分块信息
  // 光源索引
  // 光源编码数据
  // 光源编码数据纹理(rgb)
  // 光源索引数据纹理(后续改为rgba,rgb存储光源spotLight第三部分信息)
  // 临时变量
  function TilePassIBLLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, TilePassIBLLightingRenderProgram);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_m_Tiles", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsIndex", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsDecode", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsDecodeData", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsIndexData", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData0", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData1", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData2", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData0Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData1Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData2Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_PV", null);

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec3", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_2", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_3", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Center", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortWidth", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortHeight", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamLeftCoeff", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamTopCoeff", -1);

    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 不使用SRC_ALPHA，ONE的原因在于，如果第一个光源是point或spot，则会导致累计光源渲染一个DirLight时，对于材质半透明的物体会出现累加错误的情况，因为混合了alpha


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['ONE', 'ONE']);

    return _this;
  }
  /**
   * 混合GI探头信息。<br/>
   * 暂时仅仅只是提交单个探头信息。<br/>
   * @param {WebGL}[gl]
   * @param {Scene}[scene]
   * @param {FrameContext}[frameContext]
   * @private
   */


  _createClass(TilePassIBLLightingRenderProgram, [{
    key: "_blendGIProbes",
    value: function _blendGIProbes(gl, scene, frameContext) {
      var conVars = frameContext.m_LastSubShader.getContextVars(); // 探头信息

      var probeLoc = null;

      if (conVars[TilePassIBLLightingRenderProgram.S_WGIPROBE_SRC] != null) {
        if (this._m_m_LastSubShader != frameContext.m_LastSubShader) {
          // 提取相交的探头
          // 并更新探头数据进行混合渲染(但这里未实现,先记录下)
          // Log.log('提交探头!');
          var giProbe = scene.getGIProbes()[0];
          var giData = _TempVars.default.S_TEMP_VEC4; // 探头位置

          giData.setToInXYZW(giProbe.getPosition()._m_X, giProbe.getPosition()._m_Y, giProbe.getPosition()._m_Z, 1.0 / giProbe.getRadius() + giProbe.getPrefilterMipmap());
          gl.uniform4fv(conVars[TilePassIBLLightingRenderProgram.S_WGIPROBE_SRC].loc, giData.getBufferData(), 0, 4); // 球谐系数

          giData = giProbe.getShCoeffsBufferData();
          if (conVars[TilePassIBLLightingRenderProgram.S_SH_COEFFS_SRC] != null) gl.uniform3fv(conVars[TilePassIBLLightingRenderProgram.S_SH_COEFFS_SRC].loc, giData.getBufferData(), 0, 9 * 3); // prefilterEnvMap

          if (conVars[TilePassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC] != null) giProbe.getPrefilterEnvMap()._upload(gl, conVars[TilePassIBLLightingRenderProgram.S_PREF_ENV_MAP_SRC].loc);
          this._m_m_LastSubShader = frameContext.m_LastSubShader;
        } else {// 说明提交过探头数据
          // 这里,检测已经提交的探头数据,然后分析是否与之相交,否则关闭探头数据,避免错误的渲染和额外的渲染
        }
      } else {
        // 检测探头
        var giProbes = scene.getGIProbes();

        if (giProbes && giProbes.length > 0) {
          // 找出与之相交的探头
          // 首次,更新材质定义
          frameContext.m_LastMaterial.addDefine(_ShaderSource.default.S_GIPROBES_SRC, true);
        }
      }
    }
    /**
     * 创建纹理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[i]
     * @param {Number}[f]
     * @param {Number}[t]
     * @return {Texture2DVars}
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(scene, i, f, t) {
      var tex = new _Texture2DVars.default(scene);
      var gl = scene.getCanvas().getGLContext();
      tex.setTextureFormat(i, f, t);
      tex.setWrap(scene, _Texture2DVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _Texture2DVars.default.S_WRAPS.S_CLAMP_TO_EDGE);
      tex.setFilter(scene, _Texture2DVars.default.S_FILTERS.S_NEAREST, _Texture2DVars.default.S_FILTERS.S_NEAREST);
      tex.updateTextureFilter(); // 我们不需要读回主存,所以不需要进行对齐

      tex.setAlignment(1);
      return tex;
    }
  }, {
    key: "_reset",
    value: function _reset(gl, scene, tileNum) {
      if (!this._m_LightsIndexData) {
        this._m_LightsIndexData = this._createTexture(scene, gl.RGB32F, gl.RGB, gl.FLOAT);
      }

      if (!this._m_LightsDecodeData) {
        this._m_LightsDecodeData = this._createTexture(scene, gl.RGB32F, gl.RGB, gl.FLOAT);
      }

      if (!this._m_LightsData0) {
        this._m_LightsData0 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData0Array.length = 0;

      if (!this._m_LightsData1) {
        this._m_LightsData1 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData1Array.length = 0;

      if (!this._m_LightsData2) {
        this._m_LightsData2 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData2Array.length = 0; // 每个tile保存对应的光源信息

      for (var i = 0; i < tileNum; i++) {
        this._m_Tiles[i] = [];
      }

      this._m_LightsDecode.length = 0;
      this._m_LightsIndex.length = 0;
    }
    /**
     * 光锥裁剪。<br/>
     * @param {GLContext}[gl]
     * @param {Light}[light 只能是PointLight或SpotLight]
     * @return {Object}[返回光锥范围]
     */

  }, {
    key: "_lightClip",
    value: function _lightClip(gl, light) {
      var bounding = light.getBoundingVolume();
      var r = bounding.getRadius();
      var lr = r * this._m_CamLeftCoeff;
      var tr = r * this._m_CamTopCoeff;
      var center = bounding.getCenter(this._m_Temp_Vec3);
      center = this._m_Temp_Vec4.setToInXYZW(center._m_X, center._m_Y, center._m_Z, 1.0);
      this._m_Temp_Vec4._m_W = 1.0;
      this._m_Temp_Vec4_2._m_W = 1.0;
      this._m_Temp_Vec4_3._m_W = 1.0;

      var lightFrustumLeft = this._m_Cam_Left.multLength(lr, this._m_Temp_Vec4_2).add(center);

      var lightFrustumUp = this._m_Cam_Up.multLength(tr, this._m_Temp_Vec4_3).add(center);

      _Matrix.default.multiplyMV(this._m_Light_Left, lightFrustumLeft, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Up, lightFrustumUp, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Center, center, this._m_PV);

      this._m_Light_Left._m_X /= this._m_Light_Left._m_W;
      this._m_Light_Left._m_Y /= this._m_Light_Left._m_W;
      this._m_Light_Up._m_X /= this._m_Light_Up._m_W;
      this._m_Light_Up._m_Y /= this._m_Light_Up._m_W;
      this._m_Light_Center._m_X /= this._m_Light_Center._m_W;
      this._m_Light_Center._m_Y /= this._m_Light_Center._m_W;
      this._m_Light_Left._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Left._m_X);
      this._m_Light_Up._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Up._m_X);
      this._m_Light_Center._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Center._m_X);
      this._m_Light_Left._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Left._m_Y);
      this._m_Light_Up._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Up._m_Y);
      this._m_Light_Center._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Center._m_Y); // 计算光锥裁剪区
      // 视口映射后原点在左上角

      var lw = Math.abs(this._m_Light_Left._m_X - this._m_Light_Center._m_X);
      var lh = Math.abs(this._m_Light_Center._m_Y - this._m_Light_Up._m_Y);
      var left = -1,
          btm = -1;

      if (this._m_Light_Center._m_Z < -this._m_Light_Center._m_W) {
        left = -this._m_Light_Center._m_X - lw;
        btm = -this._m_Light_Center._m_Y + lh;
      } else {
        left = this._m_Light_Center._m_X - lw;
        btm = this._m_Light_Center._m_Y + lh;
      }

      var bottom = this._m_ViewPortHeight * 2.0 - btm; // 这里可以简化计算的,不过呢,这并不影响多少性能

      return {
        left: left,
        right: lw * 2 + left,
        top: lh * 2 + bottom,
        bottom: bottom
      };
    }
    /**
     * 分块索引。<br/>
     * @param {Number}[tileSize]
     * @param {Number}[tileWidth]
     * @param {Number}[tileHeight]
     * @param {Number}[tileNum]
     * @param {Array[][]}[tiles]
     * @param {Object}[lightFrustum]
     * @param {Number}[lightId]
     * @private
     */

  }, {
    key: "_tile",
    value: function _tile(tileSize, tileWidth, tileHeight, tileNum, tiles, lightFrustum, lightId) {
      // tile建立于
      //⬆
      //|
      //|
      //----------➡
      // 所以按照pixel屏幕精度,使用右上步进
      var tileLeft = Math.max(Math.floor(lightFrustum.left / tileSize), 0);
      var tileRight = Math.min(Math.ceil(lightFrustum.right / tileSize), tileWidth);
      var tileBottom = Math.max(Math.floor(lightFrustum.bottom / tileSize), 0);
      var tileTop = Math.min(Math.ceil(lightFrustum.top / tileSize), tileHeight); // 分块

      var tileId = 0;

      for (var l = tileLeft; l < tileRight; l++) {
        for (var b = tileBottom; b < tileTop; b++) {
          tileId = l + b * tileWidth;

          if (tileId >= 0 && tileId < tileNum) {
            tiles[tileId].push(lightId);
          }
        }
      }
    }
    /**
     * 上载tile信息。<br/>
     * @param gl
     * @param frameContext
     * @param tileNum
     * @param tiles
     * @param tileWidth
     * @param tileHeight
     * @param lights
     * @return {number}
     * @private
     */

  }, {
    key: "_tileLightDecode",
    value: function _tileLightDecode(gl, frameContext, tileNum, tiles, tileWidth, tileHeight, lights) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var len = -1;
      len = lights.length;
      var lightSpace = null;

      if (conVars[TilePassIBLLightingRenderProgram.S_LIGHT_NUM_SRC] != undefined) {
        gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_LIGHT_NUM_SRC].loc, len);
      }

      if (conVars[TilePassIBLLightingRenderProgram.S_TILE_V_LIGHT_DATA_0] != undefined) {
        lightSpace = 1;
      } else if (conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] != undefined) {
        lightSpace = 0;
      } else {
        // 返回0表示不需要渲染
        return 0;
      }

      for (var i = 0, offset = 0, tile = null; i < tileNum; i++) {
        tile = tiles[i];
        len = tile.length;

        for (var l = 0; l < len; l++) {
          this._m_LightsIndex.push(tile[l]);

          this._m_LightsIndex.push(0);

          this._m_LightsIndex.push(0);
        } // u偏移


        this._m_LightsDecode.push(offset); // tile对应的光源数目


        this._m_LightsDecode.push(len); // 下个环节补充


        this._m_LightsDecode.push(-1);

        offset += len;
      } // 计算光源采样尺寸


      var lightIndexWidth = Math.ceil(Math.sqrt(this._m_LightsIndex.length / 3));

      if (conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_OFFSET_SIZE] != undefined) {
        gl.uniform1f(conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_OFFSET_SIZE].loc, lightIndexWidth);
      } // 填充占位


      for (var _i = this._m_LightsIndex.length, _len = lightIndexWidth * lightIndexWidth * 3; _i < _len; _i++) {
        this._m_LightsIndex.push(-1);
      } // uv一维化


      for (var _i2 = 0, _len2 = this._m_LightsDecode.length; _i2 < _len2; _i2 += 3) {
        // g分量存储v偏移
        this._m_LightsDecode[_i2 + 2] = this._m_LightsDecode[_i2] / lightIndexWidth; // r分量存储u偏移

        this._m_LightsDecode[_i2] %= lightIndexWidth;
      } // 编码光源信息
      // lightIndexData
      // let lightIndexDataVec3 = [];
      // for(let i = 0,len = this._m_LightsIndex.length;i < len;i++){
      //     lightIndexDataVec3[i * 3] = this._m_LightsIndex[i];
      //     lightIndexDataVec3[i * 3 + 1] = 0;
      //     lightIndexDataVec3[i * 3 + 2] = 0;
      // }
      // this._m_LightsIndex = lightIndexDataVec3;


      if (conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_DECODE_SRC] != undefined) {
        this._m_LightsDecodeData.uploadArrayData(conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_DECODE_SRC].loc, tileWidth, tileHeight, new Float32Array(this._m_LightsDecode));
      }

      if (conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_INDEX_SRC] != undefined) {
        this._m_LightsIndexData.uploadArrayData(conVars[TilePassIBLLightingRenderProgram.S_TILE_LIGHT_INDEX_SRC].loc, lightIndexWidth, lightIndexWidth, new Float32Array(this._m_LightsIndex));
      } // lightsData0,1,2


      var light = null;
      var lightColor = null;
      len = lights.length;

      for (var _i3 = 0; _i3 < len; _i3++) {
        light = lights[_i3];
        lightColor = light.getColor();

        this._m_LightsData0Array.push(lightColor._m_X);

        this._m_LightsData0Array.push(lightColor._m_Y);

        this._m_LightsData0Array.push(lightColor._m_Z);

        this._m_LightsData0Array.push(light.getTypeId());

        switch (light.getType()) {
          case 'PointLight':
            if (lightSpace) {} else {
              this._m_LightsData1Array.push(light.getPosition()._m_X);

              this._m_LightsData1Array.push(light.getPosition()._m_Y);

              this._m_LightsData1Array.push(light.getPosition()._m_Z);

              this._m_LightsData1Array.push(light.getInRadius());
            }

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            break;

          case 'SpotLight':
            if (lightSpace) {} else {
              this._m_LightsData1Array.push(light.getPosition()._m_X);

              this._m_LightsData1Array.push(light.getPosition()._m_Y);

              this._m_LightsData1Array.push(light.getPosition()._m_Z);

              this._m_LightsData1Array.push(light.getInvSpotRange());
            }

            this._m_LightsData2Array.push(light.getDirection()._m_X);

            this._m_LightsData2Array.push(light.getDirection()._m_Y);

            this._m_LightsData2Array.push(light.getDirection()._m_Z);

            this._m_LightsData2Array.push(light.getPackedAngleCos());

            break;
        }
      }

      var data = conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] ? conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] : conVars[TilePassIBLLightingRenderProgram.S_TILE_V_LIGHT_DATA_0];

      if (data) {
        // 上载lightData0
        this._m_LightsData0.uploadArrayData(data.loc, this._m_LightsData0Array.length / 4, 1, new Float32Array(this._m_LightsData0Array));
      }

      data = conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_1] ? conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_1] : conVars[TilePassIBLLightingRenderProgram.S_TILE_V_LIGHT_DATA_1];

      if (data) {
        // 上载lightData1
        this._m_LightsData1.uploadArrayData(data.loc, this._m_LightsData1Array.length / 4, 1, new Float32Array(this._m_LightsData1Array));
      }

      data = conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_2] ? conVars[TilePassIBLLightingRenderProgram.S_TILE_W_LIGHT_DATA_2] : conVars[TilePassIBLLightingRenderProgram.S_TILE_V_LIGHT_DATA_2];

      if (data) {
        // 上载lightData2
        this._m_LightsData2.uploadArrayData(data.loc, this._m_LightsData2Array.length / 4, 1, new Float32Array(this._m_LightsData2Array));
      } // 返回1表示渲染


      return 1;
    }
    /**
     *
     * @param gl
     * @param scene
     * @param {FrameContext}[frameContext]
     * @param lights
     * @param batchSize
     * @param lastIndex
     * @private
     */

  }, {
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, blendGiProbes) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var enableGI = scene.enableGIProbes();

      if (conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
        gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, blendGiProbes && enableGI);
      }

      if (conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
        if (lastIndex == 0) {
          // 提交合计的ambientColor(场景可能添加多个ambientLight)
          // 也可以设计为场景只能存在一个ambientColor
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        } else {
          // 开启累积缓存模式
          // 我们使用result = s * 1.0 + d * 1.0
          // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
          gl.uniform3f(conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        }
      } // 探头信息


      if (enableGI) this._blendGIProbes(gl, scene, frameContext); // 灯光信息

      var lightSpaceLoc = null;
      var lightSpace = null;

      if (conVars[TilePassIBLLightingRenderProgram.S_V_LIGHT_DATA] != null) {
        lightSpace = 1;
        lightSpaceLoc = conVars[TilePassIBLLightingRenderProgram.S_V_LIGHT_DATA].loc;
      } else if (conVars[TilePassIBLLightingRenderProgram.S_W_LIGHT_DATA] != null) {
        lightSpace = 0;
        lightSpaceLoc = conVars[TilePassIBLLightingRenderProgram.S_W_LIGHT_DATA].loc;
      } // 计算实际需要上载的灯光


      var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;

      if (lightSpaceLoc == null) {
        return curLightCount + lastIndex;
      }

      var light = null;
      var lightColor = null; // 灯光数据

      var lightData = _TempVars.default.S_LIGHT_DATA_4;
      var array = lightData.getArray();
      var tempVec4 = _TempVars.default.S_TEMP_VEC4;
      var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
      // 数据编码格式内容
      // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

      for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
        light = lights[i];
        lightColor = light.getColor();
        array[offset] = lightColor._m_X;
        array[offset + 1] = lightColor._m_Y;
        array[offset + 2] = lightColor._m_Z;
        array[offset + 3] = light.getTypeId();

        switch (light.getType()) {
          case 'DirectionalLight':
            // 提交灯光方向
            if (lightSpace) {
              // 在视图空间计算光源,避免在片段着色阶段计算viewDir
              tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

              _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

              array[offset + 4] = tempVec4._m_X;
              array[offset + 5] = tempVec4._m_Y;
              array[offset + 6] = tempVec4._m_Z;
              array[offset + 7] = -1;
            } else {
              // 在世界空间计算光源
              array[offset + 4] = light.getDirection()._m_X;
              array[offset + 5] = light.getDirection()._m_Y;
              array[offset + 6] = light.getDirection()._m_Z;
              array[offset + 7] = -1;
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;
        }
      } // 上载数据
      // gl[conVars[TilePassIBLLightingRenderProgram.S_LIGHT_DATA].fun]


      gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);
      if (conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
      return curLightCount + lastIndex;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights, pass) {
      frameContext.getRenderState().store();

      if (pass == 0) {
        // global shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          var conVars = frameContext.m_LastSubShader.getContextVars();
          var enableGI = scene.enableGIProbes();
          if (enableGI) this._blendGIProbes(gl, scene, frameContext);

          if (conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
            gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
          }

          if (conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          }

          if (conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
          iDrawable.draw(frameContext);
          return;
        }

        var batchSize = scene.getRender().getBatchLightSize();
        var lastIndex = 0;

        while (lastIndex < lights.length) {
          // 更新灯光信息
          lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lastIndex == 0); // 最后draw

          iDrawable.draw(frameContext);
        }
      } else if (pass == 1) {
        // tile based shading
        // scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          // 直接绘制即可
          // iDrawable.draw(frameContext);
          return;
        }

        var lightFrustum = null;
        var tileInfo = scene.getRender().getTileInfo();
        var tileSize = tileInfo.tileSize;
        var tileWidth = tileInfo.tileWidth;
        var tileHeight = tileInfo.tileHeight;
        var tileNum = tileInfo.tileNum;

        this._reset(gl, scene, tileNum);

        if (lights.length > 0) {
          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());

          this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
          this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
          this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
          var v = scene.getMainCamera().getViewMatrix();

          this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

          this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

          this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

          this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

          this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

          this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
        } // tile 检索


        for (var i = 0, len = lights.length; i < len; i++) {
          lightFrustum = this._lightClip(gl, lights[i]);

          if (lightFrustum) {
            this._tile(tileSize, tileWidth, tileHeight, tileNum, this._m_Tiles, lightFrustum, i);
          }
        } // 编码光源信息


        this._tileLightDecode(gl, frameContext, tileNum, this._m_Tiles, tileWidth, tileHeight, lights);

        iDrawable.draw(frameContext);
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights, pass) {
      frameContext.getRenderState().store();

      if (pass == 0) {
        // global shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          var conVars = frameContext.m_LastSubShader.getContextVars();
          var enableGI = scene.enableGIProbes();
          if (enableGI) this._blendGIProbes(gl, scene, frameContext);

          if (conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES] != undefined) {
            gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_BLEND_GI_PROBES].loc, enableGI);
          }

          if (conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[TilePassIBLLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          }

          if (conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassIBLLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
          return;
        }

        var batchSize = scene.getRender().getBatchLightSize();
        var lastIndex = 0;

        while (lastIndex < lights.length) {
          // 更新灯光信息
          lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex, lastIndex == 0); // 最后draw

          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
        }
      } else if (pass == 1) {
        // tile based shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          // 直接绘制即可
          // iDrawables.forEach(iDrawable=>{
          //     iDrawable.draw(frameContext);
          // });
          return;
        }

        var lightFrustum = null;
        var tileInfo = scene.getRender().getTileInfo();
        var tileSize = tileInfo.tileSize;
        var tileWidth = tileInfo.tileWidth;
        var tileHeight = tileInfo.tileHeight;
        var tileNum = tileInfo.tileNum;

        this._reset(gl, scene, tileNum);

        if (lights.length > 0) {
          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());

          this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
          this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
          this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
          var v = scene.getMainCamera().getViewMatrix();

          this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

          this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

          this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

          this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

          this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

          this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
        } // tile 检索


        for (var i = 0, len = lights.length; i < len; i++) {
          lightFrustum = this._lightClip(gl, lights[i]);

          if (lightFrustum) {
            this._tile(tileSize, tileWidth, tileHeight, tileNum, this._m_Tiles, lightFrustum, i);
          }
        } // 编码光源信息


        this._tileLightDecode(gl, frameContext, tileNum, this._m_Tiles, tileWidth, tileHeight, lights);

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }]);

  return TilePassIBLLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = TilePassIBLLightingRenderProgram;

_defineProperty(TilePassIBLLightingRenderProgram, "PROGRAM_TYPE", 'TilePassIBLLighting');

_defineProperty(TilePassIBLLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(TilePassIBLLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(TilePassIBLLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(TilePassIBLLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

_defineProperty(TilePassIBLLightingRenderProgram, "S_LIGHT_NUM_SRC", "_lightNum");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_LIGHT_DECODE_SRC", "_tileLightDecode");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_LIGHT_INDEX_SRC", "_tileLightIndex");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_LIGHT_OFFSET_SIZE", "_tileLightOffsetSize");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_W_LIGHT_DATA_0", "_tileWLightData0");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_V_LIGHT_DATA_0", "_tileVLightData0");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_W_LIGHT_DATA_1", "_tileWLightData1");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_V_LIGHT_DATA_1", "_tileVLightData1");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_W_LIGHT_DATA_2", "_tileWLightData2");

_defineProperty(TilePassIBLLightingRenderProgram, "S_TILE_V_LIGHT_DATA_2", "_tileVLightData2");

_defineProperty(TilePassIBLLightingRenderProgram, "S_PREF_ENV_MAP_SRC", '_prefEnvMap');

_defineProperty(TilePassIBLLightingRenderProgram, "S_WGIPROBE_SRC", '_wGIProbe');

_defineProperty(TilePassIBLLightingRenderProgram, "S_SH_COEFFS_SRC", "_ShCoeffs");

_defineProperty(TilePassIBLLightingRenderProgram, "S_BLEND_GI_PROBES", '_blend_gi_probes');

/***/ }),

/***/ 2390:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DefaultRenderProgram2 = _interopRequireDefault(__webpack_require__(1393));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

var _Texture2DVars = _interopRequireDefault(__webpack_require__(5141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * TilePassLightingRenderProgram。<br/>
 * @author Kkk
 * @date 2021年9月8日16点43分
 */
var TilePassLightingRenderProgram = /*#__PURE__*/function (_DefaultRenderProgram) {
  _inherits(TilePassLightingRenderProgram, _DefaultRenderProgram);

  var _super = _createSuper(TilePassLightingRenderProgram);

  // Global
  // Tile
  // Tile中ppx编码的光源检索
  // Tile中ppx编码的光源id
  // Tile中采样偏移大小
  // Tile中光源编码信息0
  // Tile中光源编码信息1
  // Tile中光源编码信息2
  // 分块信息
  // 光源索引
  // 光源编码数据
  // 光源编码数据纹理(rgb)
  // 光源索引数据纹理(后续改为rgba,rgb存储光源spotLight第三部分信息)
  // 临时变量
  function TilePassLightingRenderProgram(props) {
    var _this;

    _classCallCheck(this, TilePassLightingRenderProgram);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_m_Tiles", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsIndex", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsDecode", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsDecodeData", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsIndexData", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData0", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData1", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData2", null);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData0Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData1Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_LightsData2Array", []);

    _defineProperty(_assertThisInitialized(_this), "_m_PV", null);

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec3", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_2", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Temp_Vec4_3", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Cam_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Left", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Up", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Light_Center", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortWidth", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_ViewPortHeight", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamLeftCoeff", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_CamTopCoeff", -1);

    _this._m_AccumulationLights = new _RenderState.default();

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[4], 'On');

    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[1], 'Off'); // 不使用SRC_ALPHA，ONE的原因在于，如果第一个光源是point或spot，则会导致累计光源渲染一个DirLight时，对于材质半透明的物体会出现累加错误的情况，因为混合了alpha


    _this._m_AccumulationLights.setFlag(_RenderState.default.S_STATES[5], ['ONE', 'ONE']);

    return _this;
  }
  /**
   * 创建纹理。<br/>
   * @param {Scene}[scene]
   * @param {Number}[i]
   * @param {Number}[f]
   * @param {Number}[t]
   * @return {Texture2DVars}
   * @private
   */


  _createClass(TilePassLightingRenderProgram, [{
    key: "_createTexture",
    value: function _createTexture(scene, i, f, t) {
      var tex = new _Texture2DVars.default(scene);
      var gl = scene.getCanvas().getGLContext();
      tex.setTextureFormat(i, f, t);
      tex.setWrap(scene, _Texture2DVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _Texture2DVars.default.S_WRAPS.S_CLAMP_TO_EDGE);
      tex.setFilter(scene, _Texture2DVars.default.S_FILTERS.S_NEAREST, _Texture2DVars.default.S_FILTERS.S_NEAREST);
      tex.updateTextureFilter(); // 我们不需要读回主存,所以不需要进行对齐

      tex.setAlignment(1);
      return tex;
    }
  }, {
    key: "_reset",
    value: function _reset(gl, scene, tileNum) {
      if (!this._m_LightsIndexData) {
        this._m_LightsIndexData = this._createTexture(scene, gl.RGB32F, gl.RGB, gl.FLOAT);
      }

      if (!this._m_LightsDecodeData) {
        this._m_LightsDecodeData = this._createTexture(scene, gl.RGB32F, gl.RGB, gl.FLOAT);
      }

      if (!this._m_LightsData0) {
        this._m_LightsData0 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData0Array.length = 0;

      if (!this._m_LightsData1) {
        this._m_LightsData1 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData1Array.length = 0;

      if (!this._m_LightsData2) {
        this._m_LightsData2 = this._createTexture(scene, gl.RGBA32F, gl.RGBA, gl.FLOAT);
      }

      this._m_LightsData2Array.length = 0; // 每个tile保存对应的光源信息

      for (var i = 0; i < tileNum; i++) {
        this._m_Tiles[i] = [];
      }

      this._m_LightsDecode.length = 0;
      this._m_LightsIndex.length = 0;
    }
    /**
     * 光锥裁剪。<br/>
     * @param {GLContext}[gl]
     * @param {Light}[light 只能是PointLight或SpotLight]
     * @return {Object}[返回光锥范围]
     */

  }, {
    key: "_lightClip",
    value: function _lightClip(gl, light) {
      var bounding = light.getBoundingVolume();
      var r = bounding.getRadius();
      var lr = r * this._m_CamLeftCoeff;
      var tr = r * this._m_CamTopCoeff;
      var center = bounding.getCenter(this._m_Temp_Vec3);
      center = this._m_Temp_Vec4.setToInXYZW(center._m_X, center._m_Y, center._m_Z, 1.0);
      this._m_Temp_Vec4._m_W = 1.0;
      this._m_Temp_Vec4_2._m_W = 1.0;
      this._m_Temp_Vec4_3._m_W = 1.0;

      var lightFrustumLeft = this._m_Cam_Left.multLength(lr, this._m_Temp_Vec4_2).add(center);

      var lightFrustumUp = this._m_Cam_Up.multLength(tr, this._m_Temp_Vec4_3).add(center);

      _Matrix.default.multiplyMV(this._m_Light_Left, lightFrustumLeft, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Up, lightFrustumUp, this._m_PV);

      _Matrix.default.multiplyMV(this._m_Light_Center, center, this._m_PV);

      this._m_Light_Left._m_X /= this._m_Light_Left._m_W;
      this._m_Light_Left._m_Y /= this._m_Light_Left._m_W;
      this._m_Light_Up._m_X /= this._m_Light_Up._m_W;
      this._m_Light_Up._m_Y /= this._m_Light_Up._m_W;
      this._m_Light_Center._m_X /= this._m_Light_Center._m_W;
      this._m_Light_Center._m_Y /= this._m_Light_Center._m_W;
      this._m_Light_Left._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Left._m_X);
      this._m_Light_Up._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Up._m_X);
      this._m_Light_Center._m_X = this._m_ViewPortWidth * (1.0 + this._m_Light_Center._m_X);
      this._m_Light_Left._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Left._m_Y);
      this._m_Light_Up._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Up._m_Y);
      this._m_Light_Center._m_Y = this._m_ViewPortHeight * (1.0 - this._m_Light_Center._m_Y); // 计算光锥裁剪区
      // 视口映射后原点在左上角

      var lw = Math.abs(this._m_Light_Left._m_X - this._m_Light_Center._m_X);
      var lh = Math.abs(this._m_Light_Center._m_Y - this._m_Light_Up._m_Y);
      var left = -1,
          btm = -1;

      if (this._m_Light_Center._m_Z < -this._m_Light_Center._m_W) {
        left = -this._m_Light_Center._m_X - lw;
        btm = -this._m_Light_Center._m_Y + lh;
      } else {
        left = this._m_Light_Center._m_X - lw;
        btm = this._m_Light_Center._m_Y + lh;
      }

      var bottom = this._m_ViewPortHeight * 2.0 - btm; // 这里可以简化计算的,不过呢,这并不影响多少性能

      return {
        left: left,
        right: lw * 2 + left,
        top: lh * 2 + bottom,
        bottom: bottom
      };
    }
    /**
     * 分块索引。<br/>
     * @param {Number}[tileSize]
     * @param {Number}[tileWidth]
     * @param {Number}[tileHeight]
     * @param {Number}[tileNum]
     * @param {Array[][]}[tiles]
     * @param {Object}[lightFrustum]
     * @param {Number}[lightId]
     * @private
     */

  }, {
    key: "_tile",
    value: function _tile(tileSize, tileWidth, tileHeight, tileNum, tiles, lightFrustum, lightId) {
      // tile建立于
      //⬆
      //|
      //|
      //----------➡
      // 所以按照pixel屏幕精度,使用右上步进
      var tileLeft = Math.max(Math.floor(lightFrustum.left / tileSize), 0);
      var tileRight = Math.min(Math.ceil(lightFrustum.right / tileSize), tileWidth);
      var tileBottom = Math.max(Math.floor(lightFrustum.bottom / tileSize), 0);
      var tileTop = Math.min(Math.ceil(lightFrustum.top / tileSize), tileHeight); // 分块

      var tileId = 0;

      for (var l = tileLeft; l < tileRight; l++) {
        for (var b = tileBottom; b < tileTop; b++) {
          tileId = l + b * tileWidth;

          if (tileId >= 0 && tileId < tileNum) {
            tiles[tileId].push(lightId);
          }
        }
      }
    }
  }, {
    key: "_tileLightDecode",
    value: function _tileLightDecode(gl, frameContext, tileNum, tiles, tileWidth, tileHeight, lights) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var len = -1;
      len = lights.length;
      var lightSpace = null;

      if (conVars[TilePassLightingRenderProgram.S_LIGHT_NUM_SRC] != undefined) {
        gl.uniform1i(conVars[TilePassLightingRenderProgram.S_LIGHT_NUM_SRC].loc, len);
      }

      if (conVars[TilePassLightingRenderProgram.S_TILE_V_LIGHT_DATA_0] != undefined) {
        lightSpace = 1;
      } else if (conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] != undefined) {
        lightSpace = 0;
      } else {
        // 返回0表示不需要渲染
        return 0;
      }

      for (var i = 0, offset = 0, tile = null; i < tileNum; i++) {
        tile = tiles[i];
        len = tile.length;

        for (var l = 0; l < len; l++) {
          this._m_LightsIndex.push(tile[l]);

          this._m_LightsIndex.push(0);

          this._m_LightsIndex.push(0);
        } // u偏移


        this._m_LightsDecode.push(offset); // tile对应的光源数目


        this._m_LightsDecode.push(len); // 下个环节补充


        this._m_LightsDecode.push(-1);

        offset += len;
      } // 计算光源采样尺寸


      var lightIndexWidth = Math.ceil(Math.sqrt(this._m_LightsIndex.length / 3));

      if (conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_OFFSET_SIZE] != undefined) {
        gl.uniform1f(conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_OFFSET_SIZE].loc, lightIndexWidth);
      } // 填充占位


      for (var _i = this._m_LightsIndex.length, _len = lightIndexWidth * lightIndexWidth * 3; _i < _len; _i++) {
        this._m_LightsIndex.push(-1);
      } // uv一维化


      for (var _i2 = 0, _len2 = this._m_LightsDecode.length; _i2 < _len2; _i2 += 3) {
        // g分量存储v偏移
        this._m_LightsDecode[_i2 + 2] = this._m_LightsDecode[_i2] / lightIndexWidth; // r分量存储u偏移

        this._m_LightsDecode[_i2] %= lightIndexWidth;
      } // 编码光源信息
      // lightIndexData
      // let lightIndexDataVec3 = [];
      // for(let i = 0,len = this._m_LightsIndex.length;i < len;i++){
      //     lightIndexDataVec3[i * 3] = this._m_LightsIndex[i];
      //     lightIndexDataVec3[i * 3 + 1] = 0;
      //     lightIndexDataVec3[i * 3 + 2] = 0;
      // }
      // this._m_LightsIndex = lightIndexDataVec3;


      if (conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_DECODE_SRC] != undefined) {
        this._m_LightsDecodeData.uploadArrayData(conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_DECODE_SRC].loc, tileWidth, tileHeight, new Float32Array(this._m_LightsDecode));
      }

      if (conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_INDEX_SRC] != undefined) {
        this._m_LightsIndexData.uploadArrayData(conVars[TilePassLightingRenderProgram.S_TILE_LIGHT_INDEX_SRC].loc, lightIndexWidth, lightIndexWidth, new Float32Array(this._m_LightsIndex));
      } // lightsData0,1,2


      var light = null;
      var lightColor = null;
      len = lights.length;

      for (var _i3 = 0; _i3 < len; _i3++) {
        light = lights[_i3];
        lightColor = light.getColor();

        this._m_LightsData0Array.push(lightColor._m_X);

        this._m_LightsData0Array.push(lightColor._m_Y);

        this._m_LightsData0Array.push(lightColor._m_Z);

        this._m_LightsData0Array.push(light.getTypeId());

        switch (light.getType()) {
          case 'PointLight':
            if (lightSpace) {} else {
              this._m_LightsData1Array.push(light.getPosition()._m_X);

              this._m_LightsData1Array.push(light.getPosition()._m_Y);

              this._m_LightsData1Array.push(light.getPosition()._m_Z);

              this._m_LightsData1Array.push(light.getInRadius());
            }

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            this._m_LightsData2Array.push(0.0);

            break;

          case 'SpotLight':
            if (lightSpace) {} else {
              this._m_LightsData1Array.push(light.getPosition()._m_X);

              this._m_LightsData1Array.push(light.getPosition()._m_Y);

              this._m_LightsData1Array.push(light.getPosition()._m_Z);

              this._m_LightsData1Array.push(light.getInvSpotRange());
            }

            this._m_LightsData2Array.push(light.getDirection()._m_X);

            this._m_LightsData2Array.push(light.getDirection()._m_Y);

            this._m_LightsData2Array.push(light.getDirection()._m_Z);

            this._m_LightsData2Array.push(light.getPackedAngleCos());

            break;
        }
      }

      var data = conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] ? conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_0] : conVars[TilePassLightingRenderProgram.S_TILE_V_LIGHT_DATA_0];

      if (data) {
        // 上载lightData0
        this._m_LightsData0.uploadArrayData(data.loc, this._m_LightsData0Array.length / 4, 1, new Float32Array(this._m_LightsData0Array));
      }

      data = conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_1] ? conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_1] : conVars[TilePassLightingRenderProgram.S_TILE_V_LIGHT_DATA_1];

      if (data) {
        // 上载lightData1
        this._m_LightsData1.uploadArrayData(data.loc, this._m_LightsData1Array.length / 4, 1, new Float32Array(this._m_LightsData1Array));
      }

      data = conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_2] ? conVars[TilePassLightingRenderProgram.S_TILE_W_LIGHT_DATA_2] : conVars[TilePassLightingRenderProgram.S_TILE_V_LIGHT_DATA_2];

      if (data) {
        // 上载lightData2
        this._m_LightsData2.uploadArrayData(data.loc, this._m_LightsData2Array.length / 4, 1, new Float32Array(this._m_LightsData2Array));
      } // 返回1表示渲染


      return 1;
    }
    /**
     *
     * @param gl
     * @param scene
     * @param {FrameContext}[frameContext]
     * @param lights
     * @param batchSize
     * @param lastIndex
     * @private
     */

  }, {
    key: "_uploadLights",
    value: function _uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex) {
      var conVars = frameContext.m_LastSubShader.getContextVars();

      if (conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
        if (lastIndex == 0) {
          // 提交合计的ambientColor(场景可能添加多个ambientLight)
          // 也可以设计为场景只能存在一个ambientColor
          var ambientLightColor = scene.AmbientLightColor;
          gl.uniform3f(conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
        } else {
          // 开启累积缓存模式
          // 我们使用result = s * 1.0 + d * 1.0
          // 所以,渲染当前pass,s部分在当前混合下应该使用一个全黑的ambientLightColor(因为第一个pass已经计算了ambientLightColor)
          gl.uniform3f(conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, 0.0, 0.0, 0.0);

          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        }
      }

      var lightSpaceLoc = null;
      var lightSpace = null;

      if (conVars[TilePassLightingRenderProgram.S_V_LIGHT_DATA] != null) {
        lightSpace = 1;
        lightSpaceLoc = conVars[TilePassLightingRenderProgram.S_V_LIGHT_DATA].loc;
      } else if (conVars[TilePassLightingRenderProgram.S_W_LIGHT_DATA] != null) {
        lightSpace = 0;
        lightSpaceLoc = conVars[TilePassLightingRenderProgram.S_W_LIGHT_DATA].loc;
      } // 计算实际需要上载的灯光


      var curLightCount = batchSize + lastIndex > lights.length ? lights.length - lastIndex : batchSize;

      if (lightSpaceLoc == null) {
        return curLightCount + lastIndex;
      }

      var light = null;
      var lightColor = null; // 灯光数据

      var lightData = _TempVars.default.S_LIGHT_DATA;
      var array = lightData.getArray();
      var tempVec4 = _TempVars.default.S_TEMP_VEC4;
      var tempVec42 = _TempVars.default.S_TEMP_VEC4_2; // 上载灯光信息
      // 数据编码格式内容
      // 第一个元素保存光照颜色,w分量保存光照类型(0DirectionalLight,1PointLight,2SpotLight)

      for (var i = lastIndex, offset = 0, end = curLightCount + lastIndex; i < end; i++, offset += 12) {
        light = lights[i];
        lightColor = light.getColor();
        array[offset] = lightColor._m_X;
        array[offset + 1] = lightColor._m_Y;
        array[offset + 2] = lightColor._m_Z;
        array[offset + 3] = light.getTypeId();

        switch (light.getType()) {
          case 'DirectionalLight':
            // 提交灯光方向
            if (lightSpace) {
              // 在视图空间计算光源,避免在片段着色阶段计算viewDir
              tempVec42.setToInXYZW(light.getDirection()._m_X, light.getDirection()._m_Y, light.getDirection()._m_Z, 0);

              _Matrix.default.multiplyMV(tempVec4, tempVec42, scene.getMainCamera().getViewMatrix());

              array[offset + 4] = tempVec4._m_X;
              array[offset + 5] = tempVec4._m_Y;
              array[offset + 6] = tempVec4._m_Z;
              array[offset + 7] = -1;
            } else {
              // 在世界空间计算光源
              array[offset + 4] = light.getDirection()._m_X;
              array[offset + 5] = light.getDirection()._m_Y;
              array[offset + 6] = light.getDirection()._m_Z;
              array[offset + 7] = -1;
            } // 第三个数据占位(不要假设默认为0,因为重复使用这个缓存,所以最好主动填充0)


            array[offset + 8] = 0;
            array[offset + 9] = 0;
            array[offset + 10] = 0;
            array[offset + 11] = 0;
            break;
        }
      } // 上载数据
      // gl[conVars[TilePassLightingRenderProgram.S_LIGHT_DATA].fun]


      gl.uniform4fv(lightSpaceLoc, lightData.getBufferData(), 0, curLightCount * 12);
      if (conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, curLightCount * 3);
      return curLightCount + lastIndex;
    }
  }, {
    key: "draw",
    value: function draw(gl, scene, frameContext, iDrawable, lights, pass) {
      frameContext.getRenderState().store();

      if (pass == 0) {
        // global shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          var conVars = frameContext.m_LastSubShader.getContextVars();

          if (conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          }

          if (conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
          iDrawable.draw(frameContext);
          return;
        }

        var batchSize = scene.getRender().getBatchLightSize();
        var lastIndex = 0;

        while (lastIndex < lights.length) {
          // 更新灯光信息
          lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex); // 最后draw

          iDrawable.draw(frameContext);
        }
      } else if (pass == 1) {
        // tile based shading
        // scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          // 直接绘制即可
          // iDrawable.draw(frameContext);
          return;
        }

        var lightFrustum = null;
        var tileInfo = scene.getRender().getTileInfo();
        var tileSize = tileInfo.tileSize;
        var tileWidth = tileInfo.tileWidth;
        var tileHeight = tileInfo.tileHeight;
        var tileNum = tileInfo.tileNum;

        this._reset(gl, scene, tileNum);

        if (lights.length > 0) {
          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());

          this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
          this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
          this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
          var v = scene.getMainCamera().getViewMatrix();

          this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

          this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

          this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

          this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

          this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

          this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
        } // tile 检索


        for (var i = 0, len = lights.length; i < len; i++) {
          lightFrustum = this._lightClip(gl, lights[i]);

          if (lightFrustum) {
            this._tile(tileSize, tileWidth, tileHeight, tileNum, this._m_Tiles, lightFrustum, i);
          }
        } // 编码光源信息


        this._tileLightDecode(gl, frameContext, tileNum, this._m_Tiles, tileWidth, tileHeight, lights);

        iDrawable.draw(frameContext);
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }, {
    key: "drawArrays",
    value: function drawArrays(gl, scene, frameContext, iDrawables, lights, pass) {
      frameContext.getRenderState().store();

      if (pass == 0) {
        // global shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          var conVars = frameContext.m_LastSubShader.getContextVars();

          if (conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR] != null) {
            var ambientLightColor = scene.AmbientLightColor;
            gl.uniform3f(conVars[TilePassLightingRenderProgram.S_AMBIENT_LIGHT_COLOR].loc, ambientLightColor._m_X, ambientLightColor._m_Y, ambientLightColor._m_Z);
          }

          if (conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT] != null) gl.uniform1i(conVars[TilePassLightingRenderProgram.S_CUR_LIGHT_COUNT].loc, 0);
          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
          return;
        }

        var batchSize = scene.getRender().getBatchLightSize();
        var lastIndex = 0;

        while (lastIndex < lights.length) {
          // 更新灯光信息
          lastIndex = this._uploadLights(gl, scene, frameContext, lights, batchSize, lastIndex); // 最后draw

          iDrawables.forEach(function (iDrawable) {
            iDrawable.draw(frameContext);
          });
        }
      } else if (pass == 1) {
        // tile based shading
        // 如果灯光数量为0,则直接执行渲染
        if (lights.length == 0) {
          // 直接绘制即可
          // iDrawables.forEach(iDrawable=>{
          //     iDrawable.draw(frameContext);
          // });
          return;
        }

        var lightFrustum = null;
        var tileInfo = scene.getRender().getTileInfo();
        var tileSize = tileInfo.tileSize;
        var tileWidth = tileInfo.tileWidth;
        var tileHeight = tileInfo.tileHeight;
        var tileNum = tileInfo.tileNum;

        this._reset(gl, scene, tileNum);

        if (lights.length > 0) {
          scene.getRender()._checkRenderState(gl, this._m_AccumulationLights, frameContext.getRenderState());

          this._m_ViewPortWidth = scene.getMainCamera().getWidth() * 0.5;
          this._m_ViewPortHeight = scene.getMainCamera().getHeight() * 0.5;
          this._m_PV = scene.getMainCamera().getProjectViewMatrix(true);
          var v = scene.getMainCamera().getViewMatrix();

          this._m_Temp_Vec3.setToInXYZ(v.m[0], v.m[4], v.m[8]);

          this._m_CamLeftCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(1).getNormal().dot(this._m_Temp_Vec3);

          this._m_Temp_Vec3.setToInXYZ(v.m[1], v.m[5], v.m[9]);

          this._m_CamTopCoeff = 1.0 / scene.getMainCamera().getFrustumPlane(2).getNormal().dot(this._m_Temp_Vec3);

          this._m_Cam_Left.setToInXYZW(v.m[0], v.m[4], v.m[8], 1.0).multLength(-1);

          this._m_Cam_Up.setToInXYZW(v.m[1], v.m[5], v.m[9], 1.0);
        } // tile 检索


        for (var i = 0, len = lights.length; i < len; i++) {
          lightFrustum = this._lightClip(gl, lights[i]);

          if (lightFrustum) {
            this._tile(tileSize, tileWidth, tileHeight, tileNum, this._m_Tiles, lightFrustum, i);
          }
        } // 编码光源信息


        this._tileLightDecode(gl, frameContext, tileNum, this._m_Tiles, tileWidth, tileHeight, lights);

        iDrawables.forEach(function (iDrawable) {
          iDrawable.draw(frameContext);
        });
      }

      scene.getRender()._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }]);

  return TilePassLightingRenderProgram;
}(_DefaultRenderProgram2.default);

exports["default"] = TilePassLightingRenderProgram;

_defineProperty(TilePassLightingRenderProgram, "PROGRAM_TYPE", 'TilePassLighting');

_defineProperty(TilePassLightingRenderProgram, "S_CUR_LIGHT_COUNT", '_curLightCount');

_defineProperty(TilePassLightingRenderProgram, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(TilePassLightingRenderProgram, "S_V_LIGHT_DATA", '_vLightData');

_defineProperty(TilePassLightingRenderProgram, "S_W_LIGHT_DATA", '_wLightData');

_defineProperty(TilePassLightingRenderProgram, "S_LIGHT_NUM_SRC", "_lightNum");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_LIGHT_DECODE_SRC", "_tileLightDecode");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_LIGHT_INDEX_SRC", "_tileLightIndex");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_LIGHT_OFFSET_SIZE", "_tileLightOffsetSize");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_W_LIGHT_DATA_0", "_tileWLightData0");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_V_LIGHT_DATA_0", "_tileVLightData0");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_W_LIGHT_DATA_1", "_tileWLightData1");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_V_LIGHT_DATA_1", "_tileVLightData1");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_W_LIGHT_DATA_2", "_tileWLightData2");

_defineProperty(TilePassLightingRenderProgram, "S_TILE_V_LIGHT_DATA_2", "_tileVLightData2");

/***/ }),

/***/ 3061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _FrameContext = _interopRequireDefault(__webpack_require__(6798));

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _FrameBuffer = _interopRequireDefault(__webpack_require__(7341));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _DefaultRenderProgram = _interopRequireDefault(__webpack_require__(1393));

var _SinglePassLightingRenderProgram = _interopRequireDefault(__webpack_require__(6148));

var _SinglePassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(8546));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _RenderQueue = _interopRequireDefault(__webpack_require__(9510));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Forward = _interopRequireDefault(__webpack_require__(5734));

var _Deferred = _interopRequireDefault(__webpack_require__(870));

var _MultiPassLightingRenderProgram = _interopRequireDefault(__webpack_require__(4658));

var _MultiPassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(8388));

var _TilePassLightingRenderProgram = _interopRequireDefault(__webpack_require__(2390));

var _TileDeferred = _interopRequireDefault(__webpack_require__(6987));

var _TilePassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(2987));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

var _BoolVars = _interopRequireDefault(__webpack_require__(1491));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Render = /*#__PURE__*/function (_Component) {
  _inherits(Render, _Component);

  var _super = _createSuper(Render);

  function Render(owner, cfg) {
    var _this;

    _classCallCheck(this, Render);

    _this = _super.call(this, owner, cfg); // 保存所有需要渲染的元素

    _this._m_Drawables = [];
    _this._m_DrawableIDs = {}; // 缓存当前帧渲染数据

    _this._m_VisDrawables = []; // 保存所有FramePicture对象

    _this._m_FramePictures = [];
    _this._m_FramePictureIDs = []; // sky(每次只能渲染一个sky,因为没有必要存在多个sky)

    _this._m_Sky = null; // 渲染模式
    // 默认下,0为forward,1为deferred

    _this._m_Pipeline = {};
    _this._m_PipelineConfig = {}; // renderProgram优先技术

    _this._m_PriorityTechnology = ''; // PostFilterPipeline

    _this._m_PostFilterSwap = 0;
    _this._m_PostFilterPipelineSwap = []; // 帧上下文

    _this._m_FrameContext = new _FrameContext.default(); // 所有可用渲染程序

    _this._m_RenderPrograms = {}; // 不透明队列的默认渲染状态

    _this._m_OpaqueRenderState = new _RenderState.default(); // 半透明队列的默认渲染状态

    _this._m_TranslucentRenderState = new _RenderState.default(); // 开启blend模式

    _this._m_TranslucentRenderState.setFlag(_RenderState.default.S_STATES[4], 'On'); // 关闭深度写入(不建议默认设置,因为对于大部分情况,都需要开启深度写入,以避免同一个物体前后交叉而没有深度写入导致错误情况产生,但可以通过具体材质进行控制)
    // this._m_TranslucentRenderState.setFlag(RenderState.S_STATES[1], 'Off');
    // 设置默认blend方程(默认方程)


    _this._m_TranslucentRenderState.setFlag(_RenderState.default.S_STATES[5], ['SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA']); // 一些杂项
    // singlePass batchLightSize 默认为4


    _this._m_BatchLightSize = 4; // gamma矫正

    _this._m_GammaCorrection = true; // gamma编码因子

    _this._m_GammaFactor = 0.45; // 色调映射

    _this._m_ToneMapping = false; // Tile

    _this._m_TileInfo = {
      tileSize: 0,
      tileWidth: 0,
      tileHeight: 0,
      tileNum: 0
    };

    _this._m_Scene.getCanvas().on('resize', function (w, h) {
      _this.updateTileInfo(w, h);
    });

    _this.setTileSize(32);

    return _this;
  }
  /**
   * 更新tileInfo。<br/>
   * @param {Number}[w 视口宽度]
   * @param {Number}[h 视口高度]
   */


  _createClass(Render, [{
    key: "getType",
    value: // 渲染路径
    // 默认延迟着色渲染路径frameBuffer
    // 如果启用了多渲染路径,则创建默认forwardFrameBuffer而不是使用内置frameBuffer(这是因为webGL不支持从多fbo.blit到内置fbo)
    // 用于FilterPipeline
    // 交换缓冲
    // Event
    // 一帧渲染开始
    // 获得待渲染列表后
    // 在一帧渲染提交后
    function getType() {
      return "Render";
    }
  }, {
    key: "updateTileInfo",
    value: function updateTileInfo(w, h) {
      var tileSize = this._m_TileInfo.tileSize;
      this._m_TileInfo.tileWidth = Math.floor(w / tileSize);
      this._m_TileInfo.tileHeight = Math.floor(h / tileSize);
      this._m_TileInfo.tileNum = this._m_TileInfo.tileWidth * this._m_TileInfo.tileHeight;
    }
    /**
     * 设置TileSize。<br/>
     * @param {Number}[tileSize]
     */

  }, {
    key: "setTileSize",
    value: function setTileSize(tileSize) {
      if (tileSize != this._m_TileInfo.tileSize) {
        this._m_TileInfo.tileSize = tileSize;
        this.updateTileInfo(this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight());
      }
    }
    /**
     * 返回TileInfo。<br/>
     * @return {{}|*}
     */

  }, {
    key: "getTileInfo",
    value: function getTileInfo() {
      return this._m_TileInfo;
    }
    /**
     * 设置渲染优先技术。<br/>
     * @param technology
     */

  }, {
    key: "setPriorityTechnology",
    value: function setPriorityTechnology(technology) {
      this._m_PriorityTechnology = technology;
    }
    /**
     * 返回渲染优先技术。<br/>
     * @return {string}
     */

  }, {
    key: "getPriorityTechnology",
    value: function getPriorityTechnology() {
      return this._m_PriorityTechnology;
    }
    /**
     * 设置批次渲染光源数目。<br/>
     * @param {Number}[size]
     */

  }, {
    key: "setBatchLightSize",
    value: function setBatchLightSize(size) {
      if (size != this._m_BatchLightSize) {
        if (size > 50) size = 50;

        _TempVars.default.mallocLightData(size);

        this._m_BatchLightSize = size;

        _ShaderSource.default.resizeBatchLightSize(size);
      }
    }
    /**
     * 返回批次渲染光源数目。<br/>
     * @return {number}
     */

  }, {
    key: "getBatchLightSize",
    value: function getBatchLightSize() {
      return this._m_BatchLightSize;
    }
    /**
     * 启动渲染器。<br/>
     */

  }, {
    key: "startUp",
    value: function startUp() {
      var _this2 = this;

      // 创建默认DeferredShadingFrameBuffer
      var gl = this._m_Scene.getCanvas().getGLContext();

      var depthEXT = gl.getExtension("WEBKIT_WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture");

      _Log.default.debug("depthEXT:", depthEXT); // console.log("支持的拓展:" , gl.getSupportedExtensions());


      var w = this._m_Scene.getCanvas().getWidth();

      var h = this._m_Scene.getCanvas().getHeight();

      var dfb = new _FrameBuffer.default(gl, Render.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER, w, h);

      this._m_FrameContext.addFrameBuffer(Render.DEFAULT_DEFERRED_SHADING_FRAMEBUFFER, dfb); // 这里为了统一性，一致使用RGBA16F，而不是编码法线或其他压缩，确保可以在shader使用float存储更多的信息
      // G-buffer0


      dfb.addTexture(gl, _ShaderSource.default.S_G_BUFFER0_SRC, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT0, true); // G-buffer1

      dfb.addTexture(gl, _ShaderSource.default.S_G_BUFFER1_SRC, gl.RGBA32F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT1, true); // G-buffer2

      dfb.addTexture(gl, _ShaderSource.default.S_G_BUFFER2_SRC, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT2, true); // 创建depth附件(使用renderBuffer来提供)
      // 渲染缓存是一种特殊缓冲区,不需要在shader中写数据,而是可以作为提供类似深度缓冲区这种类型的缓存来使用
      // webGL2.0不支持将深度写入纹理,https://www.it1352.com/1705357.html
      // dfb.addBuffer(gl, ShaderSource.S_G_DEPTH_RENDER_BUFFER_SRC, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);

      dfb.addTexture(gl, _ShaderSource.default.S_G_DEPTH_SRC, gl.DEPTH_COMPONENT24, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, gl.DEPTH_ATTACHMENT, false); // 但由于webGL不完全兼容gl.blitFramebuffer,所以这里使用纹理附件写入的方式进行
      // 而由于webGL不支持将深度附件作为纹理使用,所以需要同时创建一个depthRenderBuffer和一个depthTexture
      // dfb.addTexture(gl, ShaderSource.S_G_DEPTH_SRC, gl.RGBA, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.COLOR_ATTACHMENT3, true);
      // 这里使用另一种解决方案(由于webGL不支持从自定义frameBuffer.blit数据到默认frameBuffer,所以一旦启用了延迟渲染路径,则创建一个默认的forwardFrameBuffer而不是使用默认内置frameBuffer

      dfb.finish(gl, this._m_Scene, true); // 创建备用默认fbo

      var ffb = new _FrameBuffer.default(gl, Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER, w, h);

      this._m_FrameContext.addFrameBuffer(Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER, ffb); // ffb.addBuffer(gl, 'outColor', gl.RGBA4, gl.COLOR_ATTACHMENT0);
      // 为了支持HDR和gamma矫正,使用一个RGBA16F ffb


      ffb.addTexture(gl, _ShaderSource.default.S_FORWARD_COLOR_MAP_SRC, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT0, false); // ffb.addTexture(gl, 'outColor', gl.RGB, 0, gl.RGB, gl.UNSIGNED_BYTE, gl.COLOR_ATTACHMENT0, false);
      // ffb.addBuffer(gl, 'depth', gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);

      ffb.addBuffer(gl, 'depth', gl.DEPTH_COMPONENT24, gl.DEPTH_ATTACHMENT);
      ffb.finish(gl, this._m_Scene, true);
      var forwardMat = new _Material.default(this._m_Scene, {
        id: 'for_m',
        frameContext: this.getFrameContext(),
        materialDef: _MaterialDef.default.parse(_Internal.default.S_DEFAULT_OUT_COLOR_DEF_DATA)
      });
      forwardMat.setParam('gammaFactor', new _FloatVars.default().valueOf(this._m_GammaFactor));
      ffb.getFramePicture().setMaterial(forwardMat);
      this._m_FrameContext._m_DefaultFrameBuffer = ffb.getFrameBuffer(); // FilterPipeline

      var filterfb = new _FrameBuffer.default(gl, Render.DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER, w, h);

      this._m_PostFilterPipelineSwap.push(filterfb);

      this._m_FrameContext.addFrameBuffer(Render.DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER, filterfb); // 为了支持HDR和gamma矫正,使用一个RGBA16F ffb


      filterfb.addTexture(gl, _ShaderSource.default.S_IN_SCREEN_SRC, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT0, false);
      filterfb.addTexture(gl, _ShaderSource.default.S_IN_DEPTH_SRC, gl.DEPTH_COMPONENT24, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, gl.DEPTH_ATTACHMENT, false);
      filterfb.finish(gl, this._m_Scene, false);
      this._m_FrameContext._m_DefaultPostFilterFrameBuffer = filterfb.getFrameBuffer();
      var filterfb2 = new _FrameBuffer.default(gl, Render.DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER2, w, h);

      this._m_PostFilterPipelineSwap.push(filterfb2);

      this._m_FrameContext.addFrameBuffer(Render.DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER2, filterfb2); // 为了支持HDR和gamma矫正,使用一个RGBA16F ffb


      filterfb2.addTexture(gl, _ShaderSource.default.S_IN_SCREEN_SRC, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT0, false);
      filterfb2.addTexture(gl, _ShaderSource.default.S_IN_DEPTH_SRC, gl.DEPTH_COMPONENT24, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, gl.DEPTH_ATTACHMENT, false);
      filterfb2.finish(gl, this._m_Scene, false); // 加载可用渲染程序

      this._m_RenderPrograms[_DefaultRenderProgram.default.PROGRAM_TYPE] = new _DefaultRenderProgram.default();
      this._m_RenderPrograms[_SinglePassLightingRenderProgram.default.PROGRAM_TYPE] = new _SinglePassLightingRenderProgram.default();
      this._m_RenderPrograms[_MultiPassLightingRenderProgram.default.PROGRAM_TYPE] = new _MultiPassLightingRenderProgram.default();
      this._m_RenderPrograms[_SinglePassIBLLightingRenderProgram.default.PROGRAM_TYPE] = new _SinglePassIBLLightingRenderProgram.default();
      this._m_RenderPrograms[_MultiPassIBLLightingRenderProgram.default.PROGRAM_TYPE] = new _MultiPassIBLLightingRenderProgram.default();
      this._m_RenderPrograms[_TilePassLightingRenderProgram.default.PROGRAM_TYPE] = new _TilePassLightingRenderProgram.default();
      this._m_RenderPrograms[_TilePassIBLLightingRenderProgram.default.PROGRAM_TYPE] = new _TilePassIBLLightingRenderProgram.default(); // pipeline

      this._m_PipelineConfig[Render.FORWARD] = new _Forward.default({
        render: this
      });
      this._m_PipelineConfig[Render.DEFERRED_SHADING] = new _Deferred.default({
        render: this
      });
      this._m_PipelineConfig[Render.TILE_DEFERRED_SHADING] = new _TileDeferred.default({
        render: this
      });
      this.enablePipeline(Render.FORWARD);
      this.enablePipeline(Render.DEFERRED_SHADING); // 监听canvas的基本事件

      this._m_Scene.getCanvas().on('resize', function (w, h) {
        _this2._m_FrameContext.resize(gl, w, h);

        _this2._m_FrameContext._m_DefaultFrameBuffer = _this2._m_FrameContext.getFrameBuffer(Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER).getFrameBuffer();
        _this2._m_FrameContext._m_DefaultPostFilterFrameBuffer = _this2._m_FrameContext.getFrameBuffer(Render.DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER).getFrameBuffer(); // this._m_FrameContext._m_DefaultPostFilterFrameBuffer = this._m_PostFilterPipelineSwap[0].getFrameBuffer();
      });
    }
    /**
     * 准备进入PostFilterPipeline。<br/>
     */

  }, {
    key: "beginPostFilter",
    value: function beginPostFilter() {
      // 准备进入PostFilterPipeline
      // 将当前帧结果复制到PostFilterFrameBuffer以便进行PostFilter
      var gl = this._m_Scene.getCanvas().getGLContext();

      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._m_FrameContext._m_DefaultFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._m_FrameContext._m_DefaultPostFilterFrameBuffer);
      gl.blitFramebuffer(0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.NEAREST); // 将PostFilter输出结果设置到交换缓存区

      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_PostFilterPipelineSwap[1].getFrameBuffer());

      if (this._m_FrameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
        gl.disable(gl.DEPTH_TEST);
      }
    }
    /**
     * 交换PostFilter处理结果以便缓冲区进行正确的渲染。<br/>
     */

  }, {
    key: "swapPostFilter",
    value: function swapPostFilter() {
      var gl = this._m_Scene.getCanvas().getGLContext(); // 将输出buffer传递到输入buffer以便下一环节的postFilter


      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._m_PostFilterPipelineSwap[1].getFrameBuffer());
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._m_FrameContext._m_DefaultPostFilterFrameBuffer); // 这里假设PostFilter不会修改深度缓冲区,所以没有复制深度缓冲区

      gl.blitFramebuffer(0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), gl.COLOR_BUFFER_BIT, gl.NEAREST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_PostFilterPipelineSwap[1].getFrameBuffer());
    }
    /**
     * 结束PostFilterPipeline。<br/>
     */

  }, {
    key: "finishPostFilter",
    value: function finishPostFilter() {
      // 将PostFilter结果复制回默认帧缓冲区（不是真正的默认帧缓冲区，因为还有最后一个环节）
      var gl = this._m_Scene.getCanvas().getGLContext();

      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._m_FrameContext._m_DefaultPostFilterFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._m_FrameContext._m_DefaultFrameBuffer);
      gl.blitFramebuffer(0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.NEAREST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_FrameContext._m_DefaultFrameBuffer);
    }
    /**
     * 激活指定的pipeline。<br/>
     * @param {String}[pipeline Render的枚举值]
     */

  }, {
    key: "enablePipeline",
    value: function enablePipeline(pipeline) {
      var pipelineId = -1;

      switch (pipeline) {
        case Render.FORWARD:
          pipelineId = 0;
          break;

        case Render.DEFERRED_SHADING:
        case Render.TILE_DEFERRED_SHADING:
          pipelineId = 1;
          break;
      }

      if (pipelineId >= 0) this._m_Pipeline[pipelineId] = this._m_PipelineConfig[pipeline];else {
        _Log.default.warn('无效pipeline!');
      }
    }
    /**
     * 返回当前帧渲染列表。<br/>
     * @return {IDrawable[]}
     */

  }, {
    key: "getVisDrawables",
    value: function getVisDrawables() {
      return this._m_VisDrawables;
    }
    /**
     * 返回名称映射drawable列表。<br/>
     * @return {{}|*}
     */

  }, {
    key: "getDrawableIDs",
    value: function getDrawableIDs() {
      return this._m_DrawableIDs;
    }
    /**
     * 返回上下文。<br/>
     * @return {FrameContext}
     */

  }, {
    key: "getFrameContext",
    value: function getFrameContext() {
      return this._m_FrameContext;
    }
    /**
     * 设置天空盒。<br/>
     * @param {Sky}[sky SkyBox或SkyDome]
     */

  }, {
    key: "setSky",
    value: function setSky(sky) {
      if (this._m_Sky == sky) return;
      this._m_Sky = sky;
    }
    /**
     * 返回天空盒。<br/>
     * @return {Sky}
     */

  }, {
    key: "getSky",
    value: function getSky() {
      return this._m_Sky;
    }
    /**
     * 添加一个IDrawable对象,该对象必须实现IDrawable接口。<br/>
     * @param {IDrawable}[iDrawable]
     */

  }, {
    key: "addDrawable",
    value: function addDrawable(iDrawable) {
      if (iDrawable.isFramePicture && iDrawable.isFramePicture()) {
        // 添加到FramesPicture列表中
        if (!this._m_FramePictureIDs[iDrawable.getId()]) {
          this._m_FramePictureIDs[iDrawable.getId()] = iDrawable;

          this._m_FramePictures.push(iDrawable);
        }

        return;
      }

      if (iDrawable.isSky && iDrawable.isSky()) {
        // 天空盒(我们通过setSky()来设置天空盒)
        return;
      } // 每次添加一个drawable时,根据材质提前做好分区


      if (!this._m_DrawableIDs[iDrawable.getId()]) {
        this._m_DrawableIDs[iDrawable.getId()] = iDrawable;

        this._m_Drawables.push(iDrawable);
      }
    }
    /**
     * 移除一个IDrawable对象,该对象必须实现IDrawable接口。<br/>
     * @param {IDrawable}[iDrawable]
     */

  }, {
    key: "removeDrawable",
    value: function removeDrawable(iDrawable) {
      if (this._m_DrawableIDs[iDrawable.getId()]) {
        this._m_DrawableIDs[iDrawable.getId()] = null;

        this._m_Drawables.remove(iDrawable);
      }
    }
    /**
     * 检测渲染状态切换。<br/>
     * @param {WebGLContext}[gl]
     * @param {RenderState}[renderState 目标渲染状态]
     * @param {RenderState}[currentRenderState 当前渲染状态]
     * @private
     */

  }, {
    key: "_checkRenderState",
    value: function _checkRenderState(gl, renderState, currentRenderState) {
      var state = renderState.getState();
      var change = false;

      for (var k in state) {
        if (currentRenderState.getFlag(k) != state[k]) {
          change = true; // 更新状态机
          // console.log("更新渲染状态[" + k + ":" + currentRenderState.getFlag(k) + "=>" + state[k] + "]");

          currentRenderState.setFlag(k, state[k]);

          switch (k) {
            case _RenderState.default.S_STATES[0]:
              switch (state[k]) {
                case _RenderState.default.S_FACE_CULL_BACK:
                  gl.enable(gl.CULL_FACE);
                  gl.cullFace(gl.BACK);
                  break;

                case _RenderState.default.S_FACE_CULL_FRONT:
                  gl.enable(gl.CULL_FACE);
                  gl.cullFace(gl.FRONT);
                  break;

                case _RenderState.default.S_FACE_CULL_FRONT_AND_BACK:
                  gl.enable(gl.CULL_FACE);
                  gl.cullFace(gl.FRONT_AND_BACK);
                  break;

                case _RenderState.default.S_FACE_CULL_OFF:
                  gl.disable(gl.CULL_FACE);
                  break;
              }

              break;

            case _RenderState.default.S_STATES[1]:
              // console.log("depthWrite");
              if (state[k] == 'On') {
                gl.depthMask(true);
              } else if (state[k] == 'Off') {
                gl.depthMask(false);
              }

              break;

            case _RenderState.default.S_STATES[2]:
              if (state[k] == 'On') {
                gl.colorMask(true, true, true, true);
              } else if (state[k] == 'Off') {
                gl.colorMask(false, false, false, false);
              }

              break;

            case _RenderState.default.S_STATES[3]:
              if (state[k] == 'On') {
                gl.enable(gl.DEPTH_TEST);
              } else if (state[k] == 'Off') {
                gl.disable(gl.DEPTH_TEST);
              }

              break;

            case _RenderState.default.S_STATES[4]:
              if (state[k] == 'On') {
                gl.enable(gl.BLEND);
              } else if (state[k] == 'Off') {
                gl.disable(gl.BLEND);
              }

              break;

            case _RenderState.default.S_STATES[5]:
              var sfactor = null;
              var dfactor = null;

              switch (state[k][0]) {
                case "SRC_ALPHA":
                  sfactor = gl.SRC_ALPHA;
                  break;

                case "ONE":
                  sfactor = gl.ONE;
                  break;
              }

              switch (state[k][1]) {
                case "SRC_ALPHA":
                  dfactor = gl.SRC_ALPHA;

                case "ONE_MINUS_SRC_COLOR":
                  dfactor = gl.ONE_MINUS_SRC_COLOR;
                  break;

                case "ONE_MINUS_SRC_ALPHA":
                  dfactor = gl.ONE_MINUS_SRC_ALPHA;
                  break;

                case "ONE":
                  dfactor = gl.ONE;
                  break;
              }

              if (sfactor != null && dfactor != null) {
                gl.blendFunc(sfactor, dfactor);
              }

              break;

            case _RenderState.default.S_STATES[6]:
              if (state[k] == 'On') {
                gl.enable(gl.SCISSOR_TEST);
              } else if (state[k] == 'Off') {
                gl.disable(gl.SCISSOR_TEST);
              }

              break;

            case _RenderState.default.S_STATES[7]:
              if (state[k] == 'On') {
                gl.enable(gl.POLYGON_OFFSET_FILL);
              } else if (state[k] == 'Off') {
                gl.disable(gl.POLYGON_OFFSET_FILL);
              }

              break;

            case _RenderState.default.S_STATES[8]:
              gl.polygonOffset(state[k][0], state[k][1]);
              break;
          }
        }
      }

      return change;
    }
    /**
     * 重制渲染上下文。<br/>
     * @private
     */

  }, {
    key: "_resetFrameContext",
    value: function _resetFrameContext() {
      this._m_FrameContext.reset();
    }
    /**
     * 绘制一帧。<br/>
     * @param {Number}[exTime]
     * @private
     */

  }, {
    key: "_drawFrame",
    value: function _drawFrame(exTime) {
      var gl = this._m_Scene.getCanvas().getGLContext(); // 一帧的开始


      this.fire(Render.PRE_FRAME, [exTime]);

      this._resetFrameContext();

      this._checkRenderState(gl, this._m_FrameContext.getRenderState().reset(), this._m_FrameContext.getRenderState()); // m_VisDrawables包含了视锥体剔除的结果
      // 在这里进行遮挡剔除
      // 然后进行z-pre pass
      // 剔除的时候,需要先排除GUI元素


      var visDrawables = this._m_VisDrawables;
      var stateChange = false; // 按材质分类
      // 1.实时创建分类列表
      // 2.另一种方案是,在添加和删除一个drawable的函数中提前分类材质
      // 然后在剔除阶段设置每个drawable的cull标记
      // 然后在路径渲染时根据cull跳过,这样虽然会遍历所有材质的所有几何,但是可以避免实时创建分类列表
      // 暂时使用方法1

      var hasOpaque = false;
      var hasTranslucent = false;
      var hasGUI = false; // 使用后置缓存?

      var useBackForwardFrameBuffer = false; // 灯光列表

      var lights = this._m_Scene.getVisLights(); // 不透明队列


      var opaqueBucket = {}; // 半透明队列
      // let translucentBucket = {};

      var translucentBucket = []; // 最后渲染的层

      var guiBucket = [];
      visDrawables.forEach(function (drawable) {
        if (drawable.isGUI()) {
          hasGUI = true;

          if (!guiBucket[drawable.getMaterial().getId()]) {
            guiBucket[drawable.getMaterial().getId()] = [];
          }

          guiBucket[drawable.getMaterial().getId()].push(drawable);
        } else if (drawable.isOpaque()) {
          hasOpaque = true;

          if (!opaqueBucket[drawable.getMaterial().getId()]) {
            opaqueBucket[drawable.getMaterial().getId()] = [];
          }

          opaqueBucket[drawable.getMaterial().getId()].push(drawable);
        } else if (drawable.isTranslucent()) {
          hasTranslucent = true; // if(!translucentBucket[drawable.getMaterial().getId()]){
          //     translucentBucket[drawable.getMaterial().getId()] = [];
          // }
          // translucentBucket[drawable.getMaterial().getId()].push(drawable);

          translucentBucket.push(drawable);
        }
      }); // 排队,各种剔除之后(考虑设计一个RenderQueue,保存剔除后的待渲染的不透明，半透明，透明列表，然后作为参数传递到postQueue中)

      this.fire(Render.POST_QUEUE, [exTime]); // 不透明物体渲染默认默认开启深度测试,深度写入(但是仍然可以通过具体的SubPass控制渲染状态)

      if (hasOpaque) {
        this._checkRenderState(gl, this._m_OpaqueRenderState, this._m_FrameContext.getRenderState());
      }

      var subShaders = null; // 延迟路径部分...

      useBackForwardFrameBuffer = this._m_Pipeline[1].render({
        gl: gl,
        scene: this._m_Scene,
        frameContext: this._m_FrameContext,
        lights: lights,
        bucket: opaqueBucket
      });

      var pfilter = this._m_Scene.getMainCamera().demandFilter();

      if (!useBackForwardFrameBuffer) {
        // 检测filters
        if (this._m_GammaCorrection || pfilter) {
          useBackForwardFrameBuffer = true;
          gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_FrameContext._m_DefaultFrameBuffer);
          this._m_FrameContext.m_LastFrameBuffer = this._m_FrameContext._m_DefaultFrameBuffer;
        }

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      } // 正向路径部分...
      // 先渲染不透明队列


      this._m_Pipeline[0].render({
        gl: gl,
        scene: this._m_Scene,
        frameContext: this._m_FrameContext,
        lights: lights,
        opaque: true,
        bucket: opaqueBucket
      }); // 渲染env


      this._drawEnv(gl, lights); // 接着渲染半透明队列
      // 半透明物体默认关闭深度写入(但是仍然可通过具体的SubPass控制渲染状态)


      if (hasTranslucent) {
        this._checkRenderState(gl, this._m_TranslucentRenderState, this._m_FrameContext.getRenderState()); // 排序半透明队列
        // 这里有个问题,可以按照材质组作为整体组进行排序
        // 也可分开成独立物体进行排序
        // 由于默认关闭了深度写入,所有理论上所有面片都会渲染


        translucentBucket = _RenderQueue.default.sortTranslucentBucket(this._m_Scene.getMainCamera(), translucentBucket);

        this._m_Pipeline[0].render({
          gl: gl,
          scene: this._m_Scene,
          frameContext: this._m_FrameContext,
          lights: lights,
          translucent: true,
          bucket: translucentBucket
        });
      } // 一帧结束后


      if (pfilter) {
        this.beginPostFilter();
      }

      this.fire(Render.POST_FRAME, [exTime]);

      if (pfilter) {
        if (this._m_FrameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.enable(gl.DEPTH_TEST);
        }

        this.finishPostFilter();
      } // 然后是GUI层(这里需要注意的是，这里需要完善，目前暂时使用opaque渲染)
      // 这里，GUI层比较特殊，应该在最后进行渲染（事实上，应该在默认gamma矫正之后，但可能gui本身也是在sRGB空间，所以这里在默认gamma矫正之前进行渲染）


      if (hasGUI) {
        // 对于GUI,启用半透明混合,但是渲染的是opaque
        this._checkRenderState(gl, this._m_TranslucentRenderState, this._m_FrameContext.getRenderState());

        this._m_Pipeline[0].render({
          gl: gl,
          scene: this._m_Scene,
          frameContext: this._m_FrameContext,
          lights: lights,
          opaque: true,
          bucket: guiBucket
        });
      } // 检测是否启用了自定义forwardFrameBuffer


      if (useBackForwardFrameBuffer) {
        // 则在这里渲染到默认内置frameBuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, null); // 渲染forwardPicture

        var forwardPicture = this._m_FrameContext.getFrameBuffer(Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER).getFramePicture();

        var currentTechnology = forwardPicture.getMaterial().getCurrentTechnology(); // 获取当前技术所有Forward路径下的SubShaders

        var forwardSubPasss = currentTechnology.getSubPasss(Render.FORWARD); // 这里按照架构严格设计应该是遍历所有subShaders,但由于该阶段是完全引擎内置操作,所以直接取[0]第一个元素subShader进行渲染,从而跳过多余的遍历

        forwardPicture.getMaterial()._selectSubShader(forwardSubPasss.getSubShaders()[0].subShader);

        var renderDatas = forwardSubPasss.getSubShaders()[0].subShader.getRenderDatas();

        if (this._m_FrameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.disable(gl.DEPTH_TEST);
        }

        for (var k in renderDatas) {
          gl.activeTexture(gl.TEXTURE0 + renderDatas[k].loc);
          gl.bindTexture(gl.TEXTURE_2D, this._m_FrameContext.getFrameBuffer(renderDatas[k].refId).getTexture(renderDatas[k].dataId).getLoc());
        }

        forwardPicture.draw(this._m_FrameContext);

        if (this._m_FrameContext.getRenderState().getFlag(_RenderState.default.S_STATES[3]) == 'On') {
          gl.enable(gl.DEPTH_TEST);
        }

        this._m_FrameContext.m_LastFrameBuffer = null;
      }
    }
    /**
     * 使用默认输出缓存。<br/>
     */

  }, {
    key: "useDefaultFrame",
    value: function useDefaultFrame() {
      if (this._m_FrameContext.m_LastFrameBuffer != null) {
        var gl = this._m_Scene.getCanvas().getGLContext();

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._m_FrameContext.m_LastFrameBuffer = null;
      }
    }
    /**
     * 设置渲染视口。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[x 偏移量]
     * @param {Number}[y 偏移量]
     * @param {Number}[w 视口宽度]
     * @param {Number}[h 视口高度]
     */

  }, {
    key: "setViewPort",
    value: function setViewPort(gl, x, y, w, h) {
      gl.viewport(x, y, w, h);
    }
    /**
     * 强制在接下来中使用指定的某个材质。<br/>
     * @param {String}[path]
     * @param {Material}[mat]
     * @param {Number}[passId]
     */

  }, {
    key: "useForcedMat",
    value: function useForcedMat(path, mat, passId) {
      var currentTechnology = mat.getCurrentTechnology();
      var subPasss = currentTechnology.getSubPasss(path);

      if (subPasss) {
        var subShaders = subPasss.getSubShaders();
        var i = 0;

        for (var subShader in subShaders) {
          // 指定subShader
          if (i == passId) {
            mat._selectSubShader(subShaders[subShader].subShader);

            var renderDatas = subShaders[subShader].subShader.getRenderDatas();

            var gl = this._m_Scene.getCanvas().getGLContext();

            for (var k in renderDatas) {
              gl.activeTexture(gl.TEXTURE0 + renderDatas[k].loc);
              gl.bindTexture(gl.TEXTURE_2D, this._m_FrameContext.getFrameBuffer(renderDatas[k].refId).getTexture(renderDatas[k].dataId).getLoc());
            }

            break;
          }

          i++;
        }
      }
    }
    /**
     * 渲染指定列表。<br/>
     * 假设该列表已排序。<br/>
     * @param {WebGL}[gl]
     * @param {String}[path]
     * @param {Object}[lights]
     * @param {Light[]}[lights]
     */

  }, {
    key: "draw",
    value: function draw(gl, path, bucks, lights) {
      var subShaders = null;
      var mat = null;
      var currentTechnology = null;
      var subPasss = null;

      if (bucks) {
        var resetFrameBuffer = this._m_FrameContext.m_LastFrameBuffer;
        var outFB = null;

        for (var matId in bucks) {
          // 获取当前选中的技术
          mat = this._m_Scene.getComponent(matId);
          currentTechnology = mat.getCurrentTechnology();
          subPasss = currentTechnology.getSubPasss(path);

          if (subPasss) {
            subShaders = subPasss.getSubShaders(); // 执行渲染

            for (var subShader in subShaders) {
              // 指定subShader
              mat._selectSubShader(subShaders[subShader].subShader);

              if (subShaders[subShader].subShader.getFBId() != null) {
                outFB = this._m_FrameContext.getFrameBuffer(subShaders[subShader].subShader.getFBId());

                if (this._m_FrameContext.m_LastFrameBuffer != outFB) {
                  this._m_FrameContext.m_LastFrameBuffer = outFB;
                  gl.bindFramebuffer(gl.FRAMEBUFFER, outFB.getFrameBuffer());
                  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }
              } else if (this._m_FrameContext.m_LastFrameBuffer != resetFrameBuffer) {
                // 不需要clear
                gl.bindFramebuffer(gl.FRAMEBUFFER, resetFrameBuffer);
                this._m_FrameContext.m_LastFrameBuffer = resetFrameBuffer;
              }

              var renderDatas = subShaders[subShader].subShader.getRenderDatas();

              for (var k in renderDatas) {
                gl.activeTexture(gl.TEXTURE0 + renderDatas[k].loc);
                gl.bindTexture(gl.TEXTURE_2D, this._m_FrameContext.getFrameBuffer(renderDatas[k].refId).getTexture(renderDatas[k].dataId).getLoc());
              } // 检测是否需要更新渲染状态


              if (subShaders[subShader].renderState) {
                // 依次检测所有项
                this._checkRenderState(gl, subShaders[subShader].renderState, this._m_FrameContext.getRenderState());
              }

              this._m_RenderPrograms[subShaders[subShader].subShader.getRenderProgramType()].drawArrays(gl, this._m_Scene, this._m_FrameContext, bucks[matId], lights);
            }
          }
        }

        if (this._m_FrameContext.m_LastFrameBuffer != resetFrameBuffer) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, resetFrameBuffer);
          this._m_FrameContext.m_LastFrameBuffer = resetFrameBuffer;
        }
      }
    }
    /**
     * 渲染环境。<br/>
     * @param {WebGL}[gl]
     * @param {Number[]}[lights]
     */

  }, {
    key: "_drawEnv",
    value: function _drawEnv(gl, lights) {
      // 渲染sky
      if (this._m_Sky) {
        var subShaders = null; // 获取当前选中的技术

        var mat = this._m_Sky.getMaterial();

        var currentTechnology = mat.getCurrentTechnology(); // 获取当前技术所有Forward路径下的SubShaders

        var forwardSubPasss = currentTechnology.getSubPasss(Render.FORWARD); // 如果该物体存在Forward路径渲染的需要,则执行Forward渲染

        if (forwardSubPasss) {
          subShaders = forwardSubPasss.getSubShaders(); // 执行渲染

          for (var subShader in subShaders) {
            // 检测是否需要更新渲染状态
            if (subShaders[subShader].renderState) {
              // 依次检测所有项
              this._checkRenderState(gl, subShaders[subShader].renderState, this._m_FrameContext.getRenderState());
            } // 指定subShader


            mat._selectSubShader(subShaders[subShader].subShader);

            this._m_RenderPrograms[subShaders[subShader].subShader.getRenderProgramType()].draw(gl, this._m_Scene, this._m_FrameContext, this._m_Sky, lights); // geo.draw(this._m_FrameContext);

          }
        }
      }
    }
    /**
     * 启用或关闭gamma矫正。<br/>
     * @param {Boolean}[enable]
     */

  }, {
    key: "enableGammaCorrection",
    value: function enableGammaCorrection(enable) {
      // 现在忽略这个参数
      this._m_GammaCorrection = enable;
    }
    /**
     * 启用或关闭toneMapping。<br/>
     * @param {Boolean}[enable]
     */

  }, {
    key: "enableToneMapping",
    value: function enableToneMapping(enable) {
      if (enable != this._m_ToneMapping) {
        this._m_ToneMapping = enable;

        this._m_FrameContext.getFrameBuffer(Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER).getFramePicture().getMaterial().setParam('toneMapping', new _BoolVars.default().valueOf(this._m_ToneMapping));
      }
    }
    /**
     * 设置gamma编码因子。<br/>
     * @param {Number}[gammaFactor 默认为0.45]
     */

  }, {
    key: "setGammaFactor",
    value: function setGammaFactor(gammaFactor) {
      if (gammaFactor != this._m_GammaFactor) {
        this._m_GammaFactor = gammaFactor;

        this._m_FrameContext.getFrameBuffer(Render.DEFAULT_FORWARD_SHADING_FRAMEBUFFER).getFramePicture().getMaterial().setParam('gammaFactor', new _FloatVars.default().valueOf(this._m_GammaFactor));
      }
    }
    /**
     * 执行渲染调用,先判断是否需要重新构建渲染列表,然后判断是否需要优化排序,以便把所有材质一致的渲染元素排列在一起,加速渲染调用。<br/>
     * @param exTime
     */

  }, {
    key: "render",
    value: function render(exTime) {
      if (true) {
        this._drawFrame(exTime);
      }
    }
    /**
     * 排序渲染列表,这里根据材质对象进行优化排序渲染列表,以便加速渲染调用。<br/>
     * @private
     */

  }, {
    key: "_sortDrawList",
    value: function _sortDrawList() {}
  }]);

  return Render;
}(_Component2.default);

exports["default"] = Render;

_defineProperty(Render, "FORWARD", 'Forward');

_defineProperty(Render, "DEFERRED_SHADING", 'DeferredShading');

_defineProperty(Render, "TILE_DEFERRED_SHADING", 'TileDeferredShading');

_defineProperty(Render, "DEFAULT_DEFERRED_SHADING_FRAMEBUFFER", 'DefaultDeferredShadingFrameBuffer');

_defineProperty(Render, "DEFAULT_FORWARD_SHADING_FRAMEBUFFER", 'DefaultForwardShadingFrameBuffer');

_defineProperty(Render, "DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER", 'DefaultPostFilterShadingFrameBuffer');

_defineProperty(Render, "DEFAULT_POST_FILTER_SHADING_FRAMEBUFFER2", 'DefaultPostFilterShadingFrameBuffer2');

_defineProperty(Render, "PRE_FRAME", "preFrame");

_defineProperty(Render, "POST_QUEUE", "postQueue");

_defineProperty(Render, "POST_FRAME", "postFrame");

/***/ }),

/***/ 9510:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 渲染队列。<br/>
 * 保存各个渲染队列数据。<br/>
 * @author Kkk
 * @date 2021年2月10日2021年2月10日
 * @lastdate 2021年3月17日16点48分
 */
var RenderQueue = /*#__PURE__*/function () {
  function RenderQueue() {
    _classCallCheck(this, RenderQueue);

    // 不透明队列
    this.m_OpaqueBucket = {}; // 半透明队列(key : Material, value : List<Geometry>)

    this.m_TranslucentBucket = {}; // ...其他队列(比如Sky,GUI)
  }

  _createClass(RenderQueue, [{
    key: "addToOpaque",
    value: function addToOpaque(iDrawable) {}
    /**
     * 次序相关的半透明排序。<br/>
     * @param {Camera}[cam]
     * @param {Array}[translucentBucket]
     * @return {Array}
     */

  }], [{
    key: "sortTranslucentBucket",
    value: function sortTranslucentBucket(cam, translucentBucket) {
      var result = RenderQueue._TEMP_BUCKET_ARRAY;
      result.length = 0;
      var temp = RenderQueue._TEMP_ARRAY;
      temp.length = 0;
      var camPos = cam.getEye();
      translucentBucket.forEach(function (geo) {
        temp.push([geo.getLocalTranslation().distanceSq(camPos), geo]);
      }); // 从远往近排序

      temp.sort(function (a, b) {
        return b[0] - a[0];
      }); // 应该还要结合材质Id进行排序,以便尽可能在物体次序正确下材质排序

      temp.forEach(function (t) {
        result.push(t[1]);
      });
      return result;
    }
  }]);

  return RenderQueue;
}();

exports["default"] = RenderQueue;

_defineProperty(RenderQueue, "_TEMP_BUCKET_ARRAY", []);

_defineProperty(RenderQueue, "_TEMP_ARRAY", []);

/***/ }),

/***/ 1550:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Plane = _interopRequireDefault(__webpack_require__(7088));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _Filter = _interopRequireDefault(__webpack_require__(7120));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Camera定义了3D空间中的观察者,渲染3D世界时,3D世界中必须有一个Camera,否则无法渲染。<br/>
 * 除了用于渲染GUI的Picture元素外,3D世界的其他对象被激活的Camera渲染到用户设备中。<br/>
 * @author Kkk
 * @date 2020年10月10日10点35分
 */
var Camera = /*#__PURE__*/function (_Component) {
  _inherits(Camera, _Component);

  var _super = _createSuper(Camera);

  // 视锥包含标记
  // 相交
  // 包含
  // 不包含
  // 视锥体索引
  function Camera(owner, cfg) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this, owner, cfg);
    _this._m_Eye = new _Vector.default(0, 0, 10);
    _this._m_At = new _Vector.default(0, 0, -10);
    _this._m_Up = new _Vector.default(0, 1, 0);
    _this._m_Dir = new _Vector.default();
    _this._m_ViewMatrix = new _Matrix.default();
    _this._m_ProjectMatrix = new _Matrix.default();
    _this._m_ProjectViewMatrix = new _Matrix.default();
    _this._m_ViewMatrixUpdate = false;
    _this._m_ProjectMatrixUpdate = false;
    _this._m_ProjectViewMatrixUpdate = false;
    _this._m_ParallelProjection = cfg.parallelProjection != null ? cfg.parallelProjection : false; // 相机参数

    _this._m_Fovy = cfg.fovy || 45.0;
    _this._m_FixedAspect = cfg.aspect != null ? cfg.aspect : false; // 如果当前相机是一个主相机,则被激活用于主渲染

    _this._m_IsRenderingCamera = false; // Frustum6个平面

    _this._m_FrustumPlane = [];

    for (var i = 0; i < 6; i++) {
      _this._m_FrustumPlane.push(new _Plane.default());
    } // Frustum6截面距离
    // 相机到Near截面的距离


    _this._m_FrustumNear = 0.1; // 相机到Far截面的距离

    _this._m_FrustumFar = 1000; // 相机到Left截面的距离

    _this._m_FrustumLeft = 0; // 相机到Right截面的距离

    _this._m_FrustumRight = 0; // 相机到Top截面的距离

    _this._m_FrustumTop = 0; // 相机到Bottom截面的距离

    _this._m_FrustumBottom = 0; // 缓存变量

    _this._m_CoeffLeft = new Array(2).fill(0);
    _this._m_CoeffRight = new Array(2).fill(0);
    _this._m_CoeffBottom = new Array(2).fill(0);
    _this._m_CoeffTop = new Array(2).fill(0); // 计算标记

    _this._m_FrustumMask = 0; // 初始化(默认是一个透视相机)

    var canvas = _this._m_Scene.getCanvas();

    var gl = canvas.getGLContext();
    _this._m_Width = cfg.width || canvas.getWidth();
    _this._m_Height = cfg.height || canvas.getHeight();
    _this._m_FixedSize = cfg.fixedSize != null ? cfg.fixedSize : false;

    _this._m_ViewMatrix.lookAt(_this._m_Eye, _this._m_At, _this._m_Up); // this._m_ProjectMatrix.perspectiveM(this._m_Fovy, this._m_FixedAspect ? this._m_FixedAspect : (this._m_Width * 1.0 / this._m_Height), 0.1, 1000);


    _this._m_ViewMatrixUpdate = true;
    _this._m_ProjectMatrixUpdate = true;
    _this._m_UpdateCameraPosition = true;
    gl.viewport(0, 0, _this._m_Width, _this._m_Height);

    _this._init();

    canvas.on('resize', function () {
      if (!_this._m_FixedSize) {
        _this._m_Width = canvas.getWidth();
        _this._m_Height = canvas.getHeight();

        if (_this._m_IsRenderingCamera) {
          gl.viewport(0, 0, _this._m_Width, _this._m_Height);
        } // 直接展开而非函数调用,减少开销


        if (_this._m_ParallelProjection) {
          _this._m_ProjectMatrix.parallelM(_this._m_FrustumLeft, _this._m_FrustumRight, _this._m_FrustumTop, _this._m_FrustumBottom, _this._m_FrustumNear, _this._m_FrustumFar);
        } else {
          _this._m_ProjectMatrix.perspectiveM(_this._m_Fovy, _this._m_FixedAspect ? _this._m_FixedAspect : _this._m_Width * 1.0 / _this._m_Height, _this._m_FrustumNear, _this._m_FrustumFar);
        }

        _this._m_ProjectMatrixUpdate = true;
      }

      _this._doUpdate();
    }); // FilterPost

    _this._m_Filters = []; // postFilter

    _this._m_Scene.getRender().on(_Render.default.POST_QUEUE, function (renderQueue) {
      if (_this._m_IsRenderingCamera) {
        if (_this.demandFilter()) {
          _this._m_Filters.forEach(function (filter) {
            if (filter.isEnable()) {
              filter.preFrame();
            }
          });
        }
      }
    });

    _this._m_Scene.getRender().on(_Render.default.POST_FRAME, function (exTime) {
      if (_this._m_IsRenderingCamera) {
        if (_this.demandFilter()) {
          _this._m_Filters.forEach(function (filter) {
            if (filter.isEnable()) {
              filter.postFilter(); // 更新缓冲区

              _this._m_Scene.getRender().swapPostFilter();
            }
          });
        }
      }
    });

    return _this;
  }
  /**
   * 初始化。<br/>
   * @private
   */


  _createClass(Camera, [{
    key: "_init",
    value: function _init() {
      if (this._m_ParallelProjection) {
        // 默认初始化的平行投影视锥
        this._m_FrustumNear = 1.0;
        this._m_FrustumFar = 2.0;
        this._m_FrustumLeft = -0.5;
        this._m_FrustumRight = 0.5;
        this._m_FrustumTop = 0.5;
        this._m_FrustumBottom = -0.5;

        this._m_ProjectMatrix.parallelM(this._m_FrustumLeft, this._m_FrustumRight, this._m_FrustumTop, this._m_FrustumBottom, this._m_FrustumNear, this._m_FrustumFar);
      } else {
        // 默认是一个透视相机,所以这里基于透视算法建立投影平面
        // 这里直接基于fovY(45),near=0.1和far1000预建
        var defaultAspect = this._m_Width * 1.0 / this._m_Height;
        var h = Math.tan(_MoreMath.default.toRadians(this._m_Fovy) * 0.5) * 0.1;
        var w = h * defaultAspect;

        _Log.default.debug("w:" + w + ";h:" + h + ";as:" + defaultAspect);

        this._m_FrustumLeft = -w;
        this._m_FrustumRight = w;
        this._m_FrustumBottom = -h;
        this._m_FrustumTop = h;
        this._m_FrustumNear = 0.1;
        this._m_FrustumFar = 1000;

        this._m_ProjectMatrix.perspectiveM(this._m_Fovy, this._m_FixedAspect ? this._m_FixedAspect : this._m_Width * 1.0 / this._m_Height, this._m_FrustumNear, this._m_FrustumFar);
      } // 预建缓存


      var frameContext = this._m_Scene.getRender().getFrameContext();

      var gl = this._m_Scene.getCanvas().getGLContext();

      if (!frameContext.getContextBlock('MAT')) {
        var MAT = gl.createBuffer();
        this.MAT = MAT;
        gl.bindBuffer(gl.UNIFORM_BUFFER, MAT);
        gl.bufferData(gl.UNIFORM_BUFFER, 3 * 16 * 4, gl.STATIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, _ShaderSource.default.BLOCKS['MAT'].blockIndex, MAT, 0, 3 * 16 * 4);
        frameContext.addContextBlock('MAT', this.MAT);
      } else {
        this.MAT = frameContext.getContextBlock('MAT');
      }

      if (!frameContext.getContextBlock('VIEW')) {
        var VIEW = gl.createBuffer();
        this.VIEW = VIEW;
        gl.bindBuffer(gl.UNIFORM_BUFFER, VIEW);
        gl.bufferData(gl.UNIFORM_BUFFER, 3 * 4, gl.STATIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, _ShaderSource.default.BLOCKS['VIEW'].blockIndex, VIEW, 0, 3 * 4);
        frameContext.addContextBlock('VIEW', this.VIEW);
      } else {
        this.VIEW = frameContext.getContextBlock('VIEW');
      }

      this._doUpdate();
    }
    /**
     * 设置锥体截面。<br/>
     * @param {Number}[left]
     * @param {Number}[right]
     * @param {Number}[top]
     * @param {Number}[bottom]
     * @param {Number}[near]
     * @param {Number}[far]
     */

  }, {
    key: "setFrustum",
    value: function setFrustum(left, right, top, bottom, near, far) {
      this._m_FrustumNear = near;
      this._m_FrustumFar = far;
      this._m_FrustumLeft = left;
      this._m_FrustumRight = right;
      this._m_FrustumTop = top;
      this._m_FrustumBottom = bottom;

      this._m_ProjectMatrix.parallelM(this._m_FrustumLeft, this._m_FrustumRight, this._m_FrustumTop, this._m_FrustumBottom, this._m_FrustumNear, this._m_FrustumFar);
    }
    /**
     * 根据视角fovy,视口aspect,视锥near与far设置透视投影矩阵。<br/>
     * @param {Number}[fovy]
     * @param {Number}[aspect]
     * @param {Number}[near]
     * @param {Number}[far]
     */

  }, {
    key: "setFrustumPerspective",
    value: function setFrustumPerspective(fovy, aspect, near, far) {
      // 无论如何,调用这个方法意味着变成了透视投影相机
      this._m_ParallelProjection = false;
      this._m_Fovy = fovy;
      this._m_FixedAspect = aspect;
      var h = Math.tan(_MoreMath.default.toRadians(this._m_Fovy) * 0.5) * near;
      var w = h * this._m_FixedAspect; // Log.debug("w:" + w + ";h:" + h + ";as:" + this._m_FixedAspect);

      this._m_FrustumLeft = -w;
      this._m_FrustumRight = w;
      this._m_FrustumBottom = -h;
      this._m_FrustumTop = h;
      this._m_FrustumNear = near;
      this._m_FrustumFar = far;

      this._m_ProjectMatrix.perspectiveM(this._m_Fovy, this._m_FixedAspect ? this._m_FixedAspect : this._m_Width * 1.0 / this._m_Height, this._m_FrustumNear, this._m_FrustumFar);
    }
    /**
     * 强行更行投影矩阵。<br/>
     */

  }, {
    key: "forceUpdateProjection",
    value: function forceUpdateProjection() {
      if (this._m_ParallelProjection) {
        this._m_ProjectMatrix.parallelM(this._m_FrustumLeft, this._m_FrustumRight, this._m_FrustumTop, this._m_FrustumBottom, this._m_FrustumNear, this._m_FrustumFar);
      } else {
        this._m_ProjectMatrix.perspectiveM(this._m_Fovy, this._m_FixedAspect ? this._m_FixedAspect : this._m_Width * 1.0 / this._m_Height, this._m_FrustumNear, this._m_FrustumFar);
      }
    }
    /**
     * 添加一个后处理。<br/>
     * @param {Material}[material]
     */

  }, {
    key: "addFilterFromMaterial",
    value: function addFilterFromMaterial(material) {
      var newFilter = _Filter.default.newFilterFromMaterial(this, material);

      this._m_Filters.push(newFilter);

      return newFilter;
    }
    /**
     * 添加一个场景处理器。<br/>
     * @param {Object}[filter]
     * @param {Number}[priority 优先级]
     */

  }, {
    key: "addFilter",
    value: function addFilter(filter, priority) {
      var cur = [];
      var i = 0;

      for (var len = Math.min(priority, this._m_Filters.length); i < len; i++) {
        cur.push(this._m_Filters[i]);
      }

      cur.push(filter);
      i++;

      for (var _len = this._m_Filters.length; i < _len; i++) {
        cur.push(this._m_Filters[i]);
      }

      this._m_Filters = cur;
    }
    /**
     * 返回所有后处理器。<br/>
     * @return {Filter[]}
     */

  }, {
    key: "getFilters",
    value: function getFilters() {
      return this._m_Filters;
    }
    /**
     * 要求后处理。<br/>
     * @return {Boolean}
     */

  }, {
    key: "demandFilter",
    value: function demandFilter() {
      return this._m_Filters != null && this._m_Filters.length > 0;
    }
    /**
     * 返回Left截面。<br/>
     * @return {Number}
     */

  }, {
    key: "getLeft",
    value: function getLeft() {
      return this._m_FrustumLeft;
    }
    /**
     * 返回Right截面。<br/>
     *@return {Number}
     */

  }, {
    key: "getRight",
    value: function getRight() {
      return this._m_FrustumRight;
    }
    /**
     * 返回Top截面。<br/>
     * @return {Number}
     */

  }, {
    key: "getTop",
    value: function getTop() {
      return this._m_FrustumTop;
    }
    /**
     * 返回Bottom截面。<br/>
     * @return {Number}
     */

  }, {
    key: "getBottom",
    value: function getBottom() {
      return this._m_FrustumBottom;
    }
    /**
     * 返回Near截面。<br/>
     * @return {Number}
     */

  }, {
    key: "getNear",
    value: function getNear() {
      return this._m_FrustumNear;
    }
    /**
     * 返回Far截面。<br/>
     * @return {Number}
     */

  }, {
    key: "getFar",
    value: function getFar() {
      return this._m_FrustumFar;
    }
    /**
     * 设置Far截面。<br/>
     * @param {Number}[far]
     */

  }, {
    key: "setFar",
    value: function setFar(far) {
      this._m_FrustumFar = far;
    }
    /**
     * 设置为渲染相机。<br/>
     * @param {Boolean}[isMainCamera]
     */

  }, {
    key: "setIsRenderingCamera",
    value: function setIsRenderingCamera(isMainCamera) {
      this._m_IsRenderingCamera = isMainCamera;
      this._m_UpdateCameraPosition = true;
      this._m_ViewMatrixUpdate = true;
      this._m_ProjectMatrixUpdate = true;
      this._m_ProjectViewMatrixUpdate = true;

      if (isMainCamera) {
        // 更新一次数据,避免延帧渲染
        this._doUpdate(true);
      }
    }
    /**
     * 返回指定的视锥体平面。<br/>
     * @param {Number}[planeId 参考Camera的常量]
     * @return {*}
     */

  }, {
    key: "getFrustumPlane",
    value: function getFrustumPlane(planeId) {
      return this._m_FrustumPlane[planeId];
    }
    /**
     * 返回视锥体掩码。<br/>
     * @return {Number}
     */

  }, {
    key: "getFrustumMask",
    value: function getFrustumMask() {
      return this._m_FrustumMask;
    }
    /**
     * 设置视锥体掩码，以便加速剔除。<br/>
     * @param {Number}[frustumMask]
     */

  }, {
    key: "setFrustumMask",
    value: function setFrustumMask(frustumMask) {
      this._m_FrustumMask = frustumMask;
    }
    /**
     * 返回观察点。<br/>
     * @returns {Vector3}[at]
     */

  }, {
    key: "getAt",
    value: function getAt() {
      return this._m_At;
    }
    /**
     * 设置观察点。<br/>
     * @param {Vector3}[at]
     */

  }, {
    key: "setAt",
    value: function setAt(at) {
      this._m_At.setTo(at);
    }
    /**
     * 返回相机位置。<br/>
     * @returns {Vector3}[eye]
     */

  }, {
    key: "getEye",
    value: function getEye() {
      return this._m_Eye;
    }
    /**
     * 设置相机位置。<br/>
     * @param {Vector3}[eye]
     */

  }, {
    key: "setEye",
    value: function setEye(eye) {
      this._m_Eye.setTo(eye);
    }
    /**
     * 返回相机抬头朝向。<br/>
     * @returns {Vector3}[up]
     */

  }, {
    key: "getUp",
    value: function getUp() {
      return this._m_Up;
    }
    /**
     * 设置相机抬头朝向。<br/>
     * @param {Vector3}[up]
     */

  }, {
    key: "setUp",
    value: function setUp(up) {
      this._m_Up.setTo(up);
    }
    /**
     * 返回方向。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getDir",
    value: function getDir() {
      return this._m_Dir;
    }
    /**
     * 设置镜头eye,at,up。<br/>
     * @param {Vector3}[eye]
     * @param {Vector3}[at]
     * @param {Vector3}[up]
     */

  }, {
    key: "lookAt",
    value: function lookAt(eye, at, up) {
      this._m_Eye.setTo(eye);

      this._m_At.setTo(at);

      this._m_At.sub(this._m_Eye, this._m_Dir);

      this._m_Dir.normal();

      up.cross(this._m_Dir, Camera.S_TEMP_VEC3).normal();

      this._m_Dir.cross(Camera.S_TEMP_VEC3, this._m_Up).normal(); // this._m_Up.setTo(up);


      this._m_ViewMatrix.lookAt(this._m_Eye, this._m_At, this._m_Up);

      this._m_ViewMatrixUpdate = true;

      this._doUpdate();
    }
    /**
     * 是否为平行投影相机。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isParallelProjection",
    value: function isParallelProjection() {
      return this._m_ParallelProjection;
    }
    /**
     * 更新视锥体。<br/>
     * @private
     */

  }, {
    key: "_updateFrustum",
    value: function _updateFrustum() {
      // 计算更新变量
      if (this._m_ParallelProjection) {
        // 这里根据相机类型更新计算变量(透视和平行相机计算方式不同)
        this._m_CoeffLeft[0] = 1.0;
        this._m_CoeffLeft[1] = 0.0;
        this._m_CoeffRight[0] = -1.0;
        this._m_CoeffRight[1] = 0.0;
        this._m_CoeffBottom[0] = 1.0;
        this._m_CoeffBottom[1] = 0.0;
        this._m_CoeffTop[0] = -1.0;
        this._m_CoeffTop[1] = 0.0;
      } else {
        // 这里根据相机类型更新计算变量(透视和平行相机计算方式不同)
        var nearSquared = this._m_FrustumNear * this._m_FrustumNear;
        var leftSquared = this._m_FrustumLeft * this._m_FrustumLeft;
        var rightSquared = this._m_FrustumRight * this._m_FrustumRight;
        var bottomSquared = this._m_FrustumBottom * this._m_FrustumBottom;
        var topSquared = this._m_FrustumTop * this._m_FrustumTop;
        var inverseLength = 1.0 / Math.sqrt(nearSquared + leftSquared);
        this._m_CoeffLeft[0] = -this._m_FrustumNear * inverseLength;
        this._m_CoeffLeft[1] = -this._m_FrustumLeft * inverseLength;
        inverseLength = 1.0 / Math.sqrt(nearSquared + rightSquared);
        this._m_CoeffRight[0] = this._m_FrustumNear * inverseLength;
        this._m_CoeffRight[1] = this._m_FrustumRight * inverseLength;
        inverseLength = 1.0 / Math.sqrt(nearSquared + bottomSquared);
        this._m_CoeffBottom[0] = this._m_FrustumNear * inverseLength;
        this._m_CoeffBottom[1] = -this._m_FrustumBottom * inverseLength;
        inverseLength = 1.0 / Math.sqrt(nearSquared + topSquared);
        this._m_CoeffTop[0] = -this._m_FrustumNear * inverseLength;
        this._m_CoeffTop[1] = this._m_FrustumTop * inverseLength;
      } // 更新视锥体6平面


      Camera.S_TEMP_VEC3.setToInXYZ(-this._m_ViewMatrix.m[0], -this._m_ViewMatrix.m[4], -this._m_ViewMatrix.m[8]);
      Camera.S_TEMP_VEC3_2.setToInXYZ(this._m_ViewMatrix.m[1], this._m_ViewMatrix.m[5], this._m_ViewMatrix.m[9]);
      Camera.S_TEMP_VEC3_3.setTo(this._m_Dir);
      var dirDotEye = Camera.S_TEMP_VEC3_3.dot(this._m_Eye); // left plane

      var leftPlaneNormal = this._m_FrustumPlane[Camera.S_LEFT_PLANE].getNormal();

      leftPlaneNormal._m_X = Camera.S_TEMP_VEC3._m_X * this._m_CoeffLeft[0];
      leftPlaneNormal._m_Y = Camera.S_TEMP_VEC3._m_Y * this._m_CoeffLeft[0];
      leftPlaneNormal._m_Z = Camera.S_TEMP_VEC3._m_Z * this._m_CoeffLeft[0];
      leftPlaneNormal.addInXYZ(Camera.S_TEMP_VEC3_3._m_X * this._m_CoeffLeft[1], Camera.S_TEMP_VEC3_3._m_Y * this._m_CoeffLeft[1], Camera.S_TEMP_VEC3_3._m_Z * this._m_CoeffLeft[1]);

      this._m_FrustumPlane[Camera.S_LEFT_PLANE].setD(this._m_Eye.dot(leftPlaneNormal)); // right plane


      var rightPlaneNormal = this._m_FrustumPlane[Camera.S_RIGHT_PLANE].getNormal();

      rightPlaneNormal._m_X = Camera.S_TEMP_VEC3._m_X * this._m_CoeffRight[0];
      rightPlaneNormal._m_Y = Camera.S_TEMP_VEC3._m_Y * this._m_CoeffRight[0];
      rightPlaneNormal._m_Z = Camera.S_TEMP_VEC3._m_Z * this._m_CoeffRight[0];
      rightPlaneNormal.addInXYZ(Camera.S_TEMP_VEC3_3._m_X * this._m_CoeffRight[1], Camera.S_TEMP_VEC3_3._m_Y * this._m_CoeffRight[1], Camera.S_TEMP_VEC3_3._m_Z * this._m_CoeffRight[1]);

      this._m_FrustumPlane[Camera.S_RIGHT_PLANE].setD(this._m_Eye.dot(rightPlaneNormal)); // bottom plane


      var bottomPlaneNormal = this._m_FrustumPlane[Camera.S_BOTTOM_PLANE].getNormal();

      bottomPlaneNormal._m_X = Camera.S_TEMP_VEC3_2._m_X * this._m_CoeffBottom[0];
      bottomPlaneNormal._m_Y = Camera.S_TEMP_VEC3_2._m_Y * this._m_CoeffBottom[0];
      bottomPlaneNormal._m_Z = Camera.S_TEMP_VEC3_2._m_Z * this._m_CoeffBottom[0];
      bottomPlaneNormal.addInXYZ(Camera.S_TEMP_VEC3_3._m_X * this._m_CoeffBottom[1], Camera.S_TEMP_VEC3_3._m_Y * this._m_CoeffBottom[1], Camera.S_TEMP_VEC3_3._m_Z * this._m_CoeffBottom[1]);

      this._m_FrustumPlane[Camera.S_BOTTOM_PLANE].setD(this._m_Eye.dot(bottomPlaneNormal)); // top plane


      var topPlaneNormal = this._m_FrustumPlane[Camera.S_TOP_PLANE].getNormal();

      topPlaneNormal._m_X = Camera.S_TEMP_VEC3_2._m_X * this._m_CoeffTop[0];
      topPlaneNormal._m_Y = Camera.S_TEMP_VEC3_2._m_Y * this._m_CoeffTop[0];
      topPlaneNormal._m_Z = Camera.S_TEMP_VEC3_2._m_Z * this._m_CoeffTop[0];
      topPlaneNormal.addInXYZ(Camera.S_TEMP_VEC3_3._m_X * this._m_CoeffTop[1], Camera.S_TEMP_VEC3_3._m_Y * this._m_CoeffTop[1], Camera.S_TEMP_VEC3_3._m_Z * this._m_CoeffTop[1]);

      this._m_FrustumPlane[Camera.S_TOP_PLANE].setD(this._m_Eye.dot(topPlaneNormal)); // 如果是平行投影的话,需要修正left,right,top,bottom的边界


      if (this._m_ParallelProjection) {
        this._m_FrustumPlane[Camera.S_LEFT_PLANE].setD(this._m_FrustumPlane[Camera.S_LEFT_PLANE].getD() + this._m_FrustumLeft);

        this._m_FrustumPlane[Camera.S_RIGHT_PLANE].setD(this._m_FrustumPlane[Camera.S_RIGHT_PLANE].getD() - this._m_FrustumRight);

        this._m_FrustumPlane[Camera.S_TOP_PLANE].setD(this._m_FrustumPlane[Camera.S_TOP_PLANE].getD() - this._m_FrustumTop);

        this._m_FrustumPlane[Camera.S_BOTTOM_PLANE].setD(this._m_FrustumPlane[Camera.S_BOTTOM_PLANE].getD() + this._m_FrustumBottom);
      } // far plane


      this._m_FrustumPlane[Camera.S_FAR_PLANE].setNormaXYZ(-Camera.S_TEMP_VEC3_3._m_X, -Camera.S_TEMP_VEC3_3._m_Y, -Camera.S_TEMP_VEC3_3._m_Z);

      this._m_FrustumPlane[Camera.S_FAR_PLANE].setD(-(dirDotEye + this._m_FrustumFar)); // near plane


      this._m_FrustumPlane[Camera.S_NEAR_PLANE].setNormaXYZ(Camera.S_TEMP_VEC3_3._m_X, Camera.S_TEMP_VEC3_3._m_Y, Camera.S_TEMP_VEC3_3._m_Z);

      this._m_FrustumPlane[Camera.S_NEAR_PLANE].setD(dirDotEye + this._m_FrustumNear); // console.log("6平面:",this._m_FrustumPlane);
      // console.log("left:" + Camera.S_TEMP_VEC3.toString());
      // console.log("up:" + Camera.S_TEMP_VEC3_2.toString());
      // console.log("dir:" + Camera.S_TEMP_VEC3_3.toString());
      // console.log("pos:" + this._m_Eye.toString());
      // console.log("viewMatrix:" + this._m_ViewMatrix.toString());

    }
    /**
     * 更新相机。<br/>
     * @private
     */

  }, {
    key: "_update",
    value: function _update() {
      var gl = this._m_Scene.getCanvas().getGLContext();

      gl.bindBuffer(gl.UNIFORM_BUFFER, this.MAT);

      var frameContext = this._m_Scene.getRender().getFrameContext();

      if (this._m_ViewMatrixUpdate) {
        this._m_UpdateCameraPosition = true;
        this._m_ProjectViewMatrixUpdate = true;

        if (frameContext.getContext(_ShaderSource.default.S_VIEW_MATRIX_SRC) || frameContext.getContext(_ShaderSource.default.S_VP_SRC) || frameContext.getContext(_ShaderSource.default.S_MVP_SRC)) {
          if (this._m_IsRenderingCamera) {
            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this._m_ViewMatrix.getBufferData());
            frameContext.setCalcContext(_ShaderSource.default.S_VIEW_MATRIX_SRC, this._m_ViewMatrix);
          }

          this._m_ViewMatrixUpdate = false;
        }
      }

      if (this._m_ProjectMatrixUpdate) {
        this._m_ProjectViewMatrixUpdate = true;

        if (frameContext.getContext(_ShaderSource.default.S_PROJECT_MATRIX_SRC) || frameContext.getContext(_ShaderSource.default.S_VP_SRC) || frameContext.getContext(_ShaderSource.default.S_MVP_SRC)) {
          if (this._m_IsRenderingCamera) {
            gl.bufferSubData(gl.UNIFORM_BUFFER, 16 * 4, this._m_ProjectMatrix.getBufferData());
            frameContext.setCalcContext(_ShaderSource.default.S_PROJECT_MATRIX_SRC, this._m_ProjectMatrix);
          }

          this._m_ProjectMatrixUpdate = false;
        }
      } // 检测其他需要的context


      if (this._m_ProjectViewMatrixUpdate && frameContext.getContext(_ShaderSource.default.S_VP_SRC)) {
        _Matrix.default.multiplyMM(this._m_ProjectViewMatrix, 0, this._m_ProjectMatrix, 0, this._m_ViewMatrix, 0);

        if (this._m_IsRenderingCamera) {
          gl.bufferSubData(gl.UNIFORM_BUFFER, 32 * 4, this._m_ProjectViewMatrix.getBufferData());
          frameContext.setCalcContext(_ShaderSource.default.S_VP_SRC, this._m_ProjectViewMatrix);
        }

        this._m_ProjectViewMatrixUpdate = false;
      }

      gl.bindBuffer(gl.UNIFORM_BUFFER, null); // view

      if (this._m_UpdateCameraPosition) {
        if (frameContext.getContext(_ShaderSource.default.S_CAMERA_POSITION_SRC)) {
          if (this._m_IsRenderingCamera) {
            gl.bindBuffer(gl.UNIFORM_BUFFER, this.VIEW);
            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this._m_Eye.getBufferData());
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
          }

          this._m_UpdateCameraPosition = false;
        }
      }

      if (this._m_ViewMatrixUpdate || this._m_ProjectMatrixUpdate || this._m_ProjectViewMatrixUpdate) {
        this._doUpdate();
      } // 更新视锥体(这里应该使用一个标记变量检测是否应该更新,但是现在暂时在每次_update()里调用更新Frustum)


      this._updateFrustum();

      this.fire(Camera.S_CAMERA_UPDATE_EVENT, [this._m_ViewMatrix, this._m_ProjectMatrix, this._m_ProjectViewMatrix]);
    }
    /**
     * 设置视图矩阵。<br/>
     * @param {Matrix44}[viewMatrix]
     */

  }, {
    key: "setViewMatrix",
    value: function setViewMatrix(viewMatrix) {
      this._m_ViewMatrix.set(viewMatrix); // 从矩阵中计算eye,at,up
      // 可能每次更新矩阵时这么去处理开销有点大,所以要更新物体时,最好调用Camera.lookAt(),而不是该方法


      var g = this._m_ViewMatrix.inertRetNew(_TempVars.default.S_TEMP_MAT4);

      if (g) {
        this._m_Eye.setToInXYZ(g.m[12], g.m[13], g.m[14]);

        this._m_Up.setToInXYZ(g.m[4], g.m[5], g.m[6]); // 别忘了ndc是右手


        _TempVars.default.S_TEMP_VEC3.setToInXYZ(-g.m[8], -g.m[9], -g.m[10]);

        _TempVars.default.S_TEMP_VEC3.add(this._m_Eye, this._m_At);

        this._m_At.sub(this._m_Eye, this._m_Dir);

        this._m_Dir.normal();
      }

      this._m_ViewMatrixUpdate = true;

      this._doUpdate();
    }
    /**
     * 获取视图矩阵。<br/>
     * @returns {Matrix44}[viewMatrix]
     */

  }, {
    key: "getViewMatrix",
    value: function getViewMatrix() {
      return this._m_ViewMatrix;
    }
    /**
     * 返回投影视图矩阵。<br/>
     * @param {Boolean}[ref 由于ProjectViewMatrix根据渲染引擎自动计算，但有时并非用到，所以这里可以强制计算]
     * @return {Matrix44}
     */

  }, {
    key: "getProjectViewMatrix",
    value: function getProjectViewMatrix(ref) {
      if (ref) {
        _Matrix.default.multiplyMM(this._m_ProjectViewMatrix, 0, this._m_ProjectMatrix, 0, this._m_ViewMatrix, 0);
      }

      return this._m_ProjectViewMatrix;
    }
    /**
     * 设置投影矩阵。<br/>
     * @param {Matrix44}[projectMatrix]
     */

  }, {
    key: "setProjectMatrix",
    value: function setProjectMatrix(projectMatrix) {
      this._m_ProjectMatrix.set(projectMatrix);

      this._m_ProjectMatrixUpdate = true;

      this._doUpdate();
    }
    /**
     * 返回相机高度。<br/>
     * @return {Number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      // let canvas = this._m_Scene.getCanvas();
      // return canvas.getHeight();
      return this._m_Height;
    }
    /**
     * 返回当前相机宽度。<br/>
     * @return {Number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      // let canvas = this._m_Scene.getCanvas();
      // return canvas.getWidth();
      return this._m_Width;
    }
    /**
     * 滚动相机。
     * @param {Number}[zoom 滚动量,非累计量]
     */

  }, {
    key: "scroll",
    value: function scroll(zoom) {
      this._m_ProjectMatrix.perspectiveM(zoom, this._m_Width * 1.0 / this._m_Height, this._m_FrustumNear, this._m_FrustumFar);

      this._m_ProjectMatrixUpdate = true;

      this._doUpdate();
    }
    /**
     * 返回投影矩阵。<br/>
     * @returns {Matrix44}[projectMatrix]
     */

  }, {
    key: "getProjectMatrix",
    value: function getProjectMatrix() {
      return this._m_ProjectMatrix;
    }
    /**
     * 判断一个包围体与视锥体的包含关系。<br/>
     * @param {BoundingVolume}[boundingVolume]
     * @return {Number}[返回Camera.S_FRUSTUM_INTERSECT_INSIDE(包含),Camera.S_FRUSTUM_INTERSECT_OUTSIDE(不包含)以及Camera.S_FRUSTUM_INTERSECT_INSIDE(相交)]
     */

  }, {
    key: "frustumContains",
    value: function frustumContains(boundingVolume) {
      // 检测当前包围体是否处于视锥体中
      // 不同包围体使用不同的算法进行
      if (boundingVolume) {
        // 判断与视锥体6平面关系
        var mask = 0;
        var planeId = 0;
        var side = 0;
        var contains = Camera.S_FRUSTUM_INTERSECT_INSIDE;

        for (var i = 6; i >= 0; i--) {
          if (i == boundingVolume.getPriorityPlane()) {
            continue;
          } // 获取优先检测面


          planeId = i == 6 ? boundingVolume.getPriorityPlane() : i;
          mask = 1 << planeId; // 判断是否经过检测

          if ((this._m_FrustumMask & mask) == 0) {
            // 检测该截面
            side = boundingVolume.whichSide(this._m_FrustumPlane[planeId]);

            if (side == _Plane.default.S_SIDE_NEGATIVE) {
              // 只要处于任意一个截面的外部,则表明该节点应该被剔除
              // 下次优先检测剔除截面
              boundingVolume.setPriorityPlane(planeId);
              return Camera.S_FRUSTUM_INTERSECT_OUTSIDE;
            } else if (side == _Plane.default.S_SIDE_POSITIVE) {
              // 说明有至少位于某个截面正面
              // 子节点跳过这个截面,因为已经检测过该截面
              this._m_FrustumMask |= mask;
            } else {
              // 当前与截面相交
              contains = Camera.S_FRUSTUM_INTERSECT_INTERSECTS;
            }
          }
        }

        return contains;
      } else {
        // 如果没有包围体,当作包含处理(当理论上,该叶子节点是一个不需要渲染的node)
        return Camera.S_FRUSTUM_INTERSECT_INSIDE;
      }
    }
    /**
     * 从平面空间坐标以及z投射计算并返回世界中的坐标。<br/>
     * screenPosition.x表示屏幕上面0-width之间的位置值,screenPosition.y表示屏幕上面0-height之间的位置值。<br/>
     * 其中中心点在屏幕中间，对于z投射，0-1表示分布在近截面与远界面的非线性投射，为1时表示完全投射到屏幕边界，为0时表示投射到屏幕中心点。<br/>
     * @param {Vector2}[screenPosition 屏幕空间坐标]
     * @param {Number}[projectionZPos z投射]
     * @param {Boolean}[viewSpace true表示计算基于viewSpace]
     * @param {Vector3}[result 计算结果]
     * @return {Vector3}
     */

  }, {
    key: "getWorldCoordinates",
    value: function getWorldCoordinates(screenPosition, projectionZPos, viewSpace, result) {
      if (!result) {
        result = new _Vector.default();
      } // 由于没有强制更新ProjectViewMatrix,所以需要在这里进行计算(这一部分可以优化)


      if (viewSpace) {
        _Matrix.default.multiplyMM(this._m_ProjectViewMatrix, 0, this._m_ProjectMatrix, 0, this._m_ViewMatrix, 0);

        Camera.S_TEMP_MAT4.set(this._m_ProjectViewMatrix);
      } else {
        Camera.S_TEMP_MAT4.set(this._m_ProjectMatrix);
      } // 逆矩阵


      Camera.S_TEMP_MAT4.inert(); // 计算世界坐标

      var w = this.getWidth();
      var h = this.getHeight(); // 视口以左下角原点(但位于屏幕中心)

      var viewPortLeft = 0.0;
      var viewPortBottom = 0.0;
      var viewPortRight = 1.0;
      var viewPortTop = 1.0; // 变换回NDC空间

      Camera.S_TEMP_VEC3.setToInXYZ((screenPosition._m_X / w - viewPortLeft) / (viewPortRight - viewPortLeft) * 2 - 1, (screenPosition._m_Y / h - viewPortBottom) / (viewPortTop - viewPortBottom) * 2 - 1, projectionZPos * 2.0 - 1.0); // 变换回世界空间(这里直接执行pv逆变换似乎会导致错误,不知道为啥,难道是我求逆矩阵的逻辑有问题？)
      // 所以先变换会投影空间

      var pw = _Matrix.default.multiplyMV3(result, Camera.S_TEMP_VEC3, Camera.S_TEMP_MAT4);

      result.multLength(1.0 / pw);
      return result;
    }
  }]);

  return Camera;
}(_Component2.default);

exports["default"] = Camera;

_defineProperty(Camera, "S_TEMP_MAT4", new _Matrix.default());

_defineProperty(Camera, "S_TEMP_VEC3", new _Vector.default());

_defineProperty(Camera, "S_TEMP_VEC3_2", new _Vector.default());

_defineProperty(Camera, "S_TEMP_VEC3_3", new _Vector.default());

_defineProperty(Camera, "S_TEMP_VEC3_4", new _Vector.default());

_defineProperty(Camera, "S_CAMERA_UPDATE_EVENT", 'camera_update_event');

_defineProperty(Camera, "S_FRUSTUM_INTERSECT_INTERSECTS", 0);

_defineProperty(Camera, "S_FRUSTUM_INTERSECT_INSIDE", 1);

_defineProperty(Camera, "S_FRUSTUM_INTERSECT_OUTSIDE", 2);

_defineProperty(Camera, "S_LEFT_PLANE", 0);

_defineProperty(Camera, "S_RIGHT_PLANE", 1);

_defineProperty(Camera, "S_BOTTOM_PLANE", 2);

_defineProperty(Camera, "S_TOP_PLANE", 3);

_defineProperty(Camera, "S_FAR_PLANE", 4);

_defineProperty(Camera, "S_NEAR_PLANE", 5);

/***/ }),

/***/ 4939:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _Canvas = _interopRequireDefault(__webpack_require__(5109));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Queue = _interopRequireDefault(__webpack_require__(5489));

var _Light = _interopRequireDefault(__webpack_require__(513));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Picture = _interopRequireDefault(__webpack_require__(7280));

var _GIProbe = _interopRequireDefault(__webpack_require__(2815));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Scene表示渲染一个3D世界的容器，包含各种组件，但它不能作为其他组件的子组件。<br/>
 * @author JhonKkk
 */
var Scene = /*#__PURE__*/function (_Component) {
  _inherits(Scene, _Component);

  var _super = _createSuper(Scene);

  /**
   * 创建一个场景。<br/>
   * @param {String}[cfg.id]
   * @param {DOM}[cfg.canvas]
   */
  function Scene(cfg) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _super.call(this, null, cfg); // 创建一个默认渲染器组件,一个场景可以附加多个渲染器组件
    // 但是每次应该只激活其中一个渲染器
    // 这样,场景可以根据需要,使用不同的渲染器进行渲染
    // 所有该场景的渲染器共享同一个场景实例的好处是:
    // 可以添加一个实时渲染器,用于实时交互
    // 然后添加一个光追渲染器,用于渲染高质量图片

    _this._m_TaskQueue = new _Queue.default();
    _this._m_Canvas = new _Canvas.default(_assertThisInitialized(_this), {
      id: "default_canvas",
      canvas: cfg.cavnas
    });
    _this._m_Render = new _Render.default(_assertThisInitialized(_this), {
      id: "default_render"
    });
    _this._m_MainCamera = new _Camera.default(_assertThisInitialized(_this), {
      id: "mainCamera"
    });
    _this._m_FrustumCullingCamera = _this._m_MainCamera;

    _this._m_MainCamera.setIsRenderingCamera(true); // 场景节点


    _this._m_Nodes = []; // 场景节点名称映射列表

    _this._m_NodeIds = {}; // 灯光列表

    _this._m_Lights = [];
    _this._m_AmbientLightColor = new _Vector.default(1.0, 1.0, 1.0); // 激活灯光

    _this._m_EnableLights = []; // 可见光源

    _this._m_VisLights = []; // 灯光名称映射列表

    _this._m_LightIds = {}; // 激活灯光名称映射列表

    _this._m_EnableLightIds = {}; // GIProbes

    _this._m_GIProbes = [];
    _this._m_GIProbeIds = {}; // RefProbes

    _this._m_RefProbes = [];
    _this._m_RefProbeIds = {}; // 初始化

    _this._m_Render.startUp();

    return _this;
  }
  /**
   * 返回场景环境光。<br/>
   * @return {Vector3}
   * @constructor
   */


  _createClass(Scene, [{
    key: "getType",
    value: function getType() {
      return "Scene";
    }
  }, {
    key: "AmbientLightColor",
    get: function get() {
      return this._m_AmbientLightColor;
    }
    /**
     * 设置场景环境光。<br/>
     * @param {Number}[r]
     * @param {Number}[g]
     * @param {Number}[b]
     */

  }, {
    key: "setAmbientLightColor",
    value: function setAmbientLightColor(r, g, b) {
      this._m_AmbientLightColor.setToInXYZ(r, g, b);
    }
    /**
     * 返回所有灯光。<br/>
     * @return {Light[]}
     */

  }, {
    key: "getLights",
    value: function getLights() {
      return this._m_Lights;
    }
    /**
     * 返回激活的灯光。<br/>
     * @return {Array}
     */

  }, {
    key: "getEnableLights",
    value: function getEnableLights() {
      return this._m_EnableLights;
    }
    /**
     * 激活一个灯光。<br/>
     * @param {Light}[light]
     */

  }, {
    key: "enableLight",
    value: function enableLight(light) {
      if (!this._m_EnableLightIds[light.getId()]) {
        this._m_EnableLightIds[light.getId()] = light;
        light.enable();

        this._m_EnableLights.push(light);
      }
    }
    /**
     * 禁用一个灯光。<br/>
     * @param {Light}[light]
     */

  }, {
    key: "disableLight",
    value: function disableLight(light) {
      if (this._m_EnableLightIds[light.getId()]) {
        this._m_EnableLightIds[light.getId()] = null;
        light.disable();

        var i = this._m_EnableLights.indexOf(light);

        if (i > -1) {
          this._m_EnableLights.splice(i, 1);
        }
      }
    }
    /**
     * 返回可见光源。<br/>
     * @return {Array}
     */

  }, {
    key: "getVisLights",
    value: function getVisLights() {
      return this._m_VisLights;
    }
    /**
     * 返回指定灯光。<br/>
     * @param {Object}[lightId]
     * @return {Light}
     */

  }, {
    key: "getLight",
    value: function getLight(lightId) {
      return this._m_LightIds[lightId];
    }
    /**
     * 返回所有GIProbe。<br/>
     * @return {GIProbe[]}
     */

  }, {
    key: "getGIProbes",
    value: function getGIProbes() {
      return this._m_GIProbes;
    }
    /**
     * 返回是否有激活的GIProbe，由于目前未实现混合GIProbe，因此只检测第一个是否激活。<br/>
     * @return {boolean|Boolean}
     */

  }, {
    key: "enableGIProbes",
    value: function enableGIProbes() {
      return this._m_GIProbes.length > 0 && this._m_GIProbes[0].isEnable();
    }
    /**
     * 返回指定GIProbe。<br/>
     * @param {Object}[giProbeId]
     * @return {GIProbe}
     */

  }, {
    key: "getGIProbe",
    value: function getGIProbe(giProbeId) {
      return this._m_GIProbeIds[giProbeId];
    }
    /**
     * 添加一个更新任务到更新队列中。<br/>
     * @param {Object}[callback]
     * @param {Object}[scope]
     */

  }, {
    key: "scheduleTask",
    value: function scheduleTask(callback, scope) {
      this._m_TaskQueue.push(callback);

      this._m_TaskQueue.push(scope);
    }
    /**
     * 在给定的毫秒数之前弹出并处理队列中的任务。<br/>
     * @param until
     * @return {number}
     */

  }, {
    key: "runTasks",
    value: function runTasks() {
      var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var time = until > 0 ? new Date().getTime() : 0;
      var callback;
      var scope;
      var tasksRun = 0;
      var l = this._m_TaskQueue.length;

      while (l > 0 && (until < 0 || time < until)) {
        callback = this._m_TaskQueue.shift();
        scope = this._m_TaskQueue.shift();
        l -= 2;

        if (scope) {
          callback.call(scope);
        } else {
          callback();
        }

        if (until > 0) {
          time = new Date().getTime();
        }

        tasksRun++;
      }

      return tasksRun;
    }
    /**
     * 返回当前场景主相机。<br/>
     * 场景可以有多个相机,但是只能有一个主相机。<br/>
     * @returns {Camera}[当前场景主相机]
     */

  }, {
    key: "getMainCamera",
    value: function getMainCamera() {
      return this._m_MainCamera;
    }
    /**
     * 设置主摄像机。<br/>
     * @param {Camera}[mainCamera]
     */

  }, {
    key: "setMainCamera",
    value: function setMainCamera(mainCamera) {
      if (this._m_MainCamera != mainCamera && this._m_MainCamera) {
        this._m_MainCamera.setIsRenderingCamera(false);
      }

      this._m_MainCamera = mainCamera;

      this._m_MainCamera.setIsRenderingCamera(true);
    }
    /**
     * 设置剔除相机。<br/>
     * @param {Camera}[frustumCullingCamera]
     */

  }, {
    key: "setFrustumCullingCamera",
    value: function setFrustumCullingCamera(frustumCullingCamera) {
      this._m_FrustumCullingCamera = frustumCullingCamera;
    }
    /**
     * 返回视锥体剔除相机。<br/>
     * @return {Camera}
     */

  }, {
    key: "getFrustumCullingCamera",
    value: function getFrustumCullingCamera() {
      return this._m_FrustumCullingCamera;
    }
    /**
     * 返回当前场景渲染器。<br/>
     * @return {Render}
     */

  }, {
    key: "getRender",
    value: function getRender() {
      return this._m_Render;
    }
    /**
     * 返回当前渲染场景的呈现设备。<br/>
     * @returns {Object}[Canvas]
     */

  }, {
    key: "getCanvas",
    value: function getCanvas() {
      return this._m_Canvas;
    }
    /**
     * 设置天空盒。<br/>
     * @param {Sky}[sky]
     */

  }, {
    key: "setSky",
    value: function setSky(sky) {
      if (sky == null || sky.getType() == 'SkyBox') {
        this._m_Render.setSky(sky);
      }
    }
    /**
     * 返回天空盒。<br/>
     * @return {Sky}
     */

  }, {
    key: "getSky",
    value: function getSky() {
      return this._m_Render.getSky();
    }
    /**
     * 添加场景节点。<br/>
     * @param {Node}[node]
     */

  }, {
    key: "addSceneNode",
    value: function addSceneNode(node) {
      // 检测是否为Node(后面要进行场景管理,剔除,需要对类型为Node的组件进行收集)
      if (node instanceof _Node.default && !(node instanceof _Picture.default)) {
        if (!this._m_NodeIds[node.getId()]) {
          this._m_Nodes.push(node);

          this._m_NodeIds[node.getId()] = node;
        }
      }
    }
  }, {
    key: "getSceneNode",
    value: function getSceneNode(i) {
      return this._m_Nodes[i];
    }
    /**
     * 返回所有场景节点。<br/>
     * @return {Node[]}
     */

  }, {
    key: "getSceneNodes",
    value: function getSceneNodes() {
      return this._m_Nodes;
    }
    /**
     * 载入一个组件到scene中,场景对象将包含所有组件。<br/>
     * @param {Component}[component]
     */

  }, {
    key: "addComponentInScene",
    value: function addComponentInScene(component) {
      if (component instanceof _Component2.default) {
        if (!this._m_ComponentIDs[component.getId()]) {
          // 如果是scene,则跳过这个组件,所有的组件都是附加到scene中
          if (component.getType() != "Scene") {
            this._m_ComponentIDs[component.getId()] = component;

            this._m_Components.push(component);
          } // 检测是否为drawable
          // 其实应该在scene组件中维护drawables列表而不是render组件


          if (component.isDrawable && component.isDrawable()) {
            this._m_Render.addDrawable(component);
          } // 检测是否为light类型组件


          if (component instanceof _Light.default) {
            if (component instanceof _GIProbe.default) {
              if (!this._m_GIProbeIds[component.getId()]) {
                this._m_GIProbes.push(component);

                this._m_GIProbeIds[component.getId()] = component;
              }
            } else if (!this._m_LightIds[component.getId()]) {
              this._m_Lights.push(component);

              this._m_LightIds[component.getId()] = component; // 由于Light是Node的子类,而Node是Component的子类,因此在完成Component构造之前,Light还没构造完成(蛋疼...)
              // 所以会导致下面方法返回undefined,一种解决方案是让isEnable默认返回true,或者在Light构造中完成enableLight调用,这里选择第二种方案
              // if(component.isEnable()){
              //     this.enableLight(component);
              // }
            }
          }
        } else {
          console.warn("组件[[" + component.getId() + "]]已存在!!");
        }
      } else {
        console.error("component必须是一个Component对象!!");
      }
    }
    /**
     * 从场景移除一个组件
     * @param component
     */

  }, {
    key: "removeComponentInScene",
    value: function removeComponentInScene(component) {
      if (component instanceof _Component2.default) {
        if (this._m_ComponentIDs[component.getId()]) {
          this._m_ComponentIDs[component.getId()] = null;

          this._m_Components.remove(component);

          if (component.isDrawable && component.isDrawable()) {
            this._m_Render.removeDrawable(component);
          }
        }
      }
    }
  }, {
    key: "_gatherVisDrawable",
    value: function _gatherVisDrawable(node, visDrawables) {
      var _this2 = this;

      if (node.isDrawable && node.isDrawable()) {
        visDrawables.push(node);
      } else {
        if (node.getChildren().length > 0) {
          node.getChildren().forEach(function (c) {
            _this2._gatherVisDrawable(c, visDrawables);
          });
        }
      }
    }
    /**
     * 检测当前node是否处于Frustum中，如果是，递归其子节点继续判断，如果当前node已经是叶子节点(叶子节点理论上是Geometry或其子类，但也可以是一个node，如果是一个node叶子节点，表明空节点树)，则将其添加到visDrawables。<br/>
     * @param {Node}[node]
     * @param {Array}[visDrawables]
     * @private
     */

  }, {
    key: "_frustumCulling",
    value: function _frustumCulling(node, visDrawables) {
      var _this3 = this;

      // 检测视锥剔除
      if (!node.inFrustum(this._m_FrustumCullingCamera)) {
        return;
      } // 判断是否为iDrawable


      if (node.isDrawable && node.isDrawable()) {
        // 添加到visDrawable中,然后退出
        visDrawables.push(node);
      } else {
        // 执行子节点剔除
        if (node.getChildren().length > 0) {
          var resetFrustumMask = this._m_FrustumCullingCamera.getFrustumMask();

          node.getChildren().forEach(function (node) {
            if (!(node instanceof _Light.default)) {
              if (node.getFilterFlag() == _Node.default.S_DYNAMIC) {
                // 检测是否需要默认剔除
                if (node.getCullingFlags() & _Node.default.S_DEFAULT_FRUSTUM_CULLING) {
                  // 对于每个同级节点设置同样剔除掩码
                  _this3._m_FrustumCullingCamera.setFrustumMask(resetFrustumMask); // 执行默认剔除


                  _this3._frustumCulling(node, visDrawables);
                }
              } else if (node.getFilterFlag() == _Node.default.S_NEVER) {
                // 直接渲染
                _this3._gatherVisDrawable(node, visDrawables);
              }
            }
          });
        }
      }
    }
  }, {
    key: "update",
    value: function update(exTime) {
      // 执行所有更新队列
      this.runTasks(); // 通知所有观察者

      this.fire('update', [exTime]); // 然后执行其他操作
    }
  }, {
    key: "render",
    value: function render(exTime) {
      var _this4 = this;

      // 更新visDrawables
      // 这里严格来说，应该将visDrawables作为Scene的属性,而不是Render
      var visDrawables = this._m_Render.getVisDrawables(); // 最快的清楚方式


      visDrawables.length = 0; // 通知一帧开始

      this.fire('render', [exTime]); // 然后更新visDrawables

      this._m_Nodes.forEach(function (node) {
        if (node.getFilterFlag() == _Node.default.S_DYNAMIC) {
          // 检测是否执行默认视锥剔除
          if (node.getCullingFlags() & _Node.default.S_DEFAULT_FRUSTUM_CULLING) {
            // 需要执行默认视锥剔除
            _this4._m_FrustumCullingCamera.setFrustumMask(0);

            _this4._frustumCulling(node, visDrawables);
          }
        } else if (node.getFilterFlag() == _Node.default.S_NEVER) {
          // 直接渲染
          _this4._gatherVisDrawable(node, visDrawables);
        }
      }); // 更新visLights


      this._m_VisLights.length = 0;

      if (this._m_EnableLights.length > 0) {
        var restoreFrustumMask = this._m_FrustumCullingCamera.getFrustumMask(); // 从oct根节点开始


        this._m_FrustumCullingCamera.setFrustumMask(0);

        this._m_EnableLights.forEach(function (light) {
          // GIProbe和RefProbe单独处理
          if (light.getType() == 'GIProbe' || light.getType() == 'RefProbe') return;
          light._m_Mark ^= _Light.default.S_VISIBLE_LIGHT;

          if (light.getFilterFlag() == _Node.default.S_DYNAMIC) {
            // 光锥剔除
            // 尽管这里可以更加高效加速,但作为基础实现,仅在这里进行快速剔除
            if (light.inFrustum(_this4._m_FrustumCullingCamera)) {
              light._m_Mark |= _Light.default.S_VISIBLE_LIGHT;

              _this4._m_VisLights.push(light);
            }
          } else if (light.getFilterFlag() == _Node.default.S_NEVER) {
            // 直接渲染
            light._m_Mark |= _Light.default.S_VISIBLE_LIGHT;

            _this4._m_VisLights.push(light);
          }
        }); // 恢复


        this._m_FrustumCullingCamera.setFrustumMask(restoreFrustumMask);
      }

      this._m_Render.render(exTime); // console.log("剔除:" + (this._m_Render._m_Drawables.length - visDrawables.length) + ";渲染:" + visDrawables.length);

    }
  }]);

  return Scene;
}(_Component2.default);

exports["default"] = Scene;

/***/ }),

/***/ 5602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component2 = _interopRequireDefault(__webpack_require__(9650));

var _Light = _interopRequireDefault(__webpack_require__(513));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _FrameBuffer = _interopRequireDefault(__webpack_require__(7341));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _Picture = _interopRequireDefault(__webpack_require__(7280));

var _Texture2DTargetVars = _interopRequireDefault(__webpack_require__(1359));

var _BoolVars = _interopRequireDefault(__webpack_require__(1491));

var _FramePicture = _interopRequireDefault(__webpack_require__(5776));

var _Vector = _interopRequireDefault(__webpack_require__(9271));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

var _Vec2Vars = _interopRequireDefault(__webpack_require__(4690));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BasicShadowProcess = /*#__PURE__*/function (_Component) {
  _inherits(BasicShadowProcess, _Component);

  var _super = _createSuper(BasicShadowProcess);

  // 二次方缩小
  // 固定大小
  // 阴影分区类型（默认为二次方缩小）
  // Pre ShadowMap
  // Post Shadows
  // shadowMap数目
  // 要进行shadow的光源
  // 跳过处理
  // shadowMap潜在可见性集合
  // shadow潜在可见性集合
  // 过渡远处阴影
  // 背面阴影
  // PCF软阴影边缘阈值
  // 阴影强度(默认0.7)
  // 分辨率倒数
  // shadowMapSize倒数
  // 光源矩阵
  // ShadowMap
  // ShadowMapSize(默认512)
  // 分区ShadowMap大小
  // 偏差修正因子
  // 偏差修正单位
  // 所需的渲染状态
  // 需要上载的shadowMap信息
  // 需要上载的lightView信息
  // 激活状态
  // 调试
  // 尽量不要依赖外部引用
  // 分辨率倒数
  // ShadowMapSize倒数

  /**
   * @param {Comment}[owner]
   * @param {Number}[cfg.id]
   * @param {Number}[cfg.nbShadowMaps]
   * @param {Number}[cfg.shadowMapSize]
   * @param {Boolean}[cfg.debug]
   * @param {Boolean}[cfg.backfaceShadows]
   */
  function BasicShadowProcess(owner, cfg) {
    var _this;

    _classCallCheck(this, BasicShadowProcess);

    _this = _super.call(this, owner, cfg);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowSplitType", BasicShadowProcess.S_QUADRATIC_SCALING);

    _defineProperty(_assertThisInitialized(_this), "_m_MainCamera", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_PreShadowMat", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_PostShadowMat", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_NbShadowMaps", 1);

    _defineProperty(_assertThisInitialized(_this), "_m_Light", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_SkipPass", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowGeometryCasts", []);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowGeometryReceivers", []);

    _defineProperty(_assertThisInitialized(_this), "_m_FadeInfo", null);

    _defineProperty(_assertThisInitialized(_this), "_m_ZFarOverride", 0);

    _defineProperty(_assertThisInitialized(_this), "_m_FadeLength", 0);

    _defineProperty(_assertThisInitialized(_this), "_m_BackfaceShadows", false);

    _defineProperty(_assertThisInitialized(_this), "_m_PCFEdge", 1.0);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowIntensity", 0.7);

    _defineProperty(_assertThisInitialized(_this), "_m_ResolutionInverse", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowMapSizeInverse", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_LVPM", []);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowFB", []);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowMapSize", 512);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowMapSizes", []);

    _defineProperty(_assertThisInitialized(_this), "_m_BiasFactor", 1.0);

    _defineProperty(_assertThisInitialized(_this), "_m_BiasUnits", 1.0);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowRenderState", new _RenderState.default());

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowRenderState2", new _RenderState.default());

    _defineProperty(_assertThisInitialized(_this), "_m_UploadShadowMaps", []);

    _defineProperty(_assertThisInitialized(_this), "_m_UploadLightViews", []);

    _defineProperty(_assertThisInitialized(_this), "_m_Enable", true);

    _defineProperty(_assertThisInitialized(_this), "_m_DebugShadowMap", []);

    _defineProperty(_assertThisInitialized(_this), "_m_Debug", false);

    _this._m_NbShadowMaps = cfg.nbShadowMaps;
    _this._m_ShadowMapSize = cfg.shadowMapSize;
    _this._m_Debug = cfg.debug != null ? cfg.debug : false;
    _this._m_BackfaceShadows = cfg.backfaceShadows != null ? cfg.backfaceShadows : false;
    _this._m_ShadowSplitType = cfg.shadowSplitType || _this._m_ShadowSplitType;

    var gl = _this._m_Scene.getCanvas().getGLContext(); // 这里的设计有一些架构上的改进,具体参考开发日志


    var minSize = 128;
    var nextSize = _this._m_ShadowMapSize;
    var debugWSize = Math.min(1.0 / _this._m_NbShadowMaps, 0.25);

    for (var i = 0; i < _this._m_NbShadowMaps; i++) {
      _this._m_LVPM[i] = new _Matrix.default();

      if (_this._m_ShadowSplitType == BasicShadowProcess.S_QUADRATIC_SCALING) {
        _this._m_ShadowFB[i] = new _FrameBuffer.default(gl, 'ShadowFB_' + i, nextSize, nextSize);
        _this._m_ShadowMapSizes[i] = nextSize;
        nextSize /= 2;
        nextSize = Math.max(nextSize, minSize);
      } else if (_this._m_ShadowSplitType == BasicShadowProcess.S_FIXED) {
        _this._m_ShadowFB[i] = new _FrameBuffer.default(gl, 'ShadowFB_' + i, _this._m_ShadowMapSize, _this._m_ShadowMapSize);
      } else {
        Log.error('错误的阴影类型!');
      }

      _this._m_ShadowFB[i].setFixedSize(true); // 添加一个颜色附件（原因是为了防止部分webGL实现对FB的支持需要）


      if (_this._m_Debug) {
        _this._m_ShadowFB[i].addTexture(gl, 'ShadowFBDefaultColor', gl.RGBA, 0, gl.RGBA, gl.UNSIGNED_BYTE, gl.COLOR_ATTACHMENT0, false);
      } // 添加一个深度缓冲区


      _this._m_ShadowFB[i].addTexture(gl, BasicShadowProcess.S_SHADOW_MAP_ARRAY_SRC[i], gl.DEPTH_COMPONENT16, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_ATTACHMENT, false);

      _this._m_ShadowFB[i].finish(gl, _this._m_Scene, false);

      _this._m_UploadShadowMaps[i] = BasicShadowProcess.S_SHADOW_MAP_ARRAY_SRC[i];
      _this._m_UploadLightViews[i] = BasicShadowProcess.S_LIGHT_SHADOW_VP_ARRAY_SRC[i]; // debug

      if (_this._m_Debug) {
        _this._m_DebugShadowMap[i] = new _Picture.default(_this._m_Scene, {
          id: 'debug_shadow_map_' + i
        });

        _this._m_DebugShadowMap[i].setSize(debugWSize, 0.3);

        _this._m_DebugShadowMap[i].setLeftTop(-(1.0 - debugWSize) + debugWSize * 2.01 * i, -0.7);

        _this._m_DebugShadowMap[i].useDefaultMat();

        var colorMap = new _Texture2DTargetVars.default(_this._m_Scene);
        colorMap.setTextureFormat(_Texture2DTargetVars.default.S_TEXTURE_FORMAT.S_RGBA, _Texture2DTargetVars.default.S_TEXTURE_FORMAT.S_RGBA, _Texture2DTargetVars.default.S_TEXTURE_FORMAT.S_UNSIGNED_BYTE);
        colorMap.target(_this._m_ShadowFB[i]);

        _this._m_DebugShadowMap[i].getMaterial().setParam('colorMap', colorMap);

        _this._m_DebugShadowMap[i].setZIndex(0);
      }
    }

    _this._m_ShadowRenderState.setFlag(_RenderState.default.S_STATES[0], _RenderState.default.S_FACE_CULL_FRONT); // 调试,所以注释掉了下面这行


    if (!_this._m_Debug) _this._m_ShadowRenderState.setFlag(_RenderState.default.S_STATES[2], 'Off');

    _this._m_ShadowRenderState.setFlag(_RenderState.default.S_STATES[7], 'On');

    _this._m_ShadowRenderState.setFlag(_RenderState.default.S_STATES[8], [_this._m_BiasFactor, _this._m_BiasUnits]);

    _this._m_ShadowRenderState2.setFlag(_RenderState.default.S_STATES[1], 'Off'); // this._m_ShadowRenderState2.setFlag(RenderState.S_STATES[4], 'On');
    // this._m_ShadowRenderState2.setFlag(RenderState.S_STATES[5], ['SRC_ALPHA', 'ONE']);
    // mat


    _this._m_PreShadowMat = new _Material.default(_this._m_Scene, {
      id: 'preShadowMat_' + _Tools.default.nextId(),
      materialDef: _MaterialDef.default.parse(_Internal.default.S_PRE_SHADOW_DEF_DATA)
    });

    if (_this._m_Debug) {
      _this._m_PreShadowMat.setParam('debug', new _BoolVars.default().valueOf(true));
    }

    _this._m_PostShadowMat = new _Material.default(_this._m_Scene, {
      id: 'postShadowMat_' + _Tools.default.nextId(),
      materialDef: _MaterialDef.default.parse(_Internal.default.S_POST_SHADOW_DEF_DATA)
    });

    _this._m_PostShadowMat.setParam('pcfEdge', new _FloatVars.default().valueOf(_this._m_PCFEdge));

    _this._m_PostShadowMat.setParam('shadowIntensity', new _FloatVars.default().valueOf(_this._m_ShadowIntensity));

    _this._m_ShadowMapSizeInverse.setToInXY(1.0 / _this._m_ShadowMapSize, 1.0 / _this._m_ShadowMapSize);

    var w = _this._m_Scene.getCanvas().getWidth();

    var h = _this._m_Scene.getCanvas().getHeight();

    _this._m_ResolutionInverse.setToInXY(1.0 / w, 1.0 / h);

    _this._m_PostShadowMat.setParam('backfaceShadows', new _BoolVars.default().valueOf(_this._m_BackfaceShadows));

    _this._m_Scene.getCanvas().on('resize', function (w, h) {
      _this._m_ResolutionInverse.setToInXY(1.0 / w, 1.0 / h);
    });

    _this.initMat();

    _this._m_FramePicture = new _FramePicture.default(_this._m_Scene, {
      id: _this._m_Id + "_picture"
    });

    _this._m_Scene.getMainCamera().addFilter(_assertThisInitialized(_this), 0);

    return _this;
  }
  /**
   * 激活状态。<br/>
   * @return {Boolean}
   */


  _createClass(BasicShadowProcess, [{
    key: "isEnable",
    value: function isEnable() {
      return this._m_Enable;
    }
    /**
     * 是否激活。<br/>
     * @param {Boolean}[enable]
     */

  }, {
    key: "enable",
    value: function enable(_enable) {
      this._m_Enable = _enable;
    }
    /**
     * 初始化材质信息，由子类进行参数化。<br/>
     */

  }, {
    key: "initMat",
    value: function initMat() {// 子类实现
    }
    /**
     * 是否启用背面阴影,默认为false。<br/>
     * @param {Boolean}[backfaceShadows]
     */

  }, {
    key: "setBackfaceShadows",
    value: function setBackfaceShadows(backfaceShadows) {
      if (this._m_BackfaceShadows != backfaceShadows) {
        this._m_BackfaceShadows = backfaceShadows;

        this._m_PostShadowMat.setParam('backfaceShadows', new _BoolVars.default().valueOf(this._m_BackfaceShadows));
      }
    }
    /**
     * 是否启用背面阴影。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isBackfaceShadows",
    value: function isBackfaceShadows() {
      return this._m_BackfaceShadows;
    }
    /**
     * 设置偏差修正。<br/>
     * @param {Number}[factor 默认1.0]
     * @param {Number}[units 默认1.0]
     */

  }, {
    key: "setBias",
    value: function setBias(factor, units) {
      this._m_BiasFactor = factor;
      this._m_BiasUnits = units;

      this._m_ShadowRenderState.setFlag(_RenderState.default.S_STATES[8], [this._m_BiasFactor, this._m_BiasUnits]);
    }
    /**
     * 返回偏差修正因子。<br/>
     * @return {Number}
     */

  }, {
    key: "getBiasFactor",
    value: function getBiasFactor() {
      return this._m_BiasFactor;
    }
    /**
     * 返回偏差修正单位。<br/>
     * @return {Number}
     */

  }, {
    key: "getBiasUnits",
    value: function getBiasUnits() {
      return this._m_BiasUnits;
    }
    /**
     * 设置阴影过渡。<br/>
     * @param {Number}[a]
     * @param {Number}[b]
     */

  }, {
    key: "setFade",
    value: function setFade(a, b) {
      if (!this._m_FadeInfo) {
        this._m_FadeInfo = new _Vec2Vars.default();
      }

      var value = this._m_FadeInfo.valueFromXY(a, b);

      this._m_PostShadowMat.setParam('fadeInfo', value);
    }
    /**
     * 设置过渡半程,距离视点最远的阴影距离阈值。<br/>
     * @param {Number}[fadeExtend]
     */

  }, {
    key: "setFadeExtend",
    value: function setFadeExtend(fadeExtend) {
      if (this._m_ZFarOverride != fadeExtend) {
        this._m_ZFarOverride = fadeExtend;
      }

      if (this._m_ZFarOverride == 0) {
        // 暂时未实现clearParams接口，所以暂时用下面这段逻辑
        if (this._m_FadeInfo) {
          this.setFade(0, 0);
        }
      } else {
        this.setFade(this._m_ZFarOverride - this._m_FadeLength, 1.0 / this._m_FadeLength);
      }
    }
    /**
     * 阴影过渡阈值。<br/.
     * @return {Number}
     */

  }, {
    key: "getFadeExtend",
    value: function getFadeExtend() {
      return this._m_ZFarOverride;
    }
    /**
     * 阴影渐变淡化长度。<br/>
     * @param {Number}[fadeLength]
     */

  }, {
    key: "setFadeLength",
    value: function setFadeLength(fadeLength) {
      if (this._m_FadeLength != fadeLength) {
        this._m_FadeLength = fadeLength;
      }

      if (this._m_ZFarOverride == 0) {
        // 暂时未实现clearParams接口，所以暂时用下面这段逻辑
        if (this._m_FadeInfo) {
          this.setFade(0, 0);
        }
      } else {
        this.setFade(this._m_ZFarOverride - this._m_FadeLength, 1.0 / this._m_FadeLength);
      }
    }
    /**
     * 阴影渐变淡化长度。<br/>
     * @return {Number}
     */

  }, {
    key: "getFadeLength",
    value: function getFadeLength() {
      return this._m_FadeLength;
    }
    /**
     * 设置PCFEdge。<br/>
     * @param {Number}[pcfEdge 默认1.0]
     */

  }, {
    key: "setPCFEdge",
    value: function setPCFEdge(pcfEdge) {
      if (this._m_PCFEdge != pcfEdge) {
        this._m_PCFEdge = pcfEdge;

        this._m_PostShadowMat.setParam('pcfEdge', new _FloatVars.default().valueOf(this._m_PCFEdge));
      }
    }
    /**
     * 返回PCFEdge。<br/>
     * @return {Number}
     */

  }, {
    key: "getPCFEdge",
    value: function getPCFEdge() {
      return this._m_PCFEdge;
    }
    /**
     * 设置阴影强度。<br/>
     * @param {Number}[shadowIntensity 默认0.7]
     */

  }, {
    key: "setShadowIntensity",
    value: function setShadowIntensity(shadowIntensity) {
      if (this._m_ShadowIntensity != shadowIntensity) {
        this._m_ShadowIntensity = shadowIntensity;

        this._m_PostShadowMat.setParam('shadowIntensity', new _FloatVars.default().valueOf(this._m_ShadowIntensity));
      }
    }
    /**
     * 返回阴影强度。<br/>
     * @return {Number}
     */

  }, {
    key: "getShadowIntensity",
    value: function getShadowIntensity() {
      return this._m_ShadowIntensity;
    }
    /**
     * 设置渲染光源。<br/>
     * @param {Light}[light]
     */

  }, {
    key: "setLight",
    value: function setLight(light) {
      this._m_Light = light;
    }
    /**
     * 返回渲染光源。<br/>
     * @return {Light}
     */

  }, {
    key: "getLight",
    value: function getLight() {
      return this._m_Light;
    }
    /**
     * 根据lightView更新Shadow Cameras。<br/>
     */

  }, {
    key: "updateShadowCams",
    value: function updateShadowCams() {// ...
    }
    /**
     * 判断光源是否为可见光源。<br/>
     * @return {Boolean}
     */

  }, {
    key: "visLight",
    value: function visLight() {
      return (this._m_Light._m_Mark & _Light.default.S_VISIBLE_LIGHT) != 0;
    }
    /**
     * 生成指定的shadowMap。<br/>
     * @param {GLContext}[gl]
     * @param {Render}[render]
     * @param {FrameContext}[frameContext]
     * @param {Number}[shadowMapIndex]
     */

  }, {
    key: "generateShadowMap",
    value: function generateShadowMap(gl, render, frameContext, shadowMapIndex) {
      // 获取当前光锥范围内的可见性集合
      this._m_ShadowGeometryCasts.length = 0;
      this._m_ShadowGeometryCasts = this.getShadowGeometryCasts(shadowMapIndex, this._m_ShadowGeometryCasts); // 当前光锥

      var shadowCam = this.getShadowCam(shadowMapIndex); // 用于post pass

      this._m_LVPM[shadowMapIndex].set(shadowCam.getProjectViewMatrix(true)); // 渲染当前光锥生成shadowMap


      this._m_Scene.setMainCamera(shadowCam);

      this._m_ShadowFB[shadowMapIndex].use(render);

      this._m_ShadowFB[shadowMapIndex].clear(gl);

      this._m_ShadowGeometryCasts.forEach(function (iDrawable) {
        // console.log('draw')
        iDrawable.draw(frameContext);
      });
    }
    /**
     * 返回指定shadowMap的潜在可见性集合，这里有几种优化方案，具体参考我的开发日志。<br/>
     * @param {Number}[shadowMapIndex]
     * @param {Array}[shadowGeometryCasts]
     * @return {Array}
     */

  }, {
    key: "getShadowGeometryCasts",
    value: function getShadowGeometryCasts(shadowMapIndex, shadowGeometryCasts) {
      return shadowGeometryCasts;
    }
    /**
     * 返回接受阴影处理的潜在可见性集合。<br/>
     * @param {Array}[shadowGeometryReceivers]
     * @return {Array}
     */

  }, {
    key: "getShadowGeometryReceivers",
    value: function getShadowGeometryReceivers(shadowGeometryReceivers) {
      return shadowGeometryReceivers;
    }
    /**
     * 返回指定shadowMap的cam。<br/>
     * @param {Number}[shadowMapIndex]
     * @return {Camera}[camera]
     */

  }, {
    key: "getShadowCam",
    value: function getShadowCam(shadowMapIndex) {// 由子类实现
    }
    /**
     * 上载shadowMap信息。<br/>
     * @param {GLContext}[gl]
     * @param {FrameContext}[frameContext]
     * @private
     */

  }, {
    key: "_uploadInfo",
    value: function _uploadInfo(gl, frameContext) {
      var conVars = frameContext.m_LastSubShader.getContextVars();
      var rd = null;

      for (var i = 0; i < this._m_NbShadowMaps; i++) {
        rd = conVars[BasicShadowProcess.S_SHADOW_MAP_ARRAY_SRC[i]];

        if (rd != null) {
          gl.activeTexture(gl.TEXTURE0 + rd.loc);
          gl.bindTexture(gl.TEXTURE_2D, this._m_ShadowFB[i].getTexture(BasicShadowProcess.S_SHADOW_MAP_ARRAY_SRC[i]).getLoc());
        }

        rd = conVars[BasicShadowProcess.S_LIGHT_SHADOW_VP_ARRAY_SRC[i]];

        if (rd != null) {
          gl[rd.fun](rd.loc, false, this._m_LVPM[i].getBufferData());
        }
      }

      if (!this._m_BackfaceShadows) {
        rd = conVars[BasicShadowProcess.S_RESOLUTION_INVERSE];

        if (rd != null) {
          gl.uniform2f(rd.loc, this._m_ResolutionInverse._m_X, this._m_ResolutionInverse._m_Y);
        }
      }

      rd = conVars[BasicShadowProcess.S_SHADOW_MAP_SIZE];

      if (rd != null) {
        gl.uniform1f(rd.loc, this._m_ShadowMapSize);
      }

      rd = conVars[BasicShadowProcess.S_SHADOW_MAP_SIZE_INVERSE];

      if (rd != null) {
        gl.uniform2f(rd.loc, this._m_ShadowMapSizeInverse._m_X, this._m_ShadowMapSizeInverse._m_Y);
      }
    }
  }, {
    key: "preFrame",
    value: function preFrame() {
      this._m_ShadowGeometryReceivers.length = 0; // draw shadowMap

      this._m_SkipPass = !this.visLight();

      if (this._m_SkipPass) {
        return;
      } // 更新shadow cams


      this.updateShadowCams(); // shadow map shading(这里的一个优化具体参考我的开发日志)

      var render = this._m_Scene.getRender();

      this._m_MainCamera = this._m_Scene.getMainCamera();
      var frameContext = render.getFrameContext();

      var gl = this._m_Scene.getCanvas().getGLContext();

      frameContext.getRenderState().store();

      if (this._m_ShadowSplitType == BasicShadowProcess.S_FIXED) {
        render.setViewPort(gl, 0, 0, this._m_ShadowMapSize, this._m_ShadowMapSize);
      }

      render._checkRenderState(gl, this._m_ShadowRenderState, frameContext.getRenderState());

      render.useForcedMat('PreFrame', this._m_PreShadowMat, 0);

      for (var i = 0; i < this._m_NbShadowMaps; i++) {
        if (this._m_ShadowSplitType == BasicShadowProcess.S_QUADRATIC_SCALING) {
          render.setViewPort(gl, 0, 0, this._m_ShadowMapSizes[i], this._m_ShadowMapSizes[i]);
        }

        this.generateShadowMap(gl, render, frameContext, i);
      }

      this._m_Scene.setMainCamera(this._m_MainCamera);

      this._m_Scene.getRender().useDefaultFrame();

      render.setViewPort(gl, 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight());

      render._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }, {
    key: "postFilter",
    value: function postFilter() {
      // draw shadow
      if (this._m_SkipPass) return; // // 获取接受阴影的潜在可见集合
      // this._m_ShadowGeometryReceivers.length = 0;
      // this.getShadowGeometryReceivers(this._m_ShadowGeometryReceivers);
      // if(this._m_ShadowGeometryReceivers.length > 0){
      //     // post shadow pass
      //     let render = this._m_Scene.getRender();
      //     let frameContext = render.getFrameContext();
      //     const gl = this._m_Scene.getCanvas().getGLContext();
      //     frameContext.getRenderState().store();
      //     render._checkRenderState(gl, this._m_ShadowRenderState2, frameContext.getRenderState());
      //     render.useForcedMat(Render.FORWARD, this._m_PostShadowMat, 0);
      //     this._uploadInfo();
      //     this._m_ShadowGeometryReceivers.forEach(iDrawable=>{
      //         iDrawable.draw(frameContext);
      //     });
      //     render._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
      // }

      var render = this._m_Scene.getRender();

      var frameContext = render.getFrameContext();

      var gl = this._m_Scene.getCanvas().getGLContext();

      frameContext.getRenderState().store();

      render._checkRenderState(gl, this._m_ShadowRenderState2, frameContext.getRenderState());

      render.useForcedMat('PostFilter', this._m_PostShadowMat, 0);

      this._uploadInfo(gl, frameContext);

      this._m_FramePicture.draw(frameContext); // debug


      if (this._m_Debug) {
        for (var i = 0; i < this._m_NbShadowMaps; i++) {
          render.useForcedMat(_Render.default.FORWARD, this._m_DebugShadowMap[i].getMaterial(), 0); // this._uploadInfo();

          this._m_DebugShadowMap[i].draw(frameContext);
        }
      }

      render._checkRenderState(gl, frameContext.getRenderState().restore(), frameContext.getRenderState());
    }
  }]);

  return BasicShadowProcess;
}(_Component2.default);

exports["default"] = BasicShadowProcess;

_defineProperty(BasicShadowProcess, "S_QUADRATIC_SCALING", 0x001);

_defineProperty(BasicShadowProcess, "S_FIXED", 0x002);

_defineProperty(BasicShadowProcess, "S_SHADOW_MAP_ARRAY_SRC", {
  0: '_shadowMap0',
  1: '_shadowMap1',
  2: '_shadowMap2',
  3: '_shadowMap3',
  4: '_shadowMap4',
  5: '_shadowMap5',
  6: '_shadowMap6'
});

_defineProperty(BasicShadowProcess, "S_LIGHT_SHADOW_VP_ARRAY_SRC", {
  0: '_lightViewProjectMatrix0',
  1: '_lightViewProjectMatrix1',
  2: '_lightViewProjectMatrix2',
  3: '_lightViewProjectMatrix3',
  4: '_lightViewProjectMatrix4',
  5: '_lightViewProjectMatrix5',
  6: '_lightViewProjectMatrix6'
});

_defineProperty(BasicShadowProcess, "S_LIGHT_DIR", "_lightDir");

_defineProperty(BasicShadowProcess, "S_LIGHT_POS", "_lightPos");

_defineProperty(BasicShadowProcess, "S_SPLITS", "_splits");

_defineProperty(BasicShadowProcess, "S_FADEINFO", "_fadeInfo");

_defineProperty(BasicShadowProcess, "S_RESOLUTION_INVERSE", '_ResolutionInverse');

_defineProperty(BasicShadowProcess, "S_SHADOW_MAP_SIZE", "_shadowMapSize");

_defineProperty(BasicShadowProcess, "S_SHADOW_MAP_SIZE_INVERSE", "_sMapSizeInverse");

/***/ }),

/***/ 6177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BasicShadowProcess2 = _interopRequireDefault(__webpack_require__(5602));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Shadow = _interopRequireDefault(__webpack_require__(1266));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * DirectionalLightShadowProcess基于Parallel Split Shadows Mapping实现。具体参考:<br/>
 * <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch10.html">https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch10.html</a><br/>
 * @author Kkk
 * @date 2021年9月15日11点26分
 */
var DirectionalLightShadowProcess = /*#__PURE__*/function (_BasicShadowProcess) {
  _inherits(DirectionalLightShadowProcess, _BasicShadowProcess);

  var _super = _createSuper(DirectionalLightShadowProcess);

  // PSSM分割级别（rgba分别存储各级别信息）
  // PSSM分区数据
  // 光锥视点
  // 覆盖光锥的8个顶点
  // 临时变量
  // 防止突然消失的阴影

  /**
   * DirectionalLightShadowProcess。<br/>
   * @param {Comment}[owner]
   * @param {Number}[cfg.id]
   * @param {Number}[cfg.nbSplits]
   * @param {Number}[cfg.shadowMapSize]
   * @param {Boolean}[cfg.debug]
   * @param {Boolean}[cfg.backfaceShadows]
   */
  function DirectionalLightShadowProcess(owner, cfg) {
    var _this;

    _classCallCheck(this, DirectionalLightShadowProcess);

    cfg.nbShadowMaps = cfg.nbSplits;
    _this = _super.call(this, owner, cfg);

    _defineProperty(_assertThisInitialized(_this), "_m_SplitsVec4", new _Vector2.default());

    _defineProperty(_assertThisInitialized(_this), "_m_SplitsArray", null);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowCam", null);

    _defineProperty(_assertThisInitialized(_this), "_m_Points", new Array(8));

    _defineProperty(_assertThisInitialized(_this), "_m_TempVec3", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Lambda", 0.65);

    _defineProperty(_assertThisInitialized(_this), "_m_Stabilize", true);

    _this.init(cfg.nbSplits, cfg.shadowMapSize);

    return _this;
  }

  _createClass(DirectionalLightShadowProcess, [{
    key: "init",
    value: function init(nbSplits, shadowMapSize) {
      // 最多4级分割
      this._m_NbShadowMaps = Math.max(Math.min(nbSplits, 4), 1);

      if (this._m_NbShadowMaps != nbSplits) {
        _Log.default.error('PSSM分割级别只能为1-4之间,指定的分割级别为:' + nbSplits);
      }

      this._m_SplitsArray = new Array(this._m_NbShadowMaps + 1);
      this._m_ShadowCam = new _Camera.default(this._m_Scene, {
        id: 'DirectionalLightShadowProcess_' + _Tools.default.nextId(),
        width: shadowMapSize,
        height: shadowMapSize,
        fixedSize: true,
        parallelProjection: true
      });

      this._m_ShadowCam.setEye(new _Vector.default(0, 0, 0));

      for (var i = 0; i < 8; i++) {
        this._m_Points[i] = new _Vector.default();
      }
    }
  }, {
    key: "initMat",
    value: function initMat() {
      _get(_getPrototypeOf(DirectionalLightShadowProcess.prototype), "initMat", this).call(this); // 追加材质定义


      this._m_PostShadowMat.addDefine(_ShaderSource.default.S_PSSM_SRC, false);
    }
  }, {
    key: "_uploadInfo",
    value: function _uploadInfo(gl, frameContext) {
      _get(_getPrototypeOf(DirectionalLightShadowProcess.prototype), "_uploadInfo", this).call(this, gl, frameContext); // 更新PSSM信息


      var conVars = frameContext.m_LastSubShader.getContextVars();
      var rd = null;
      rd = conVars[_BasicShadowProcess2.default.S_LIGHT_DIR];

      if (rd) {
        var dir = this._m_Light.getDirection();

        gl.uniform3f(rd.loc, dir._m_X, dir._m_Y, dir._m_Z);
      }

      rd = conVars[_BasicShadowProcess2.default.S_SPLITS];

      if (rd) {
        gl.uniform4f(rd.loc, this._m_SplitsVec4._m_X, this._m_SplitsVec4._m_Y, this._m_SplitsVec4._m_Z, this._m_SplitsVec4._m_W);
      }
    }
  }, {
    key: "updateShadowCams",
    value: function updateShadowCams() {
      if (this._m_Light == null) {
        _Log.default.warn('无效光源!');

        return;
      }

      var mainCamera = this._m_Scene.getMainCamera();

      var zFar = this._m_ZFarOverride;

      if (zFar == 0) {
        zFar = mainCamera.getFar();
      }

      var zNear = Math.max(mainCamera.getNear(), 0.001);

      _Shadow.default.calculateLightConeScope(mainCamera, zNear, zFar, 1.0, this._m_Points);

      this._m_ShadowCam.setFar(zFar);

      var e = this._m_ShadowCam.getEye();

      this._m_ShadowCam.lookAt(e, e.add(this._m_Light.getDirection(), this._m_TempVec3), this._m_ShadowCam.getUp()); // 强制更新


      this._m_ShadowCam._updateFrustum();

      this._m_ShadowCam.forceUpdateProjection();

      this._m_ShadowCam.getProjectViewMatrix(true);

      _Shadow.default.calculateSplits(this._m_SplitsArray, zNear, zFar, this._m_Lambda);

      if (mainCamera.isParallelProjection()) {
        // 对于平行投影，shadow位置规范在[0,1]
        // 实际上对于DirectionalLight默认下就是平行投影
        // 但是为了灵活性，仍然根据实际情况进行归一化
        var fn = (zFar - zNear) * 1.0;

        for (var i = 0; i < this._m_NbShadowMaps; i++) {
          this._m_SplitsArray[i] /= fn;
        }
      }

      switch (this._m_SplitsArray.length) {
        case 5:
          this._m_SplitsVec4._m_W = this._m_SplitsArray[4];

        case 4:
          this._m_SplitsVec4._m_Z = this._m_SplitsArray[3];

        case 3:
          this._m_SplitsVec4._m_Y = this._m_SplitsArray[2];

        case 2:
        case 1:
          this._m_SplitsVec4._m_X = this._m_SplitsArray[1];
          break;
      }
    }
  }, {
    key: "getShadowCam",
    value: function getShadowCam(shadowMapIndex) {
      return this._m_ShadowCam;
    }
  }, {
    key: "getShadowGeometryCasts",
    value: function getShadowGeometryCasts(shadowMapIndex, shadowGeometryCasts) {
      // 计算当前ShadowMap下光锥边界体
      _Shadow.default.calculateLightConeScope(this._m_MainCamera, this._m_SplitsArray[shadowMapIndex], this._m_SplitsArray[shadowMapIndex + 1], 1.0, this._m_Points);

      if (this._m_ShadowGeometryReceivers.length == 0) {
        // 我们需要根据receivers集合来计算完整的casts集合
        // 简而言之,这里根据收集当前可见视锥下需要参与receiver的物体
        // 此时仅需从潜在可见集合中中计算子集
        _Shadow.default.calculateGeometriesInFrustum(this._m_Scene.getRender().getVisDrawables(), this._m_MainCamera, _Node.default.S_SHADOW_RECEIVE, this._m_ShadowGeometryReceivers);
      }

      _Shadow.default.calculateShadowCamera(this._m_Scene.getSceneNodes(), this._m_ShadowGeometryReceivers, this._m_ShadowCam, this._m_Points, shadowGeometryCasts, this._m_Stabilize ? this._m_ShadowMapSize : 0.0);

      return shadowGeometryCasts;
    }
  }, {
    key: "getShadowGeometryReceivers",
    value: function getShadowGeometryReceivers(shadowGeometryReceivers) {
      if (shadowGeometryReceivers.length == 0) {
        _Shadow.default.calculateGeometriesInFrustum(this._m_Scene.getRender().getVisDrawables(), this._m_MainCamera, _Node.default.S_SHADOW_RECEIVE, shadowGeometryReceivers);
      }
    }
  }]);

  return DirectionalLightShadowProcess;
}(_BasicShadowProcess2.default);

exports["default"] = DirectionalLightShadowProcess;

/***/ }),

/***/ 4867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BasicShadowProcess2 = _interopRequireDefault(__webpack_require__(5602));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _TextureCubeVars = _interopRequireDefault(__webpack_require__(4048));

var _Shadow = _interopRequireDefault(__webpack_require__(1266));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * PointLightShadowProcess。<br/>
 * 这个类用于实现PointLight的Shadow,为了统一ShadowPipeline,这里使用6张texture2D来模拟传统cubeMap,尽管这样会增加额外的开销。<br/>
 */
var PointLightShadowProcess = /*#__PURE__*/function (_BasicShadowProcess) {
  _inherits(PointLightShadowProcess, _BasicShadowProcess);

  var _super = _createSuper(PointLightShadowProcess);

  // cubeMap 6个face
  // 对应的6个shadowCam
  // 当前光源位置
  // 当前光源半径
  // 临时变量

  /**
   * @param {Comment}[owner]
   * @param {Number}[cfg.id]
   * @param {Number}[cfg.shadowMapSize]
   * @param {Boolean}[cfg.debug]
   * @param {Boolean}[cfg.backfaceShadows]
   */
  function PointLightShadowProcess(owner, cfg) {
    var _this;

    _classCallCheck(this, PointLightShadowProcess);

    cfg.nbShadowMaps = PointLightShadowProcess._S_FACE_NUMS; // 对于pointLight而言,必须为固定尺寸的分区

    cfg.shadowSplitType = 0x002;
    _this = _super.call(this, owner, cfg);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowCams", new Array(PointLightShadowProcess._S_FACE_NUMS));

    _defineProperty(_assertThisInitialized(_this), "_m_Position", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Radius", 0);

    _defineProperty(_assertThisInitialized(_this), "_m_UpdateCasterCam", false);

    _this.init(cfg.shadowMapSize);

    return _this;
  }

  _createClass(PointLightShadowProcess, [{
    key: "init",
    value: function init(smSize) {
      for (var i = 0; i < PointLightShadowProcess._S_FACE_NUMS; i++) {
        this._m_ShadowCams[i] = new _Camera.default(this._m_Scene, {
          id: this._m_Id + "_" + i + _Tools.default.nextId(),
          width: smSize,
          height: smSize,
          fixedSize: true
        });
      }
    }
  }, {
    key: "initMat",
    value: function initMat() {
      _get(_getPrototypeOf(PointLightShadowProcess.prototype), "initMat", this).call(this); // 追加材质定义


      this._m_PostShadowMat.addDefine(_ShaderSource.default.S_POINTLIGHT_SHADOWS_SRC, false);
    }
  }, {
    key: "_uploadInfo",
    value: function _uploadInfo(gl, frameContext) {
      _get(_getPrototypeOf(PointLightShadowProcess.prototype), "_uploadInfo", this).call(this, gl, frameContext); // 更新PointLight信息


      var conVars = frameContext.m_LastSubShader.getContextVars();
      var rd = null;
      rd = conVars[_BasicShadowProcess2.default.S_LIGHT_POS];

      if (rd) {
        gl.uniform3f(rd.loc, this._m_Position._m_X, this._m_Position._m_Y, this._m_Position._m_Z);
      }
    }
    /**
     * 更新阴影投射相机。<br/>
     */

  }, {
    key: "updateShadowCams",
    value: function updateShadowCams() {
      if (this._m_Radius != this._m_Light.getRadius() || !this._m_Position.equals(this._m_Light.getPosition())) {
        this._m_Radius = this._m_Light.getRadius();

        this._m_Position.setTo(this._m_Light.getPosition());

        this._calc();
      } else if (this._m_UpdateCasterCam) {
        this._m_UpdateCasterCam = false;

        for (var i = 0; i < PointLightShadowProcess._S_FACE_NUMS; i++) {
          this._m_ShadowCams[i].setFrustumPerspective(90.0, 1.0, 0.1, this._m_Radius);

          this._m_ShadowCams[i]._updateFrustum();
        }
      }
    }
    /**
     * 返回指定的shadowCam。<br/>
     * @param {Number}[shadowMapIndex]
     * @return {Camera}
     */

  }, {
    key: "getShadowCam",
    value: function getShadowCam(shadowMapIndex) {
      return this._m_ShadowCams[shadowMapIndex];
    }
    /**
     * 返回当前shadowMap要渲染的遮挡物集合。<br/>
     * @param {Number}[shadowMapIndex]
     * @param {Array}[shadowGeometryCasts]
     */

  }, {
    key: "getShadowGeometryCasts",
    value: function getShadowGeometryCasts(shadowMapIndex, shadowGeometryCasts) {
      var _this2 = this;

      // 从场景图中查找当前shadowCam要进行投射的物体
      var scenes = this._m_Scene.getSceneNodes();

      scenes.forEach(function (scene) {
        _Shadow.default.calculateNodeInFrustum(scene, _this2._m_ShadowCams[shadowMapIndex], _Node.default.S_SHADOW_CAST, shadowGeometryCasts);
      });
      this._m_UpdateCasterCam = true; // 计算完遮挡潜在子集后，将投射相机范围拉大，以确保完整投射潜在遮挡子集

      this._m_ShadowCams[shadowMapIndex].setFrustumPerspective(90.0, 1.0, 0.1, 1000.0);

      this._m_ShadowCams[shadowMapIndex].getProjectViewMatrix(true);

      return shadowGeometryCasts;
    }
    /**
     * 计算阴影更新区域。<br/>
     * @private
     */

  }, {
    key: "_calc",
    value: function _calc() {
      var at = PointLightShadowProcess._S_TEMP_VEC3_0;

      for (var i = 0; i < PointLightShadowProcess._S_FACE_NUMS; i++) {
        PointLightShadowProcess._S_CAPTURE_CONFIG[i].dir.add(this._m_Position, at);

        this._m_ShadowCams[i].lookAt(this._m_Position, at, PointLightShadowProcess._S_CAPTURE_CONFIG[i].up);

        this._m_ShadowCams[i].setFrustumPerspective(90.0, 1.0, 0.1, this._m_Radius);

        this._m_ShadowCams[i]._updateFrustum(); // this._m_ShadowCams[i].getProjectViewMatrix(true);

      }
    }
  }]);

  return PointLightShadowProcess;
}(_BasicShadowProcess2.default);

exports["default"] = PointLightShadowProcess;

_defineProperty(PointLightShadowProcess, "_S_CAPTURE_CONFIG", [// NegativeY
{
  dir: new _Vector.default(0, -1, 0),
  up: new _Vector.default(0, 0, -1)
}, // PositiveY
{
  dir: new _Vector.default(0, 1, 0),
  up: new _Vector.default(0, 0, 1)
}, // NegativeZ
{
  dir: new _Vector.default(0, 0, -1),
  up: new _Vector.default(0, 1, 0)
}, // PositiveZ
{
  dir: new _Vector.default(0, 0, 1),
  up: new _Vector.default(0, 1, 0)
}, // NegativeX
{
  dir: new _Vector.default(-1, 0, 0),
  up: new _Vector.default(0, 1, 0)
}, // PositiveX
{
  dir: new _Vector.default(1, 0, 0),
  up: new _Vector.default(0, 1, 0)
}]);

_defineProperty(PointLightShadowProcess, "_S_FACE_NUMS", 6);

_defineProperty(PointLightShadowProcess, "_S_TEMP_VEC3_0", new _Vector.default());

/***/ }),

/***/ 1266:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _SplitOccluders = _interopRequireDefault(__webpack_require__(8578));

var _Light = _interopRequireDefault(__webpack_require__(513));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Shadow = /*#__PURE__*/function () {
  function Shadow() {
    _classCallCheck(this, Shadow);
  }

  _createClass(Shadow, null, [{
    key: "calculateLightConeScope",
    value:
    /**
     * 计算光锥边界范围，这里的思路是根据near,far将光锥代表的范围计算到一个边界体中。<br/>
     * @param {Camera}[viewCam 通常是渲染主相机]
     * @param {Number}[newNear]
     * @param {Number}[newFar]
     * @param {Number}[scale]
     * @param {Array}[result 存放边界体结果，这里其实统一为8个点标记的边界体]
     */
    function calculateLightConeScope(viewCam, newNear, newFar, scale, result) {
      var depthHeightRatio = viewCam.getTop() * 1.0 / viewCam.getNear();
      var near = newNear * 1.0;
      var far = newFar * 1.0;
      var top = viewCam.getTop() * 1.0;
      var right = viewCam.getRight() * 1.0;
      var ratio = right / top;
      var near_height = -1,
          near_width = -1,
          far_height = -1,
          far_width = -1;

      if (viewCam.isParallelProjection()) {
        near_height = top;
        near_width = near_height * ratio;
        far_height = top;
        far_width = far_height * ratio;
      } else {
        near_height = depthHeightRatio * near;
        near_width = near_height * ratio;
        far_height = depthHeightRatio * far;
        far_width = far_height * ratio;
      } // 计算光锥包围体


      var pos = viewCam.getEye();
      var dir = viewCam.getDir();
      var up = viewCam.getUp();
      var r = dir.cross(up, Shadow.S_TEMP_VEC3_1).normal(); // near,far中点计算

      var farCenter = dir.multLength(far, Shadow.S_TEMP_VEC3_2).add(pos);
      var nearCenter = dir.multLength(near, Shadow.S_TEMP_VEC3_3).add(pos);
      var nearUp = up.multLength(near_height, Shadow.S_TEMP_VEC3_4);
      var farUp = up.multLength(far_height, Shadow.S_TEMP_VEC3_5);
      var nearRight = r.multLength(near_width, Shadow.S_TEMP_VEC3_6);
      var farRight = r.multLength(far_width, Shadow.S_TEMP_VEC3_7);
      nearCenter.sub(nearUp, result[0]).sub(nearRight);
      nearCenter.add(nearUp, result[1]).sub(nearRight);
      nearCenter.add(nearUp, result[2]).add(nearRight);
      nearCenter.sub(nearUp, result[3]).add(nearRight);
      farCenter.sub(farUp, result[4]).sub(farRight);
      farCenter.add(farUp, result[5]).sub(farRight);
      farCenter.add(farUp, result[6]).add(farRight);
      farCenter.sub(farUp, result[7]).add(farRight);

      if (scale != 1.0) {
        // 找到光锥体的中心
        var center = Shadow.S_TEMP_VEC3_8.setToInXYZ(0, 0, 0);

        for (var i = 0; i < 8; i++) {
          center.add(result[i]);
        }

        center.multLength(1.0 / 8);
        var cDir = Shadow.S_TEMP_VEC3_0;

        for (var _i = 0; _i < 8; _i++) {
          result[_i].sub(center, cDir);

          cDir.multLength(scale - 1.0);

          result[_i].add(cDir);
        }
      }
    }
    /**
     * 基于PSSM计算锥体分区。<br/>
     * @param {Array}[splits 分区结果信息]
     * @param {Number}[near]
     * @param {Number}[far]
     * @param {Number}[lambda]
     */

  }, {
    key: "calculateSplits",
    value: function calculateSplits(splits, near, far, lambda) {
      var IDM = -1,
          log = -1,
          u = -1;
      var nf = far * 1.0 / near;
      var nf2 = far - near;

      for (var i = 0, len = splits.length; i < len; i++) {
        IDM = i * 1.0 / len;
        log = near * Math.pow(nf, IDM);
        u = near + nf2 * IDM;
        splits[i] = log * lambda + u * (1.0 - lambda);
      } // 这用于提高计算的正确性。 无论发生什么，camera的主要近平面和远平面始终保持不变。


      splits[0] = near;
      splits[splits.length - 1] = far;
    }
    /**
     * 更新shadowCam确保视锥体包含指定的视锥边界体,同时计算锥体下的潜在可见集合。<br/>
     * @param {Node[]}[sceneNodes]
     * @param {Geometry[]}[splitShadowGeometryReceivers]
     * @param {Camera}[shadowCam]
     * @param {Vector3[]}[points]
     * @param {Geometry[]}[splitShadowGeometryCasts]
     * @param {Number}[shadowMapSize]
     */

  }, {
    key: "calculateShadowCamera",
    value: function calculateShadowCamera(sceneNodes, splitShadowGeometryReceivers, shadowCam, points, splitShadowGeometryCasts, shadowMapSize) {
      if (shadowCam.isParallelProjection()) {
        shadowCam.setFrustum(-1, 1, 1, -1, -shadowCam.getFar(), shadowCam.getFar());
        shadowCam.forceUpdateProjection();
      }

      var vp = shadowCam.getProjectViewMatrix(true);
      var splitBoundary = Shadow.calculateBoundaryFromPoints(points, vp, Shadow.S_AABB_BOUNDARY_BOX0);
      var casterBoundary = new _AABBBoundingBox.default();
      var receiverBoundary = new _AABBBoundingBox.default();
      var casterCount = 0,
          receiverCount = 0; // 计算receiver包围体

      var bv = null,
          recvBox = null;
      var c = null;
      splitShadowGeometryReceivers.forEach(function (geometry) {
        bv = geometry.getBoundingVolume();
        recvBox = Shadow.S_AABB_BOUNDARY_BOX1;
        bv.transformFromMat44(vp, Shadow.S_AABB_BOUNDARY_BOX1);

        if (splitBoundary.contains(recvBox)) {
          c = recvBox.getCenter();

          if (Math.abs(c._m_X) != Number.MAX_VALUE && !Number.isNaN(c._m_X) && Number.isFinite(c._m_X)) {
            receiverBoundary.merge(recvBox);
            receiverCount++;
          }
        }
      }); // 遍历整个场景（实际上仅遍历场景潜在可见集合）
      // 获取分区下的潜在可见集合

      var ext = new _SplitOccluders.default(vp, casterCount, splitBoundary, casterBoundary, splitShadowGeometryCasts);
      sceneNodes.forEach(function (sceneNode) {
        ext.calculate(sceneNode);
      });
      casterCount = ext._m_CasterCount;

      if (casterCount != receiverCount) {
        casterBoundary.setHalfInXYZ(casterBoundary.getXHalf() + 2.0, casterBoundary.getYHalf() + 2.0, casterBoundary.getZHalf() + 2.0);
      }

      var casterMin = casterBoundary.getMin(Shadow.S_TEMP_VEC3_00);
      var casterMax = casterBoundary.getMax(Shadow.S_TEMP_VEC3_11);
      var receiverMin = receiverBoundary.getMin(Shadow.S_TEMP_VEC3_22);
      var receiverMax = receiverBoundary.getMax(Shadow.S_TEMP_VEC3_33);
      var splitMin = splitBoundary.getMin(Shadow.S_TEMP_VEC3_44);
      var splitMax = splitBoundary.getMax(Shadow.S_TEMP_VEC3_55);
      splitMin._m_Z = 0.0;
      var p = shadowCam.getProjectMatrix(); // 为了避免使用重复,这里使用倒数临时变量

      var cropMin = Shadow.S_TEMP_VEC3_8;
      var cropMax = Shadow.S_TEMP_VEC3_7;
      cropMin._m_X = Math.max(Math.max(casterMin._m_X, receiverMin._m_X), splitMin._m_X);
      cropMax._m_X = Math.min(Math.min(casterMax._m_X, receiverMax._m_X), splitMax._m_X);
      cropMin._m_Y = Math.max(Math.max(casterMin._m_Y, receiverMin._m_Y), splitMin._m_Y);
      cropMax._m_Y = Math.min(Math.min(casterMax._m_Y, receiverMax._m_Y), splitMax._m_Y); // Z 值的特殊处理

      cropMin._m_Z = Math.min(casterMin._m_Z, splitMin._m_Z);
      cropMax._m_Z = Math.min(receiverMax._m_Z, splitMax._m_Z); // 创建cropMatrix

      var scaleX, scaleY, scaleZ;
      var offsetX, offsetY, offsetZ;
      scaleX = 2.0 / (cropMax._m_X - cropMin._m_X);
      scaleY = 2.0 / (cropMax._m_Y - cropMin._m_Y); // 这里的思路来自ShaderX7,用于稳定的PSSM(尽管这是一个比较古老的方案)

      var halfTS = shadowMapSize * 0.5;

      if (halfTS != 0 && scaleX > 0 && scaleY > 0) {
        var scaleQuantizer = 0.1;
        scaleX = 1.0 / Math.ceil(1.0 / scaleX * scaleQuantizer) * scaleQuantizer;
        scaleY = 1.0 / Math.ceil(1.0 / scaleY * scaleQuantizer) * scaleQuantizer;
      }

      offsetX = -0.5 * (cropMax._m_X + cropMin._m_X) * scaleX;
      offsetY = -0.5 * (cropMax._m_Y + cropMin._m_Y) * scaleY;

      if (halfTS != 0 && scaleX > 0 && scaleY > 0) {
        offsetX = Math.ceil(offsetX * halfTS) * 1.0 / halfTS;
        offsetY = Math.ceil(offsetY * halfTS) * 1.0 / halfTS;
      }

      scaleZ = 1.0 / (cropMax._m_Z - cropMin._m_Z);
      offsetZ = -cropMin._m_Z * scaleZ;
      var cropMatrix = Shadow.S_TEMP_MAT44_0;
      cropMatrix.setArray([scaleX, 0, 0, 0, 0, scaleY, 0, 0, 0, 0, scaleZ, 0, offsetX, offsetY, offsetZ, 1]);
      var pr = Shadow.S_TEMP_MAT44_1;

      _Matrix.default.multiplyMM(pr, 0, cropMatrix, 0, p, 0);

      shadowCam.setProjectMatrix(pr);
    }
    /**
     * 根据指定点和变换矩阵计算BoundaryVolume。<br/>
     * @param {Vector3[]}[pos]
     * @param {Matrix44}[mat]
     * @param {AABBBoundingBox}[result]
     * @return {AABBBoundingBox}
     */

  }, {
    key: "calculateBoundaryFromPoints",
    value: function calculateBoundaryFromPoints(pos, mat, result) {
      var min = Shadow.S_TEMP_VEC3_0.setTo(_Vector.default.S_MIN);
      var max = Shadow.S_TEMP_VEC3_1.setTo(_Vector.default.S_MAX);
      var temp = Shadow.S_TEMP_VEC3_2;
      var pw = 0;

      for (var i = 0, len = pos.length; i < len; i++) {
        pw = _Matrix.default.multiplyMV3(temp, pos[i], mat);
        temp.multLength(1.0 / pw);
        min.min(temp);
        max.max(temp);
      } // 计算Boundary中心和半径


      var center = min.add(max, Shadow.S_TEMP_VEC3_3).multLength(0.5);
      var r = max.sub(min, Shadow.S_TEMP_VEC3_4).multLength(0.5);
      var boundary = result || new _AABBBoundingBox.default();
      boundary.setCenter(center); // 加偏移是为了修正精度范围内的误差

      boundary.setHalfInXYZ(r._m_X + 2.0, r._m_Y + 2.0, r._m_Z + 2.5);
      return boundary;
    }
    /**
     * 计算当前锥体内的潜在可见性集合，这里的优化策略是，这个方法用于查找主相机中潜在可见集合的子集，因此不必遍历场景图。<br/>
     * @param {Array}[visDrawables]
     * @param {Camera}[camera]
     * @param {Number}[mode]
     * @param {Array}[result]
     */

  }, {
    key: "calculateGeometriesInFrustum",
    value: function calculateGeometriesInFrustum(visDrawables, camera, mode, result) {
      var restoreFrustumMask = camera.getFrustumMask(); // 执行默认剔除

      Shadow._cull(visDrawables, camera, mode, result);

      camera.setFrustumMask(restoreFrustumMask);
    }
    /**
     * 计算当前锥体内的潜在可见集合。<br/>
     * @param {Node}[node]
     * @param {Camera}[camera]
     * @param {Number}[mode]
     * @param {Array}[result]
     */

  }, {
    key: "calculateNodeInFrustum",
    value: function calculateNodeInFrustum(node, camera, mode, result) {
      var restoreFrustumMask = camera.getFrustumMask(); // 执行默认剔除

      camera.setFrustumMask(0);

      Shadow._cull2(node, camera, mode, result);

      camera.setFrustumMask(restoreFrustumMask);
    }
    /**
     * 锥体剔除，实际上虽然可以直接使用Camera的内部方法进行，但是为了效率直接在这里实现一个函数封装，以便去掉额外的内容和增加额外的内容。<br/>
     * @param {Array}[visDrawables]
     * @param {Camera}[camera]
     * @param {Number}[mode]
     * @param {Array}[result]
     * @private
     */

  }, {
    key: "_cull",
    value: function _cull(visDrawables, camera, mode, result) {
      visDrawables.forEach(function (visDrawable) {
        camera.setFrustumMask(0);

        if (visDrawable.inFrustum(camera)) {
          // 判断是否为指定阴影模式
          if (Shadow._parseShadowMode(visDrawable, mode)) {
            // 添加到result中
            result.push(visDrawable);
          }
        }
      });
    }
  }, {
    key: "_cull2",
    value: function _cull2(node, camera, mode, result) {
      if (node.getFilterFlag() == _Node.default.S_ALWAYS) return;

      if (node.inFrustum(camera)) {
        if (node.isDrawable && node.isDrawable() && !node.isGUI()) {
          // 判断是否为指定阴影模式
          if (Shadow._parseShadowMode(node, mode)) {
            // 添加到result中
            result.push(node);
          }
        } else {
          if (node.getChildren().length > 0) {
            var resetFrustumMask = camera.getFrustumMask();
            node.getChildren().forEach(function (node) {
              if (!(node instanceof _Light.default)) {
                camera.setFrustumMask(resetFrustumMask);

                Shadow._cull2(node, camera, mode, result);
              }
            });
          }
        }
      }
    }
    /**
     * 解析阴影类型。<br/>
     * @param {Node}[node]
     * @param {Number}[mode]
     * @return {Number}
     * @private
     */

  }, {
    key: "_parseShadowMode",
    value: function _parseShadowMode(node, mode) {
      if (mode != _Node.default.S_SHADOW_NONE) {
        switch (mode) {
          case _Node.default.S_SHADOW_CAST:
            return node.isCastShadow();

          case _Node.default.S_SHADOW_RECEIVE:
            return node.isReceiveShadow();

          case _Node.default.S_SHADOW_CAST_AND_RECEIVE:
            return true;
        }
      }

      return false;
    }
  }]);

  return Shadow;
}();

exports["default"] = Shadow;

_defineProperty(Shadow, "S_TEMP_VEC3_0", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_1", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_2", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_3", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_4", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_5", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_6", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_7", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_8", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_00", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_11", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_22", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_33", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_44", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_VEC3_55", new _Vector.default());

_defineProperty(Shadow, "S_TEMP_MAT44_0", new _Matrix.default());

_defineProperty(Shadow, "S_TEMP_MAT44_1", new _Matrix.default());

_defineProperty(Shadow, "S_AABB_BOUNDARY_BOX0", new _AABBBoundingBox.default());

_defineProperty(Shadow, "S_AABB_BOUNDARY_BOX1", new _AABBBoundingBox.default());

/***/ }),

/***/ 8578:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry = _interopRequireDefault(__webpack_require__(4720));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _BoundingVolume = _interopRequireDefault(__webpack_require__(1322));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * SplitOccluders。<br/>
 * 用于计算锥体内潜在可见集合的辅助类。<br/>
 * @author Kkk
 * @date 2021年9月17日16点15分
 */
var SplitOccluders = /*#__PURE__*/function () {
  /**
   * 分区潜在可见集合计算。<br/>
   * @param {Matrix44}[pv]
   * @param {Number}[casterCount]
   * @param {AABBBoundingBox}[splitBoundaryBox]
   * @param {AABBBoundingBox}[casterBoundaryBox]
   * @param {Geometry[]}[splitOccluders]
   */
  function SplitOccluders(pv, casterCount, splitBoundaryBox, casterBoundaryBox, splitOccluders) {
    _classCallCheck(this, SplitOccluders);

    _defineProperty(this, "_m_VP", void 0);

    _defineProperty(this, "_m_CasterCount", void 0);

    _defineProperty(this, "_m_SplitBoundaryBox", void 0);

    _defineProperty(this, "_m_CasterBoundaryBox", void 0);

    _defineProperty(this, "_m_SplitOccluders", void 0);

    this._m_VP = pv;
    this._m_CasterCount = casterCount;
    this._m_SplitBoundaryBox = splitBoundaryBox;
    this._m_CasterBoundaryBox = casterBoundaryBox;
    this._m_SplitOccluders = splitOccluders;
  }
  /**
   * 计算潜在可见集合。<br/>
   * @param {Node}[rootNode]
   */


  _createClass(SplitOccluders, [{
    key: "calculate",
    value: function calculate(rootNode) {
      this._calculate(rootNode);

      return this._m_CasterCount;
    }
  }, {
    key: "_calculate",
    value: function _calculate(node) {
      var _this = this;

      if (node.getFilterFlag() == _Node.default.S_ALWAYS) return;

      if (node.isDrawable && node.isDrawable() && !node.isGUI()) {
        if (node.isCastShadow()) {
          var bv = node.getBoundingVolume();
          var obv = SplitOccluders.S_AABB_BOUNDARY_BOX0;
          bv.transformFromMat44(this._m_VP, SplitOccluders.S_AABB_BOUNDARY_BOX0);

          var intersects = this._m_SplitBoundaryBox.contains(obv);

          if (!intersects && bv.getType() == _BoundingVolume.default.S_TYPE_AABB) {
            // 将包围体延伸到光锥体内
            // 尽管物体不在光锥内，但是阴影仍然可能在光锥内
            // 50只是一个经验值
            obv.setZHalf(obv.getZHalf() + 50);
            obv.setCenter(obv.getCenter(SplitOccluders.S_TEMP_VEC3_0).addInXYZ(0, 0, 25)); // 再次测试

            if (this._m_SplitBoundaryBox.contains(obv)) {
              var x = obv.getCenter(SplitOccluders.S_TEMP_VEC3_1)._m_X;

              if (Math.abs(x) != Number.MAX_VALUE && !Number.isNaN(x) && Number.isFinite(x)) {
                // 通过测试后,将边界体重设为原始状态并添加
                // 防止用新的偏移边界体扩大了深度范围
                obv.setZHalf(obv.getZHalf() - 50);
                obv.setCenter(obv.getCenter(SplitOccluders.S_TEMP_VEC3_0).subInXYZ(0, 0, 25));

                this._m_CasterBoundaryBox.merge(obv);

                this._m_CasterCount++;
              }

              if (this._m_SplitOccluders != null) {
                this._m_SplitOccluders.push(node);
              }
            }
          } else if (intersects) {
            this._m_CasterBoundaryBox.merge(obv);

            this._m_CasterCount++;

            if (this._m_SplitOccluders != null) {
              this._m_SplitOccluders.push(node);
            }
          }
        }
      } else {
        if (node instanceof _Node.default) {
          var _bv = node.getBoundingVolume();

          if (_bv != null) {
            var _obv = SplitOccluders.S_AABB_BOUNDARY_BOX0;

            _bv.transformFromMat44(this._m_VP, SplitOccluders.S_AABB_BOUNDARY_BOX0);

            var _intersects = this._m_SplitBoundaryBox.contains(_obv);

            if (!_intersects && _obv.getType() == _BoundingVolume.default.S_TYPE_AABB) {
              // 将包围体延伸到光锥体内
              // 尽管物体不在光锥内，但是阴影仍然可能在光锥内
              // 50只是一个经验值
              _obv.setZHalf(_obv.getZHalf() + 50);

              _obv.setCenter(_obv.getCenter(SplitOccluders.S_TEMP_VEC3_0).addInXYZ(0, 0, 25)); // 再次测试


              _intersects = this._m_SplitBoundaryBox.contains(_obv);
            }

            if (_intersects) {
              // 遍历子节点
              node.getChildren().forEach(function (children) {
                _this._calculate(children);
              });
            }
          }
        }
      }
    }
  }]);

  return SplitOccluders;
}();

exports["default"] = SplitOccluders;

_defineProperty(SplitOccluders, "S_TEMP_VEC3_0", new _Vector.default());

_defineProperty(SplitOccluders, "S_TEMP_VEC3_1", new _Vector.default());

_defineProperty(SplitOccluders, "S_TEMP_VEC3_2", new _Vector.default());

_defineProperty(SplitOccluders, "S_AABB_BOUNDARY_BOX0", new _AABBBoundingBox.default());

_defineProperty(SplitOccluders, "S_AABB_BOUNDARY_BOX1", new _AABBBoundingBox.default());

/***/ }),

/***/ 948:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BasicShadowProcess2 = _interopRequireDefault(__webpack_require__(5602));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Shadow = _interopRequireDefault(__webpack_require__(1266));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * SpotLightShadowProcess。<br/>
 * 用于实现SpotLight光源阴影。<br/>
 * @author Kkk
 * @date 2021年9月23日17点11分
 */
var SpotLightShadowProcess = /*#__PURE__*/function (_BasicShadowProcess) {
  _inherits(SpotLightShadowProcess, _BasicShadowProcess);

  var _super = _createSuper(SpotLightShadowProcess);

  // 临时变量
  function SpotLightShadowProcess(owner, cfg) {
    var _this;

    _classCallCheck(this, SpotLightShadowProcess);

    cfg.nbShadowMaps = 1;
    _this = _super.call(this, owner, cfg);

    _defineProperty(_assertThisInitialized(_this), "_m_ShadowCam", void 0);

    _defineProperty(_assertThisInitialized(_this), "_m_OutAngle", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_SpotRange", -1);

    _defineProperty(_assertThisInitialized(_this), "_m_Position", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_Direction", new _Vector.default());

    _defineProperty(_assertThisInitialized(_this), "_m_UpdateCasterCam", false);

    _defineProperty(_assertThisInitialized(_this), "_m_TempVec3", new _Vector.default());

    _this.init(cfg.shadowMapSize);

    return _this;
  }

  _createClass(SpotLightShadowProcess, [{
    key: "init",
    value: function init(shadowMapSize) {
      this._m_ShadowCam = new _Camera.default(this._m_Scene, {
        id: this._m_Id + "_" + _Tools.default.nextId(),
        width: shadowMapSize,
        height: shadowMapSize,
        fixedSize: true
      });
    }
  }, {
    key: "initMat",
    value: function initMat() {
      _get(_getPrototypeOf(SpotLightShadowProcess.prototype), "initMat", this).call(this); // 追加材质定义


      this._m_PostShadowMat.addDefine(_ShaderSource.default.S_SPOTLIGHT_SHADOWS_SRC, false);
    }
  }, {
    key: "_uploadInfo",
    value: function _uploadInfo(gl, frameContext) {
      _get(_getPrototypeOf(SpotLightShadowProcess.prototype), "_uploadInfo", this).call(this, gl, frameContext); // 更新SpotLight信息


      var conVars = frameContext.m_LastSubShader.getContextVars();
      var rd = null;
      rd = conVars[_BasicShadowProcess2.default.S_LIGHT_DIR];

      if (rd) {
        var dir = this._m_Light.getDirection();

        gl.uniform3f(rd.loc, dir._m_X, dir._m_Y, dir._m_Z);
      }

      rd = conVars[_BasicShadowProcess2.default.S_LIGHT_POS];

      if (rd) {
        var pos = this._m_Light.getPosition();

        gl.uniform3f(rd.loc, pos._m_X, pos._m_Y, pos._m_Z);
      }
    }
  }, {
    key: "getShadowCam",
    value: function getShadowCam(shadowMapIndex) {
      return this._m_ShadowCam;
    }
  }, {
    key: "updateShadowCams",
    value: function updateShadowCams() {
      if (this._m_Light == null) {
        _Log.default.warn('无效光源!');

        return;
      }

      if (this._m_OutAngle != this._m_Light.getOuterAngle() || this._m_SpotRange != this._m_Light.getSpotRange() || !this._m_Position.equals(this._m_Light.getPosition()) || !this._m_Direction.equals(this._m_Light.getDirection())) {
        this._m_OutAngle = this._m_Light.getOuterAngle();
        this._m_SpotRange = this._m_Light.getSpotRange();

        this._m_Position.setTo(this._m_Light.getPosition());

        this._m_Direction.setTo(this._m_Light.getDirection());

        this._m_ShadowCam.setFrustumPerspective(this._m_OutAngle * _MoreMath.default.S_RAD_TO_DEG * 2.0, 1.0, 1.0, this._m_SpotRange);

        this._m_ShadowCam.lookAt(this._m_Position, this._m_Position.add(this._m_Direction, this._m_TempVec3), this._m_ShadowCam.getUp()); // 强制更新


        this._m_ShadowCam._updateFrustum();

        this._m_ShadowCam.getProjectViewMatrix(true);
      } else if (this._m_UpdateCasterCam) {
        this._m_UpdateCasterCam = false;

        this._m_ShadowCam.setFrustumPerspective(this._m_OutAngle * _MoreMath.default.S_RAD_TO_DEG * 2.0, 1.0, 1.0, this._m_SpotRange);

        this._m_ShadowCam._updateFrustum();
      }
    }
  }, {
    key: "getShadowGeometryCasts",
    value: function getShadowGeometryCasts(shadowMapIndex, shadowGeometryCasts) {
      var _this2 = this;

      // 从场景图中查找当前shadowCam要进行投射的物体
      var scenes = this._m_Scene.getSceneNodes();

      scenes.forEach(function (scene) {
        _Shadow.default.calculateNodeInFrustum(scene, _this2._m_ShadowCam, _Node.default.S_SHADOW_CAST, shadowGeometryCasts);
      });
      this._m_UpdateCasterCam = true;

      this._m_ShadowCam.setFrustumPerspective(this._m_OutAngle * _MoreMath.default.S_RAD_TO_DEG * 2.0, 1.0, 1.0, 1000.0);

      this._m_ShadowCam.getProjectViewMatrix(true);

      return shadowGeometryCasts;
    }
  }]);

  return SpotLightShadowProcess;
}(_BasicShadowProcess2.default);

exports["default"] = SpotLightShadowProcess;

/***/ }),

/***/ 1193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 资源加载器,管理资源加载,提供流数据异步加载,诸如:纹理载入，模型加载，材质定义文件加载等。<br/>
 * @author Kkk
 */
var AssetLoader = /*#__PURE__*/function () {
  function AssetLoader() {
    _classCallCheck(this, AssetLoader);
  }

  _createClass(AssetLoader, null, [{
    key: "_get",
    value: function _get(src, ok, type, options) {
      options = options || {
        sync: true
      };
      var request = new XMLHttpRequest(); // request.open('GET', src, true);//默认请求方式

      request.open(type || 'POST', src, options.sync);
      var inflate = options && options.inflate;
      if (inflate) request.responseType = 'arraybuffer';

      if (options.sync == false) {
        request.send(null);

        if (request.status === 200) {
          return request.responseText;
        } else {
          return null;
        }
      } else {
        request.onreadystatechange = function () {
          if (request.readyState === 4) {
            if (request.status === 200) {
              ok(request.response);
            } else {}
          }
        };

        request.send(null);
      }
    }
    /**
     * 返回一个路径的目录。<br/>
     * @param {String}[src]
     * @return {String}
     */

  }, {
    key: "getBasePath",
    value: function getBasePath(src) {
      var n = src.lastIndexOf('/');
      return n === -1 ? src : src.substring(0, n + 1);
    }
    /**
     * 加载一个文件。<br/>
     * 对于异步加载,将通过ok或err回调获得加载的结果;对于同步加载,直接返回结果,如果加载失败返回null。<br/>
     * @param {String}[url 文件请求路径]
     * @param {Function}[ok 异步加载成功回调接口]
     * @param {Function}[err 异步加载失败回调接口]
     * @param {String}[options.type 'GET'或'POST']
     * @param {Boolean}[options.sync true表示异步/false表示同步,默认为true]
     * @param {Boolean}[options.inflate true表示加载为二进制流/默认false]
     * @return {Object}[同步加载返回的结果]
     */

  }, {
    key: "loadFile",
    value: function loadFile(url, ok, err, options) {
      options = options || {
        type: 'GET',
        sync: true
      };
      options.type = options.type || 'GET';
      options.sync = options.sync != null ? options.sync : true;
      var request = new XMLHttpRequest();
      request.open(options.type, url, options.sync); // 二进制数据流

      var inflate = options && options.inflate;

      _Log.default.debug("inflate:" + inflate);

      if (inflate) {
        request.responseType = 'arraybuffer';

        _Log.default.debug("二进制");
      }

      if (options.sync == false) {
        request.send(null);

        if (request.status === 200) {
          return request.responseText;
        } else {
          return null;
        }
      } else {
        // 异步加载
        request.addEventListener('load', function (event) {
          var response = event.target.response;

          if (request.status === 200) {
            if (ok) {
              ok(response);
            }
          } else if (request.status === 0) {
            // 某些浏览器在使用非HTTP协议时会返回HTTP状态0
            // 例如 “文件：//”或“数据：//”。 处理成功。
            _Log.default.warn('loadFile: HTTP Status 0 received.');

            if (ok) {
              ok(response);
            }
          } else {
            if (err) {
              err(event);
            }
          }
        }, false);
        request.addEventListener('error', function (event) {
          if (err) {
            err(event);
          }
        }, false);
        request.send(null);
      }
    }
    /**
     * 加载材质定义文件。<br/>
     * @param {String}[filePath]
     * @param {Function}[callback]
     */

  }, {
    key: "loadMaterialSourceDef",
    value: function loadMaterialSourceDef(filePath, callback) {
      // 使用materialSourceDef加载器,同步加载器
      return AssetLoader._get(filePath, null, 'GET', {
        sync: false
      });
    }
    /**
     * 加载模型。<br/>
     * 支持的模型格式:OBJ,GLTF。<br/>
     * @param {String}[filePath]
     * @param {Function}[callback]
     */

  }, {
    key: "loadModel",
    value: function loadModel(filePath, callback) {// 判断文件类型
      // 以obj进行加载
    }
  }]);

  return AssetLoader;
}();

exports["default"] = AssetLoader;

/***/ }),

/***/ 66:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 观察者模型,事件触发器。
 * @author Kkk
 * @date 2021年2月1日16点03分
 */
var Events = /*#__PURE__*/function () {
  function Events(object) {
    _classCallCheck(this, Events);

    this.object = object;
    this.listeners = {};
  }

  _createClass(Events, [{
    key: "removeA",
    value: function removeA(arr) {
      var what,
          a = arguments,
          L = a.length,
          ax;

      while (L > 1 && arr.length) {
        what = a[--L];

        while ((ax = arr.indexOf(what)) !== -1) {
          arr.splice(ax, 1);
        }
      }

      return arr;
    }
  }, {
    key: "isset",
    value: function isset(variable) {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] == 'undefined' || arguments[i] == null) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "isArray",
    value: function isArray(variable) {
      return Object.prototype.toString.call(variable) === '[object Array]';
    }
  }, {
    key: "register",
    value: function register(event, callback, object) {
      if (typeof event != 'string' || typeof callback != 'function') {
        return;
      }

      if (!this.listeners[event]) {
        this.listeners[event] = new Array();
      }

      this.listeners[event].push({
        object: !this.isset(object) ? this.object : object,
        callback: callback
      });
    }
  }, {
    key: "unregister",
    value: function unregister(event, callback, object) {
      if (typeof event != 'string' || typeof callback != 'function') {
        return;
      }

      object = !this.isset(object) ? this.object : object;

      if (this.listeners[event]) {
        for (var i = 0; i < this.listeners[event].length; i++) {
          if (this.listeners[event][i].object == object && this.listeners[event][i].callback == callback) {
            this.listeners[event].splice(i, 1);
            break;
          }
        }
      }
    }
  }, {
    key: "trigger",
    value: function trigger(event, eventArguments, object) {
      if (typeof event != 'string') {
        return false;
      }

      eventArguments = eventArguments || new Array();

      if (!this.isset(eventArguments)) {
        eventArguments = new Array();
      } else if (!this.isArray(eventArguments)) {
        eventArguments = [eventArguments];
      }

      if (event.substring(0, 5).toLowerCase() == 'mouse') {
        eventArguments[0] = this.normalizeEvent(eventArguments[0]);
      }

      if (!this.listeners[event] || this.listeners[event].length == 0) {
        return true;
      }

      var listeners = this.listeners[event].slice(0);

      for (var i = 0; i < listeners.length; i++) {
        var continueEvent = null;

        if (this.isset(object)) {
          continueEvent = listeners[i].callback.apply(object, eventArguments);
        } else {
          continueEvent = listeners[i].callback.apply(listeners[i].object, eventArguments);
        }

        if (continueEvent === false) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "normalizeEvent",
    value: function normalizeEvent(event) {
      return event;
    }
  }]);

  return Events;
}();

exports["default"] = Events;

/***/ }),

/***/ 3846:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var sLog = console.log;
var sInfo = console.info;
var sWarn = console.warn;
var sDebug = console.debug;
var sError = console.error;
var sTime = console.time;
var sTimeEnd = console.timeEnd;
/**
 * 简单的日志系统。<br/>
 * 提供引擎内部日志控制的日志系统，用法同console一致，默认开启基本级别日志，如果需要开启或关闭级别日志，请调用enable()激活指定级别。<br/>
 * 用法:<br/>
 * Log.log("");或者Log.log("e",e);<br/>
 * Log.info("");Log.time("start");Log.timeEnd("start");<br/>
 * 开启或关闭:<br/>
 * Log.enable(Log.S_DEBUG, true/false);<br/>
 * @author Kkk
 * @date 2021年3月5日14点00分
 */

var Log = /*#__PURE__*/function () {
  function Log() {
    _classCallCheck(this, Log);
  }

  _createClass(Log, null, [{
    key: "debug",
    value: //默认定义,什么也不处理
    function debug() {}
  }, {
    key: "log",
    value: function log() {}
  }, {
    key: "info",
    value: function info() {}
  }, {
    key: "warn",
    value: function warn() {}
  }, {
    key: "error",
    value: function error() {}
  }, {
    key: "time",
    value: function time() {}
  }, {
    key: "timeEnd",
    value: function timeEnd() {}
  }, {
    key: "timeCalc",
    value: function timeCalc() {}
  }, {
    key: "enable",
    value: function enable(level, _enable) {
      switch (level) {
        case Log.S_DEBUG:
          Log.debug = _enable ? sDebug : function () {};
          break;

        case Log.S_INFO:
          Log.info = _enable ? sInfo : function () {};
          break;

        case Log.S_LOG:
          Log.log = _enable ? sLog : function () {};
          break;

        case Log.S_WARN:
          Log.warn = _enable ? sWarn : function () {};
          break;

        case Log.S_ERROR:
          Log.error = _enable ? sError : function () {};
          break;

        case Log.S_TIME:
          Log.time = _enable ? sTime : function () {};
          Log.timeEnd = _enable ? sTimeEnd : function () {};
          break;

        case Log.S_TIME_CALC:
          /**
           * 用法:
           * let timeCalc = Log.timeCalc();
           * .....
           * timeCalc = Log.timeCalc(timeCalc).time;
           * @param obj
           * @return {*}
           */
          Log.timeCalc = _enable ? function (obj) {
            if (obj) {
              obj.time = new Date().getTime() - obj.time;
              return obj;
            } else {
              obj = {};
              obj.time = new Date().getTime();
              return obj;
            }
          } : function () {};
          break;
      }
    }
  }]);

  return Log;
}();

exports["default"] = Log;

_defineProperty(Log, "S_DEBUG", 0);

_defineProperty(Log, "S_INFO", 1);

_defineProperty(Log, "S_WARN", 2);

_defineProperty(Log, "S_LOG", 3);

_defineProperty(Log, "S_ERROR", 4);

_defineProperty(Log, "S_TIME", 5);

_defineProperty(Log, "S_TIME_CALC", 6);

Log.enable(Log.S_LOG, true);
Log.enable(Log.S_INFO, true);
Log.enable(Log.S_DEBUG, true);
Log.enable(Log.S_ERROR, true);
Log.enable(Log.S_WARN, true);
Log.enable(Log.S_TIME, true);

/***/ }),

/***/ 8583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(9271));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MeshFactor = /*#__PURE__*/function () {
  function MeshFactor() {
    _classCallCheck(this, MeshFactor);
  }

  _createClass(MeshFactor, null, [{
    key: "nextId",
    value: function nextId() {
      return --MeshFactor.count;
    }
  }, {
    key: "pushVec3ToArray",
    value: function pushVec3ToArray(array, vec3) {
      array.push(vec3._m_X);
      array.push(vec3._m_Y);
      array.push(vec3._m_Z);
    }
    /**
     * 创建Probe数据。<br/>
     * @return {Mesh}
     */

  }, {
    key: "createProbeMesh",
    value: function createProbeMesh() {
      var mesh = new _Mesh.default(); // 对于不需要旋转的Sky,我们仅需要positions和indices数据

      mesh.setData(_Mesh.default.S_POSITIONS, [3.4201992, 0.0, -9.396927, 2.7669992, 2.0103426, -9.396927, 1.0568995, 3.2528028, -9.396927, -1.0568998, 3.2528026, -9.396927, -2.7669995, 2.0103424, -9.396927, -3.4201992, -2.9900332E-7, -9.396927, -2.766999, -2.010343, -9.396927, -1.0569, -3.2528026, -9.396927, 1.0569001, -3.2528026, -9.396927, 2.7670002, -2.0103416, -9.396927, 3.4201992, 0.0, -9.396927, 6.427875, 0.0, -7.660445, 5.20026, 3.7782102, -7.660445, 1.9863225, 6.1132727, -7.660445, -1.9863229, 6.113272, -7.660445, -5.2002606, 3.7782097, -7.660445, -6.427875, -5.6194267E-7, -7.660445, -5.2002597, -3.7782109, -7.660445, -1.9863232, -6.113272, -7.660445, 1.9863235, -6.113272, -7.660445, 5.2002616, -3.7782083, -7.660445, 6.427875, 0.0, -7.660445, 8.6602545, 0.0, -4.9999995, 7.0062933, 5.0903697, -4.9999995, 2.6761656, 8.236392, -4.9999995, -2.676166, 8.236391, -4.9999995, -7.006294, 5.090369, -4.9999995, -8.6602545, -7.5710346E-7, -4.9999995, -7.006293, -5.0903707, -4.9999995, -2.6761668, -8.236391, -4.9999995, 2.676167, -8.236391, -4.9999995, 7.006295, -5.0903673, -4.9999995, 8.6602545, 0.0, -4.9999995, 9.848078, 0.0, -1.7364818, 7.9672623, 5.7885547, -1.7364818, 3.0432231, 9.366078, -1.7364818, -3.0432239, 9.366078, -1.7364818, -7.9672627, 5.788554, -1.7364818, -9.848078, -8.6094633E-7, -1.7364818, -7.967262, -5.788556, -1.7364818, -3.0432243, -9.366078, -1.7364818, 3.0432246, -9.366078, -1.7364818, 7.9672647, -5.788552, -1.7364818, 9.848078, 0.0, -1.7364818, 9.848078, 0.0, 1.7364826, 7.9672623, 5.7885547, 1.7364826, 3.0432231, 9.366078, 1.7364826, -3.0432239, 9.366078, 1.7364826, -7.9672627, 5.788554, 1.7364826, -9.848078, -8.6094633E-7, 1.7364826, -7.967262, -5.788556, 1.7364826, -3.0432243, -9.366078, 1.7364826, 3.0432246, -9.366078, 1.7364826, 7.9672647, -5.788552, 1.7364826, 9.848078, 0.0, 1.7364826, 8.660254, 0.0, 5.0000005, 7.0062923, 5.090369, 5.0000005, 2.6761653, 8.236391, 5.0000005, -2.6761658, 8.23639, 5.0000005, -7.006293, 5.0903687, 5.0000005, -8.660254, -7.571034E-7, 5.0000005, -7.006292, -5.09037, 5.0000005, -2.6761663, -8.23639, 5.0000005, 2.6761665, -8.23639, 5.0000005, 7.0062943, -5.090367, 5.0000005, 8.660254, 0.0, 5.0000005, 6.427875, 0.0, 7.660445, 5.20026, 3.7782102, 7.660445, 1.9863225, 6.1132727, 7.660445, -1.9863229, 6.113272, 7.660445, -5.2002606, 3.7782097, 7.660445, -6.427875, -5.6194267E-7, 7.660445, -5.2002597, -3.7782109, 7.660445, -1.9863232, -6.113272, 7.660445, 1.9863235, -6.113272, 7.660445, 5.2002616, -3.7782083, 7.660445, 6.427875, 0.0, 7.660445, 3.4201992, 0.0, 9.396927, 2.7669992, 2.0103426, 9.396927, 1.0568995, 3.2528028, 9.396927, -1.0568998, 3.2528026, 9.396927, -2.7669995, 2.0103424, 9.396927, -3.4201992, -2.9900332E-7, 9.396927, -2.766999, -2.010343, 9.396927, -1.0569, -3.2528026, 9.396927, 1.0569001, -3.2528026, 9.396927, 2.7670002, -2.0103416, 9.396927, 3.4201992, 0.0, 9.396927, 0.0, 0.0, -10.0, 0.0, 0.0, 10.0]);
      mesh.setData(_Mesh.default.S_NORMALS, [-0.34201992, -0.0, 0.9396927, -0.27669993, -0.20103426, 0.9396927, -0.10568996, -0.32528028, 0.9396927, 0.10568998, -0.32528028, 0.9396927, 0.27669996, -0.20103423, 0.9396927, 0.34201992, 2.990033E-8, 0.9396927, 0.2766999, 0.20103431, 0.9396927, 0.10569, 0.32528028, 0.9396927, -0.10569002, 0.32528028, 0.9396927, -0.27670002, 0.20103417, 0.9396927, -0.34201992, -0.0, 0.9396927, -0.6427875, -0.0, 0.76604456, -0.520026, -0.37782103, 0.76604456, -0.19863226, -0.6113273, 0.76604456, 0.19863228, -0.61132723, 0.76604456, 0.5200261, -0.37782097, 0.76604456, 0.6427875, 5.6194267E-8, 0.76604456, 0.52002597, 0.3778211, 0.76604456, 0.19863233, 0.61132723, 0.76604456, -0.19863234, 0.61132723, 0.76604456, -0.52002615, 0.37782082, 0.76604456, -0.6427875, -0.0, 0.76604456, -0.86602545, -0.0, 0.49999997, -0.70062935, -0.50903696, 0.49999997, -0.26761654, -0.82363915, 0.4999999, 0.2676166, -0.8236391, 0.49999997, 0.70062935, -0.5090369, 0.4999999, 0.86602545, 7.5710346E-8, 0.49999997, 0.70062923, 0.509037, 0.4999999, 0.2676167, 0.8236391, 0.49999997, -0.26761672, 0.8236391, 0.49999997, -0.7006295, 0.5090367, 0.4999999, -0.86602545, -0.0, 0.49999997, -0.9848078, -0.0, 0.17364818, -0.7967262, -0.57885545, 0.17364818, -0.30432233, -0.93660784, 0.17364818, 0.3043224, -0.93660784, 0.17364818, 0.7967263, -0.57885545, 0.17364818, 0.9848078, 8.609464E-8, 0.17364818, 0.79672617, 0.57885563, 0.17364818, 0.30432245, 0.93660784, 0.17364818, -0.30432245, 0.93660784, 0.17364818, -0.79672647, 0.5788552, 0.17364818, -0.9848078, -0.0, 0.17364818, -0.9848078, -0.0, -0.17364827, -0.7967262, -0.57885545, -0.17364827, -0.30432233, -0.93660784, -0.17364827, 0.3043224, -0.93660784, -0.17364827, 0.7967263, -0.57885545, -0.17364827, 0.9848078, 8.609464E-8, -0.17364827, 0.7967261, 0.5788556, -0.17364825, 0.30432242, 0.9366078, -0.17364825, -0.30432245, 0.9366078, -0.17364825, -0.79672647, 0.5788552, -0.17364827, -0.9848078, -0.0, -0.17364827, -0.8660254, -0.0, -0.50000006, -0.70062923, -0.50903696, -0.50000006, -0.26761654, -0.8236391, -0.50000006, 0.2676166, -0.82363904, -0.50000006, 0.7006293, -0.5090369, -0.50000006, 0.8660254, 7.571034E-8, -0.50000006, 0.7006292, 0.509037, -0.50000006, 0.26761663, 0.82363904, -0.50000006, -0.26761666, 0.82363904, -0.50000006, -0.7006294, 0.5090367, -0.50000006, -0.8660254, -0.0, -0.50000006, -0.6427875, -0.0, -0.76604456, -0.520026, -0.37782103, -0.76604456, -0.19863226, -0.6113273, -0.76604456, 0.19863228, -0.61132723, -0.76604456, 0.5200261, -0.37782097, -0.76604456, 0.6427875, 5.6194267E-8, -0.76604456, 0.52002597, 0.3778211, -0.76604456, 0.19863233, 0.61132723, -0.76604456, -0.19863234, 0.61132723, -0.76604456, -0.52002615, 0.37782082, -0.76604456, -0.6427875, -0.0, -0.76604456, -0.34201992, -0.0, -0.9396927, -0.27669993, -0.20103426, -0.9396927, -0.10568996, -0.32528028, -0.9396927, 0.10568998, -0.32528028, -0.9396927, 0.27669996, -0.20103423, -0.9396927, 0.34201992, 2.990033E-8, -0.9396927, 0.2766999, 0.20103431, -0.9396927, 0.10569, 0.32528028, -0.9396927, -0.10569002, 0.32528028, -0.9396927, -0.27670002, 0.20103417, -0.9396927, -0.34201992, -0.0, -0.9396927, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0]);
      mesh.setData(_Mesh.default.S_INDICES, [0, 11, 1, 1, 11, 12, 1, 12, 2, 2, 12, 13, 2, 13, 3, 3, 13, 14, 3, 14, 4, 4, 14, 15, 4, 15, 5, 5, 15, 16, 5, 16, 6, 6, 16, 17, 6, 17, 7, 7, 17, 18, 7, 18, 8, 8, 18, 19, 8, 19, 9, 9, 19, 20, 9, 20, 10, 10, 20, 21, 11, 22, 12, 12, 22, 23, 12, 23, 13, 13, 23, 24, 13, 24, 14, 14, 24, 25, 14, 25, 15, 15, 25, 26, 15, 26, 16, 16, 26, 27, 16, 27, 17, 17, 27, 28, 17, 28, 18, 18, 28, 29, 18, 29, 19, 19, 29, 30, 19, 30, 20, 20, 30, 31, 20, 31, 21, 21, 31, 32, 22, 33, 23, 23, 33, 34, 23, 34, 24, 24, 34, 35, 24, 35, 25, 25, 35, 36, 25, 36, 26, 26, 36, 37, 26, 37, 27, 27, 37, 38, 27, 38, 28, 28, 38, 39, 28, 39, 29, 29, 39, 40, 29, 40, 30, 30, 40, 41, 30, 41, 31, 31, 41, 42, 31, 42, 32, 32, 42, 43, 33, 44, 34, 34, 44, 45, 34, 45, 35, 35, 45, 46, 35, 46, 36, 36, 46, 47, 36, 47, 37, 37, 47, 48, 37, 48, 38, 38, 48, 49, 38, 49, 39, 39, 49, 50, 39, 50, 40, 40, 50, 51, 40, 51, 41, 41, 51, 52, 41, 52, 42, 42, 52, 53, 42, 53, 43, 43, 53, 54, 44, 55, 45, 45, 55, 56, 45, 56, 46, 46, 56, 57, 46, 57, 47, 47, 57, 58, 47, 58, 48, 48, 58, 59, 48, 59, 49, 49, 59, 60, 49, 60, 50, 50, 60, 61, 50, 61, 51, 51, 61, 62, 51, 62, 52, 52, 62, 63, 52, 63, 53, 53, 63, 64, 53, 64, 54, 54, 64, 65, 55, 66, 56, 56, 66, 67, 56, 67, 57, 57, 67, 68, 57, 68, 58, 58, 68, 69, 58, 69, 59, 59, 69, 70, 59, 70, 60, 60, 70, 71, 60, 71, 61, 61, 71, 72, 61, 72, 62, 62, 72, 73, 62, 73, 63, 63, 73, 74, 63, 74, 64, 64, 74, 75, 64, 75, 65, 65, 75, 76, 66, 77, 67, 67, 77, 78, 67, 78, 68, 68, 78, 79, 68, 79, 69, 69, 79, 80, 69, 80, 70, 70, 80, 81, 70, 81, 71, 71, 81, 82, 71, 82, 72, 72, 82, 83, 72, 83, 73, 73, 83, 84, 73, 84, 74, 74, 84, 85, 74, 85, 75, 75, 85, 86, 75, 86, 76, 76, 86, 87, 0, 1, 88, 1, 2, 88, 2, 3, 88, 3, 4, 88, 4, 5, 88, 5, 6, 88, 6, 7, 88, 7, 8, 88, 8, 9, 88, 9, 10, 88, 77, 89, 78, 78, 89, 79, 79, 89, 80, 80, 89, 81, 81, 89, 82, 82, 89, 83, 83, 89, 84, 84, 89, 85, 85, 89, 86, 86, 89, 87]);
      return mesh;
    }
    /**
     * 根据AABBBoundingBox创建包围盒渲染数据。<br/>
     * @param {AABBBoudingBox}[aabbBoundingBox]
     * @return {Mesh}
     */

  }, {
    key: "createAABBBoundingBoxMeshFromAABBBoundingBox",
    value: function createAABBBoundingBoxMeshFromAABBBoundingBox(aabbBoundingBox) {
      var mesh = new _Mesh.default(); // 计算4个点

      var min = aabbBoundingBox.getMin();
      var max = aabbBoundingBox.getMax();
      var positions = [// bbl
      min._m_X, min._m_Y, min._m_Z, // bfl
      min._m_X, min._m_Y, max._m_Z, // bbr
      max._m_X, min._m_Y, min._m_Z, // bfr
      max._m_X, min._m_Y, max._m_Z, // tbl
      min._m_X, max._m_Y, min._m_Z, // tfl
      min._m_X, max._m_Y, max._m_Z, // tbr
      max._m_X, max._m_Y, min._m_Z, // tfr
      max._m_X, max._m_Y, max._m_Z];
      var indices = [// bottom
      0, 1, 1, 3, 3, 2, 2, 0, // top
      4, 5, 5, 7, 7, 6, 6, 4, // left
      0, 4, 1, 5, // right
      2, 6, 3, 7];
      mesh.setData(_Mesh.default.S_POSITIONS, positions);
      mesh.setData(_Mesh.default.S_INDICES, indices);
      mesh.setPrimitive(_Mesh.default.S_PRIMITIVE_LINES);
      return mesh;
    }
    /**
     * 基于指定Camera创建视锥体。<br/>
     * 注意:返回的视锥体是当前Camera状态下的可视化，即处于当前Camera位置，如果要单独创建位于原点的视锥体，请将viewSpace设置为false。<br/>
     * @param {Camera}[camera]
     * @param {Boolean}[viewSpace 默认为true,表示计算结果为viewSpace]
     * @return {Mesh}
     */

  }, {
    key: "createViewFrustumMeshFromCamera",
    value: function createViewFrustumMeshFromCamera(camera, viewSpace) {
      var w = camera.getWidth();
      var h = camera.getHeight();
      var positions = [];
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(0, 0), 0, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(0, h), 0, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(w, h), 0, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(w, 0), 0, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(0, 0), 1, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(0, h), 1, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(w, h), 1, viewSpace || true));
      MeshFactor.pushVec3ToArray(positions, camera.getWorldCoordinates(new _Vector.default(w, 0), 1, viewSpace || true)); // indices

      var indices = [0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7];
      var mesh = new _Mesh.default();
      mesh.setData(_Mesh.default.S_POSITIONS, positions);
      mesh.setData(_Mesh.default.S_INDICES, indices);
      mesh.setPrimitive(_Mesh.default.S_PRIMITIVE_LINES);
      return mesh;
    }
  }]);

  return MeshFactor;
}();

exports["default"] = MeshFactor;

_defineProperty(MeshFactor, "count", 0);

/***/ }),

/***/ 5247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _FrameBuffer = _interopRequireDefault(__webpack_require__(7341));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _TextureCubeVars = _interopRequireDefault(__webpack_require__(4048));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _SkyBox = _interopRequireDefault(__webpack_require__(9468));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * EnvCapture。<br/>
 * 环境捕捉对象，用于将环境数据捕捉到一个CubeMap中，以便提供反射探头或GI探头参考数据。<br/>
 * @author Kkk
 * @date 2021年3月22日13点36分
 */
var EnvCapture = /*#__PURE__*/function () {
  /**
   * 创建一个EnvCapture。<br/>
   * @param {Scene}[scene]
   * @param {Number}[resolute]
   * @param {Vector3}[position]
   * @param {Boolean}[mipmap]
   */
  function EnvCapture(scene, resolute, position, mipmap) {
    _classCallCheck(this, EnvCapture);

    this._m_Scene = scene;
    this._m_MipMap = mipmap;
    this._m_Resolute = resolute;
    this._m_CaptureCameres = [];
    this._m_CaptureFrames = [];
    this._m_CaptureResult = new _TextureCubeVars.default(scene);

    this._m_CaptureResult.setTextureFormat(_TextureCubeVars.default.S_TEXTURE_FORMAT.S_RGBA16F, _TextureCubeVars.default.S_TEXTURE_FORMAT.S_RGBA, _TextureCubeVars.default.S_TEXTURE_FORMAT.S_FLOAT);

    this._m_CapturePixels = [];
    this._m_Position = new _Vector.default();

    if (position) {
      this._m_Position.setTo(position);
    } // 用于捕获prefilterEnvMap(关于这一点，这里有一点需要注意的是，这里虽然保留了cpu解决方案，但是使用gpu解决方案，原因是在web上启用多线程cpu解决方案不如gpu解决方案高效)


    this._m_PrefilterSky = new _SkyBox.default(scene, {
      id: 'prefitlerSky' + _Tools.default.nextId()
    });

    this._m_PrefilterSky.setMaterial(new _Material.default(scene, {
      id: 'prefilterMat' + _Tools.default.nextId(),
      materialDef: _MaterialDef.default.parse(_Internal.default.S_PREFILTER_DEF)
    }));

    this._m_PrefilterSky.getMaterial().setParam('roughness', new _FloatVars.default().valueOf(0));

    this._m_PrefilterSky.getMaterial().setParam('resolution', new _FloatVars.default().valueOf(resolute));

    this._m_PrefilterSky.getMaterial().setParam('envMap', this._m_CaptureResult);

    this._m_PrefilterMap = new _TextureCubeVars.default(scene);

    this._m_PrefilterMap.setTextureFormat(_TextureCubeVars.default.S_TEXTURE_FORMAT.S_RGBA16F, _TextureCubeVars.default.S_TEXTURE_FORMAT.S_RGBA, _TextureCubeVars.default.S_TEXTURE_FORMAT.S_FLOAT);

    this._m_PrefilterMap.setFilter(scene, _TextureCubeVars.default.S_FILTERS.S_LINEAR_MIPMAP_NEAREST, _TextureCubeVars.default.S_FILTERS.S_LINEAR);

    this._m_PrefilterMipmap = 0;
    var height = resolute;
    var width = resolute;

    while (height >= 1 || width >= 1) {
      if (height == 1 || width == 1) {
        break;
      }

      height /= 2;
      width /= 2;
      this._m_PrefilterMipmap++;
    } // 初始化


    this._init();
  }
  /**
   * 初始化。<br/>
   * @private
   */


  _createClass(EnvCapture, [{
    key: "_init",
    value: function _init() {
      var at = new _Vector.default();

      var gl = this._m_Scene.getCanvas().getGLContext();

      for (var i = 0; i < 6; i++) {
        this._m_CaptureCameres[i] = new _Camera.default(this._m_Scene, {
          id: 'capture_' + i + "_" + _Tools.default.nextId(),
          fovy: 90.0,
          aspect: 1.0
        });

        EnvCapture._S_CAPTURE_CONFIG[i].dir.add(this._m_Position, at);

        this._m_CaptureCameres[i].lookAt(this._m_Position, at, EnvCapture._S_CAPTURE_CONFIG[i].up);

        this._m_CaptureFrames[i] = new _FrameBuffer.default(gl, 'capture_frame_' + i + "_" + _Tools.default.nextId(), this._m_Resolute, this._m_Resolute);

        this._m_CaptureFrames[i].addTexture(gl, 'capture_texture_' + i, gl.RGBA16F, 0, gl.RGBA, gl.FLOAT, gl.COLOR_ATTACHMENT0, false, this._m_MipMap);

        this._m_CaptureFrames[i].addBuffer(gl, 'capture_depth_' + i, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);

        this._m_CaptureFrames[i].finish(gl, this._m_Scene, false);
      } // 设置默认数据


      this._m_CaptureResult.setPreloadColor(this._m_Scene, new _Vector2.default(0.5, 0.5, 0.5, 1.0));
    }
    /**
     * 设置捕捉位置。<br/>
     * @param {Vector3}[pos]
     */

  }, {
    key: "setPosition",
    value: function setPosition(pos) {
      this._m_Position.setTo(pos);
    }
    /**
     * 返回捕捉位置。<br/>
     * @return {Vector3}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this._m_Position;
    }
    /**
     * 捕捉环境数据。<br/>
     */

  }, {
    key: "capture",
    value: function capture() {
      var gl = this._m_Scene.getCanvas().getGLContext(); // 以便编译材质


      this._m_Scene.getRender()._resetFrameContext();

      this._m_Scene.getRender()._drawEnv(gl);

      var mainCamera = this._m_Scene.getMainCamera();

      var render = this._m_Scene.getRender();

      var pixels = null;
      render.setViewPort(gl, 0, 0, this._m_Resolute, this._m_Resolute);

      for (var i = 0; i < 6; i++) {
        this._m_Scene.setMainCamera(this._m_CaptureCameres[i]);

        this._m_CaptureFrames[i].use(render);

        this._m_CaptureFrames[i].clear(gl); // 目前仅支持捕捉环境（后续完善对场景的捕捉）


        this._m_Scene.getRender()._drawEnv(gl);

        pixels = this._m_CaptureFrames[i].readPixels(gl, '', gl.RGBA, gl.FLOAT);
        this._m_CapturePixels[i] = pixels; // Log.log('pixels:',pixels);
        // 将像素数据设置到结果纹理中

        this._m_CaptureResult.setImage(this._m_Scene, EnvCapture._S_CAPTURE_FACE[i], pixels, {
          width: this._m_Resolute,
          height: this._m_Resolute
        });
      }

      this._m_CaptureResult.setWrap(this._m_Scene, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE);

      this._m_Scene.setMainCamera(mainCamera);

      this._m_Scene.getRender().useDefaultFrame();

      render.setViewPort(gl, 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight());
    }
    /**
     * 捕获PrefilteredEnvMap
     */

  }, {
    key: "prefiltered",
    value: function prefiltered() {
      var gl = this._m_Scene.getCanvas().getGLContext();

      var sky = this._m_Scene.getSky();

      this._m_Scene.setSky(this._m_PrefilterSky); // 以便编译材质


      this._m_Scene.getRender()._resetFrameContext();

      this._m_Scene.getRender()._drawEnv(gl);

      var mainCamera = this._m_Scene.getMainCamera();

      var render = this._m_Scene.getRender();

      var pixels = null;
      render.setViewPort(gl, 0, 0, this._m_Resolute, this._m_Resolute);
      var mipWidth, mipHeight;

      for (var i = 0; i < 6; i++) {
        this._m_Scene.setMainCamera(this._m_CaptureCameres[i]);

        this._m_CaptureFrames[i].use(render);

        this._m_CaptureFrames[i].clear(gl);

        for (var mip = 0; mip <= this._m_PrefilterMipmap; mip++) {
          mipWidth = this._m_Resolute * Math.pow(0.5, mip);
          mipHeight = this._m_Resolute * Math.pow(0.5, mip); // Log.log('size:(' + mipWidth + "x" + mipHeight + ")");

          this._m_PrefilterSky.getMaterial().setParam('roughness', new _FloatVars.default().valueOf(mip * 1.0 / (this._m_PrefilterMipmap - 1.0)));

          this._m_CaptureFrames[i].clear(gl); // 目前仅支持捕捉环境（后续完善对场景的捕捉）


          this._m_Scene.getRender()._drawEnv(gl);

          pixels = this._m_CaptureFrames[i].readPixels(gl, '', gl.RGBA, gl.FLOAT); // 将像素数据设置到结果纹理中

          this._m_PrefilterMap.setImage(this._m_Scene, EnvCapture._S_CAPTURE_FACE[i], pixels, {
            width: mipWidth,
            height: mipHeight,
            mipmapLevel: mip
          });
        }
      }

      this._m_PrefilterMap.setWrap(this._m_Scene, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE, _TextureCubeVars.default.S_WRAPS.S_CLAMP_TO_EDGE);

      this._m_Scene.setMainCamera(mainCamera);

      this._m_Scene.getRender().useDefaultFrame();

      this._m_Scene.setSky(sky);

      render.setViewPort(gl, 0, 0, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight());
    }
    /**
     * 返回捕获数据。<br/>
     * @return {TextureCubeVars}
     */

  }, {
    key: "getCaptureTextureCube",
    value: function getCaptureTextureCube() {
      return this._m_CaptureResult;
    }
    /**
     * 返回捕获数据。<br/>
     * @return {ArrayBuffer[]}
     */

  }, {
    key: "getCapturePixels",
    value: function getCapturePixels() {
      return this._m_CapturePixels;
    }
    /**
     * 返回预过滤环境图。<br/>
     * @return {TextureCubeVars}
     */

  }, {
    key: "getPrefilterTextureCube",
    value: function getPrefilterTextureCube() {
      return this._m_PrefilterMap;
    }
    /**
     * 返回PrefilterMipMap级别数量。<br/>
     * @return {Number}
     */

  }, {
    key: "getPrefilterMipMap",
    value: function getPrefilterMipMap() {
      return this._m_PrefilterMipmap;
    }
  }]);

  return EnvCapture;
}();
/**
 * ProbeTools。<br/>
 * 提供一系列RefProbe,GIProbe工具函数。<br/>
 * @author Kkk
 * @date 2021年3月20日16点21分
 */


_defineProperty(EnvCapture, "_S_CAPTURE_CONFIG", [// PositiveX
{
  dir: new _Vector.default(1, 0, 0),
  up: new _Vector.default(0, -1, 0)
}, // NegativeX
{
  dir: new _Vector.default(-1, 0, 0),
  up: new _Vector.default(0, -1, 0)
}, // PositiveY
{
  dir: new _Vector.default(0, 1, 0),
  up: new _Vector.default(0, 0, 1)
}, // NegativeY
{
  dir: new _Vector.default(0, -1, 0),
  up: new _Vector.default(0, 0, -1)
}, // PositiveZ
{
  dir: new _Vector.default(0, 0, 1),
  up: new _Vector.default(0, -1, 0)
}, // NegativeZ
{
  dir: new _Vector.default(0, 0, -1),
  up: new _Vector.default(0, -1, 0)
}]);

_defineProperty(EnvCapture, "_S_CAPTURE_FACE", {
  0: _TextureCubeVars.default.S_FACE.PositiveX,
  1: _TextureCubeVars.default.S_FACE.NegativeX,
  2: _TextureCubeVars.default.S_FACE.PositiveY,
  3: _TextureCubeVars.default.S_FACE.NegativeY,
  4: _TextureCubeVars.default.S_FACE.PositiveZ,
  5: _TextureCubeVars.default.S_FACE.NegativeZ
});

var ProbeTools = /*#__PURE__*/function () {
  function ProbeTools() {
    _classCallCheck(this, ProbeTools);
  }

  _createClass(ProbeTools, null, [{
    key: "captureProbe",
    value: // 默认捕获分辨率
    // 修复接缝的方案
    // 有关这些系数，请参见Peter-Pike Sloan论文。

    /**
     * 捕获环境数据到探头中。<br/>
     * @param {Scene}[scene]
     * @param {Probe}[probe]
     * @param {Number}[options.resolute 分辨率,默认256]
     */
    function captureProbe(scene, probe, options) {
      // 创建捕捉镜头
      var gl = scene.getCanvas().getGLContext();
      var resolute = options && options.resolute != null ? options.resolute : ProbeTools._S_DEFAULT_CAPTURE_RESOLUTE;
      var envCapture = new EnvCapture(scene, resolute, probe.getPosition(), options.mipmap); // 开始捕捉

      _Log.default.time('capture!');

      envCapture.capture();

      _Log.default.timeEnd('capture!');

      return envCapture;
    }
  }, {
    key: "bakeGIProbe",
    value: function bakeGIProbe(scene, giProbe, options) {
      options = options || {};
      options.mipmap = true;
      var resolute = options && options.resolute != null ? options.resolute : ProbeTools._S_DEFAULT_CAPTURE_RESOLUTE;
      var envCapture = ProbeTools.captureProbe(scene, giProbe, options); // 可以在子线程中进行
      // 计算球谐系数

      _Log.default.time('shCoeffs');

      var shCoeffs = ProbeTools.getShCoeffs(resolute, resolute, envCapture.getCapturePixels(), ProbeTools._S_FIX_SEAMS_METHOD.Wrap);
      ProbeTools.prepareShCoefs(shCoeffs); // shCoeffs[0].setToInXYZ(0.37123486, 0.28240448, 0.2381286);
      // shCoeffs[1].setToInXYZ(-0.11429441, -0.024181858, 0.036112532);
      // shCoeffs[2].setToInXYZ(-0.17223172, -0.09823992, -0.057545196);
      // shCoeffs[3].setToInXYZ(0.029801141, 0.0883107, 0.13856964);
      // shCoeffs[4].setToInXYZ(0.03002505, 0.02395944, 0.032721985);
      // shCoeffs[5].setToInXYZ(0.13808998, 0.054031435, 0.0057469863);
      // shCoeffs[6].setToInXYZ(-0.0028244117, -0.017800365, -0.02938147);
      // shCoeffs[7].setToInXYZ(0.02475643, -0.025586102, -0.06279054);
      // shCoeffs[8].setToInXYZ(0.03176331, 0.07265141, 0.10513105);

      giProbe.setShCoeffs(shCoeffs);

      _Log.default.timeEnd('shCoeffs'); // 计算prefilterMap


      _Log.default.time('prefiltered');

      envCapture.prefiltered();
      giProbe.setPrefilterEnvMap(envCapture.getPrefilterTextureCube());
      giProbe.setPrefilterMipmap(envCapture.getPrefilterMipMap());

      _Log.default.timeEnd('prefiltered');

      return envCapture;
    }
  }, {
    key: "_bakePrefilteredEnvMap",
    value: function _bakePrefilteredEnvMap(sEnvMap, resolute, fixSeamsMethod, pem) {
      var mipMap = 4;
      var sourcePixels = sEnvMap.getCapturePixels();
      var targetPixels = pem.getCapturePixels();
      var texelVect = new _Vector.default();
      var color = new _Vector.default();
      var outColor = new _Vector2.default();
      var targetMipMapSize = resolute;

      for (var mipLevel = 0; mipLevel < mipMap; mipLevel++) {
        var roughness = ProbeTools._getRFM(mipLevel, mipMap);

        var samples = ProbeTools._getSFM(mipLevel, mipMap);

        for (var y = 0; y < targetMipMapSize; y++) {
          for (var x = 0; x < targetMipMapSize; x++) {
            color.setToInXYZ(0, 0, 0);

            ProbeTools._getVFCFTC(x, y, targetMipMapSize, face, texelVect, fixSeamsMethod);
          }
        }
      }
    }
  }, {
    key: "_prefilterEnvMapTexel",
    value: function _prefilterEnvMapTexel(resolute, envMapPixels, roughness, N, numSamples, mipLevel, prefilteredColor) {
      var totalWeight = 0.0;
      var rotations = 1;
      var rad = 2.0 * Math.PI / rotations; // 偏移旋转以避免采样模式

      var gi = Math.abs(N._m_Z + N._m_X) * 256.0;
      var offset = rad * (Math.cos(gi * 0.5 % (2.0 * Math.PI)) * 0.5 + 0.5);
      var a2 = roughness * roughness;
      a2 *= a2;
      var upVector = ProbeTools._S_TEMP_UNIT_X;

      if (Math.abs(N._m_Z) < 0.999) {
        upVector = ProbeTools._S_TEMP_UNIT_Y;
      }

      var tangentX = new _Vector.default();
      var tangentY = new _Vector.default();
      tangentX.setTo(upVector);
      tangentX.cross(N);
      tangentX.normal();
      tangentY.setTo(N);
      tangentY.cross(tangentX); // 在模型空间视图中==normal== 0,0,1

      var V = new _Vector.default(0, 0, 1);
      var lWorld = new _Vector.default();
      var Xi = new _Vector2.default();
      var H = new _Vector.default();

      for (var i = 0; i < numSamples; i++) {
        Xi = ProbeTools._getHPoint(i, numSamples, Xi);
        H = ProbeTools._iSGGX(Xi, a2, H);
        H.normal();
        var VoH = H._m_Z;
        var L = H.multLength(VoH * 2.0).sub(V);
        var NoL = L._m_Z;
        var computedMipLevel = mipLevel;

        if (mipLevel != 0) {
          computedMipLevel = ProbeTools._computeMipLevel(roughness, numSamples, resolute, VoH);
        }

        ProbeTools._2World(L, N, tangentX, tangentY, lWorld);

        totalWeight += 0;
      }
    }
  }, {
    key: "_getHPoint",
    value: function _getHPoint(i, nbrSample, store) {
      var phi;
      var ui = i;
      store._m_X = i * 1.0 / nbrSample; // Radical Inverse：范德·科普特

      ui = ui << 16 | ui >> 16;
      ui = (ui & 0x55555555) << 1 | (ui & 0xAAAAAAAA) >>> 1;
      ui = (ui & 0x33333333) << 2 | (ui & 0xCCCCCCCC) >>> 2;
      ui = (ui & 0x0F0F0F0F) << 4 | (ui & 0xF0F0F0F0) >>> 4;
      ui = (ui & 0x00FF00FF) << 8 | (ui & 0xFF00FF00) >>> 8;
      ui = ui & 0xffffffff;
      store._m_Y = 2.3283064365386963e-10 * (ui * 1.0); // 0x100000000

      phi = 2.0 * Math.PI * store._m_Y;
      store._m_Z = Math.cos(phi);
      store._m_W = Math.sin(phi);
      return store;
    }
  }, {
    key: "_2World",
    value: function _2World(L, N, tangentX, tangentY, store) {
      store.setTo(tangentX);
      store.multLength(L._m_X);
      var tmp = new _Vector.default();
      tmp.set(tangentY);
      tmp.multLength(L._m_Y);
      store.add(tmp);
      tmp.set(N);
      tmp.multLength(L._m_Z);
      store.add(tmp);
    }
  }, {
    key: "_samplePixel",
    value: function _samplePixel(resolute, envMapPixels, lWorld, NoL, computedMipLevel, store) {
      if (NoL <= 0) {
        return 0;
      }

      var c = new _Vector2.default();
      store._m_X = store._m_X + c._m_X * NoL;
      store._m_Y = store._m_Y + c._m_Y * NoL;
      store._m_Z = store._m_Z + c._m_Z * NoL;
      return NoL;
    }
    /**
     * 返回重要性采样。<br/>
     * @param {Vector4}[xi]
     * @param {Number}[a2]
     * @param {Vector3}[store]
     * @return {Vector3}
     * @private
     */

  }, {
    key: "_iSGGX",
    value: function _iSGGX(xi, a2, store) {
      var cosTheta = Math.sqrt((1.0 - xi._m_X) / (1.0 + (a2 - 1.0) * xi._m_X));
      var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);
      var sinThetaCosPhi = sinTheta * xi._m_Z; //xi._m_Z is cos(phi)

      var sinThetaSinPhi = sinTheta * xi._m_W; //xi._m_W is sin(phi)

      store._m_X = sinThetaCosPhi;
      store._m_Y = sinThetaSinPhi;
      store._m_Z = cosTheta;
      return store;
    }
  }, {
    key: "_ggx",
    value: function _ggx(NoH, alpha) {
      // 没啥好说的，参考迪斯尼的GGX或Ue4的GGX
      var tmp = alpha / (NoH * NoH * (alpha * alpha - 1.0) + 1.0);
      return tmp * tmp * (1.0 / Math.PI);
    }
  }, {
    key: "_computeMipLevel",
    value: function _computeMipLevel(roughness, numSamples, size, voH) {
      // H [2]在本地空间中为NoH
      // 添加1.e-5以避免ggx / 0.0
      var NoH = voH + 1E-5; // 概率分布函数

      var Pdf = ProbeTools._ggx(NoH, roughness) * NoH / (4.0 * voH); // 该样品代表的立体角

      var omegaS = 1.0 / (numSamples * Pdf); // 由1个像素覆盖的立体角，其中包含6个面，分别为EnvMapSize X EnvMapSize

      var omegaP = 4.0 * Math.PI / (6.0 * size * size); // 原始论文建议对Mip施加偏见以改善结果

      var mipBias = 1.0; // 我测试了偏差1的结果更好

      var maxLod = Math.log(size) / Math.log(2.0);
      var log2 = Math.log(omegaS / omegaP) / Math.log(2);
      return Math.min(Math.max(0.5 * log2 + mipBias, 0.0), 1.0 * maxLod);
    }
    /**
     * 返回线性粗糙度。<br/>
     * @param {Number}[miplevel]
     * @param {Number}[miptot]
     * @return {Number}
     * @private
     */

  }, {
    key: "_getRFM",
    value: function _getRFM(miplevel, miptot) {
      var step = 1.0 / (miptot - 1.0);
      step *= miplevel;
      return step * step;
    }
    /**
     * 返回采样率。<br/>
     * @param {Number}[mipLevel]
     * @param {Number}[miptot]
     * @return {Number}
     * @private
     */

  }, {
    key: "_getSFM",
    value: function _getSFM(mipLevel, miptot) {
      return mipLevel == 0 ? 1 : Math.min(1 << miptot - 1 + mipLevel * 2, 8192);
    }
    /**
     * 准备球谐系数。<br/>
     * @param {Vector3[]}[shCoefs]
     */

  }, {
    key: "prepareShCoefs",
    value: function prepareShCoefs(shCoefs) {
      var sqrtPi = ProbeTools._S_SQRT_PI;
      var sqrt3Pi = ProbeTools._S_SQRT_3PI;
      var sqrt5Pi = ProbeTools._S_SQRT_5PI;
      var sqrt15Pi = ProbeTools._S_SQRT_15PI;
      var coef0 = 1.0 / (2.0 * sqrtPi);
      var coef1 = -sqrt3Pi / 2.0;
      var coef2 = -coef1;
      var coef3 = coef1;
      var coef4 = sqrt15Pi / 2.0;
      var coef5 = -coef4;
      var coef6 = sqrt5Pi / 4.0;
      var coef7 = coef5;
      var coef8 = sqrt15Pi / 4.0; // 不知为何，这里有个地方算得有问题，暂时只能通过*-1来修复

      shCoefs[0].multLength(coef0).multLength(ProbeTools._S_SH_BAND_FACTOR[0]);
      shCoefs[1].multLength(coef1).multLength(ProbeTools._S_SH_BAND_FACTOR[1]);
      shCoefs[2].multLength(-coef2).multLength(ProbeTools._S_SH_BAND_FACTOR[2]);
      shCoefs[3].multLength(-coef3).multLength(ProbeTools._S_SH_BAND_FACTOR[3]);
      shCoefs[4].multLength(-coef4).multLength(ProbeTools._S_SH_BAND_FACTOR[4]);
      shCoefs[5].multLength(-coef5).multLength(ProbeTools._S_SH_BAND_FACTOR[5]);
      shCoefs[6].multLength(coef6).multLength(ProbeTools._S_SH_BAND_FACTOR[6]);
      shCoefs[7].multLength(coef7).multLength(ProbeTools._S_SH_BAND_FACTOR[7]);
      shCoefs[8].multLength(coef8).multLength(ProbeTools._S_SH_BAND_FACTOR[8]);
    }
    /**
     * 返回此立方体贴图的球谐系数。<br/>
     * @param {Number}[width map宽度]
     * @param {Number}[height map高度]
     * @param {ArrayBuffer}[cubeMapPixels]
     * @param {Number}[ProbeTools._FIX_SEAMS_METHOD]
     * @return {Vector3[]}[9个向量的数组，代表每个RGB通道的系数]
     */

  }, {
    key: "getShCoeffs",
    value: function getShCoeffs(width, height, cubeMapPixels, fixSeamsMethod) {
      var shCoef = [];

      for (var i = 0; i < 9; i++) {
        shCoef.push(new _Vector.default());
      }

      var shDir = [];
      var weightAccum = 0.0;
      var weight;
      var texelVect = new _Vector.default();
      var color = new _Vector2.default();

      for (var f = 0; f < 6; f++) {
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            weight = ProbeTools.getSAAV(x, y, width, f, texelVect, fixSeamsMethod);
            ProbeTools.evalShBasis(texelVect, shDir);

            ProbeTools._getPixelColor(x, y, width, height, cubeMapPixels[f], color);

            for (var _i = 0; _i < 9; _i++) {
              shCoef[_i].setToInXYZ(shCoef[_i]._m_X + color._m_X * shDir[_i] * weight, shCoef[_i]._m_Y + color._m_Y * shDir[_i] * weight, shCoef[_i]._m_Z + color._m_Z * shDir[_i] * weight);
            }

            weightAccum += weight;
          }
        }
      } // 归一化-立体角的总和应等于球体的立体角（4 PI），因此进行归一化以使我们的weightAccum精确匹配4 PI。


      for (var _i2 = 0; _i2 < 9; ++_i2) {
        shCoef[_i2].multLength(4.0 * Math.PI / weightAccum);
      }

      return shCoef;
    }
    /**
     * 从指定像素数据中读取(x,y)像素颜色值。<br/>
     * @param {Number}[x 坐标0-width]
     * @param {Number}[y 坐标0-height]
     * @param {Number}[width map宽度]
     * @param {Number}[height map高度]
     * @param {ArrayBuffer}[pixels]
     * @param {Vector4}[store]
     * @private
     */

  }, {
    key: "_getPixelColor",
    value: function _getPixelColor(x, y, width, height, pixels, store) {
      x *= 4;
      store._m_X = pixels[y * width * 4 + x];
      store._m_Y = pixels[y * width * 4 + x + 1];
      store._m_Z = pixels[y * width * 4 + x + 2];
      store._m_W = pixels[y * width * 4 + x + 3];
    }
    /**
     * 计算给定图素的球谐系数。<br/>
     * @param {Number}[texelVect]
     * @param {Number[]}[shDir]
     */

  }, {
    key: "evalShBasis",
    value: function evalShBasis(texelVect, shDir) {
      var xV = texelVect._m_X;
      var yV = texelVect._m_Y;
      var zV = texelVect._m_Z;
      var x2 = xV * xV;
      var y2 = yV * yV;
      var z2 = zV * zV;
      var sqrtPi = ProbeTools._S_SQRT_PI;
      var sqrt3Pi = ProbeTools._S_SQRT_3PI;
      var sqrt5Pi = ProbeTools._S_SQRT_5PI;
      var sqrt15Pi = ProbeTools._S_SQRT_15PI;
      shDir[0] = 1.0 / (2.0 * sqrtPi);
      shDir[1] = -(sqrt3Pi * yV) / 2.0;
      shDir[2] = sqrt3Pi * zV / 2.0;
      shDir[3] = -(sqrt3Pi * xV) / 2.0;
      shDir[4] = sqrt15Pi * xV * yV / 2.0;
      shDir[5] = -(sqrt15Pi * yV * zV) / 2.0;
      shDir[6] = sqrt5Pi * (-1.0 + 3.0 * z2) / 4.0;
      shDir[7] = -(sqrt15Pi * xV * zV) / 2.0;
      shDir[8] = sqrt15Pi * (x2 - y2) / 4.0;
    }
    /**
     * 返回立体角和向量。<br/>
     * 为给定的x，y纹理坐标和给定的立方体贴图面计算向量坐标。<br/>
     * 还计算这些坐标的立体角并返回。<br/>
     * @param {Number}[x 0-1纹理坐标]
     * @param {Number}[y 0-1纹理坐标]
     * @param {Number}[mapSize 立方体贴图大小,一般用width]
     * @param {Number}[立方体贴图的face id,这里已0-5指定]
     * @param {Vector3}[store 将存储矢量的位置。 不要为此参数提供null]
     * @param {Number}[ProbeTools._S_FIX_SEAMS_METHOD]
     * @return {Number}[给定参数的立体角]
     */

  }, {
    key: "getSAAV",
    value: function getSAAV(x, y, mapSize, face, store, fixSeamsMethod) {
      mapSize *= 1.0;
      var u = 2.0 * (x + 0.5) / mapSize - 1.0;
      var v = 2.0 * (y + 0.5) / mapSize - 1.0;

      ProbeTools._getVFCFTC(x, y, mapSize, face, store, fixSeamsMethod); // 立体角重量近似值：
      // U和V是当前面上的-1..1纹理坐标。
      // 获取此纹理像素的投影面积


      var x0, y0, x1, y1;
      var invRes = 1.0 / mapSize;
      x0 = u - invRes;
      y0 = v - invRes;
      x1 = u + invRes;
      y1 = v + invRes;
      return ProbeTools._areaElement(x0, y0) - ProbeTools._areaElement(x0, y1) - ProbeTools._areaElement(x1, y0) + ProbeTools._areaElement(x1, y1);
    }
    /**
     * 用于计算立体角。<br/>
     * @param {Number}[x 纹理坐标]
     * @param {Number}[y 纹理坐标]
     * @return {Number}
     * @private
     */

  }, {
    key: "_areaElement",
    value: function _areaElement(x, y) {
      return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
    }
    /**
     * 计算给定面和坐标的3个分量矢量坐标。<br/>
     * @param {Number}[x 0-1纹理坐标]
     * @param {Number}[y 0-1纹理坐标]
     * @param {Number}[mapSize 立方体贴图大小,一般用width]
     * @param {Number}[立方体贴图的face id,这里已0-5指定]
     * @param {Vector3}[store 将存储矢量的位置。 不要为此参数提供null]
     * @param {Number}[ProbeTools._S_FIX_SEAMS_METHOD]
     * @return [Vector3]
     */

  }, {
    key: "_getVFCFTC",
    value: function _getVFCFTC(x, y, mapSize, face, store, fixSeamsMethod) {
      var u, v;
      x *= 1.0;
      y *= 1.0;
      mapSize *= 1.0;

      if (fixSeamsMethod == ProbeTools._S_FIX_SEAMS_METHOD.Stretch) {
        // 参考Nvidia的代码:https://github.com/castano/nvidia-texture-tools/blob/master/src/nvtt/CubeSurface.cpp#L77
        u = 2.0 * x / (mapSize - 1.0) - 1.0;
        v = 2.0 * y / (mapSize - 1.0) - 1.0;
      } else {
        u = 2.0 * (x + 0.5) / mapSize - 1.0;
        v = 2.0 * (y + 0.5) / mapSize - 1.0;
      }

      if (fixSeamsMethod == ProbeTools._S_FIX_SEAMS_METHOD.Wrap) {
        // wrap纹理像素在边缘附近居中。
        var a = Math.pow(mapSize, 2.0) / Math.pow(mapSize - 1.0, 3.0);
        u = a * Math.pow(u, 3.0) + u;
        v = a * Math.pow(v, 3.0) + v;
      } // 根据face id计算向量


      switch (face) {
        case 0:
          store.setToInXYZ(1, -v, -u);
          break;

        case 1:
          store.setToInXYZ(-1, -v, u);
          break;

        case 2:
          store.setToInXYZ(u, 1, v);
          break;

        case 3:
          store.setToInXYZ(u, -1, -v);
          break;

        case 4:
          store.setToInXYZ(u, -v, 1);
          break;

        case 5:
          store.setToInXYZ(-u, -v, -1.0);
          break;
      }

      store.normal();
      return store;
    }
  }]);

  return ProbeTools;
}();

exports["default"] = ProbeTools;

_defineProperty(ProbeTools, "_S_TEMP_UNIT_X", new _Vector.default(1, 0, 0));

_defineProperty(ProbeTools, "_S_TEMP_UNIT_Y", new _Vector.default(0, 1, 0));

_defineProperty(ProbeTools, "_S_TEMP_UNIT_Z", new _Vector.default(0, 0, 1));

_defineProperty(ProbeTools, "_S_DEFAULT_CAPTURE_RESOLUTE", 256);

_defineProperty(ProbeTools, "_S_FIX_SEAMS_METHOD", {
  // wrap纹理坐标
  Wrap: 0,
  // 延伸纹理坐标
  Stretch: 1,
  // 不修复
  None: 2
});

_defineProperty(ProbeTools, "_S_SQRT_PI", Math.sqrt(Math.PI));

_defineProperty(ProbeTools, "_S_SQRT_3PI", Math.sqrt(3.0 / Math.PI));

_defineProperty(ProbeTools, "_S_SQRT_5PI", Math.sqrt(5.0 / Math.PI));

_defineProperty(ProbeTools, "_S_SQRT_15PI", Math.sqrt(15.0 / Math.PI));

_defineProperty(ProbeTools, "_S_SH_BAND_FACTOR", [1.0, 2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0]);

/***/ }),

/***/ 5489:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 队列。
 * @author Kkk
 */
var Queue = /*#__PURE__*/function () {
  function Queue() {
    _classCallCheck(this, Queue);

    this._head = [];
    this._headLength = 0;
    this._tail = [];
    this._index = 0;
    this._length = 0;
  }

  _createClass(Queue, [{
    key: "length",
    get: function get() {
      return this._length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this._index >= this._headLength) {
        var t = this._head;
        t.length = 0;
        this._head = this._tail;
        this._tail = t;
        this._index = 0;
        this._headLength = this._head.length;

        if (!this._headLength) {
          return;
        }
      }

      var value = this._head[this._index];

      if (this._index < 0) {
        delete this._head[this._index++];
      } else {
        this._head[this._index++] = undefined;
      }

      this._length--;
      return value;
    }
  }, {
    key: "push",
    value: function push(item) {
      this._length++;

      this._tail.push(item);

      return this;
    }
  }, {
    key: "unshift",
    value: function unshift(item) {
      this._head[--this._index] = item;
      this._length++;
      return this;
    }
  }]);

  return Queue;
}();

exports["default"] = Queue;

/***/ }),

/***/ 2475:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _UniformBuffer = _interopRequireDefault(__webpack_require__(1446));

var _Vector2 = _interopRequireDefault(__webpack_require__(7141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 这个类提供一系列临时变量,避免重复创建缓存。<br/>
 * @author Kkk
 * @date 2021年2月2日17点59分
 */
var TempVars = /*#__PURE__*/function () {
  // 最大缓存4个灯光,每个灯光3个数据段,每个段是一个vec4(4个float)
  // 最大缓存8个灯光,每个灯光3个数据段,每个段是一个vec4(4个float)
  // 9个球谐系数,每个系数3个float
  function TempVars() {
    _classCallCheck(this, TempVars);
  }

  _createClass(TempVars, null, [{
    key: "mallocLightData",
    value: function mallocLightData(size) {
      TempVars.S_LIGHT_DATA = new _UniformBuffer.default(size * 3 * 4);
    }
  }]);

  return TempVars;
}();

exports["default"] = TempVars;

_defineProperty(TempVars, "S_TEMP_VEC3", new _Vector.default());

_defineProperty(TempVars, "S_TEMP_VEC3_2", new _Vector.default());

_defineProperty(TempVars, "S_TEMP_VEC3_3", new _Vector.default());

_defineProperty(TempVars, "S_TEMP_VEC3_4", new _Vector.default());

_defineProperty(TempVars, "S_TEMP_VEC4", new _Vector2.default());

_defineProperty(TempVars, "S_TEMP_VEC4_2", new _Vector2.default());

_defineProperty(TempVars, "S_TEMP_VEC4_3", new _Vector2.default());

_defineProperty(TempVars, "S_TEMP_MAT4", new _Matrix.default());

_defineProperty(TempVars, "S_TEMP_MAT4_1", new _Matrix.default());

_defineProperty(TempVars, "S_TEMP_MAT4_2", new _Matrix.default());

_defineProperty(TempVars, "S_TEMP_MAT4_3", new _Matrix.default());

_defineProperty(TempVars, "S_LIGHT_DATA_4", new _UniformBuffer.default(4 * 3 * 4));

_defineProperty(TempVars, "S_LIGHT_DATA", TempVars.S_LIGHT_DATA_4);

_defineProperty(TempVars, "S_LIGHT_DATA_8", new _UniformBuffer.default(8 * 3 * 4));

_defineProperty(TempVars, "S_SH_COEFFS", new _UniformBuffer.default(9 * 3));

/***/ }),

/***/ 6552:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * TextImage。<br/>
 * 使用HTML canvas实现文本纹理。<br/>
 * @author Kkk
 * @data 2021年9月27日17点12分
 */
var TextImage = /*#__PURE__*/function () {
  function TextImage(width, height, label, pixelsize, backgroundColor) {
    _classCallCheck(this, TextImage);

    _defineProperty(this, "_m_TextureCanvas", void 0);

    _defineProperty(this, "_m_Context", void 0);

    _defineProperty(this, "_m_Pixelsize", void 0);

    _defineProperty(this, "_m_Width", void 0);

    _defineProperty(this, "_m_Height", void 0);

    _defineProperty(this, "_m_BackgroundColor", '#a0d7ff');

    _defineProperty(this, "_m_TextColor", "black");

    _defineProperty(this, "_m_AlignLeftOffset", 0.5);

    _defineProperty(this, "_m_AlignTopOffset", 0.7);

    _defineProperty(this, "_m_CurLabel", null);

    this._m_Pixelsize = pixelsize || 60;
    this._m_BackgroundColor = backgroundColor || this._m_BackgroundColor;
    this._m_Width = width;
    this._m_Height = height;
    this._m_TextureCanvas = document.createElement('canvas');
    this._m_TextureCanvas.width = width;
    this._m_TextureCanvas.height = height;
    this._m_TextureCanvas.style.width = width + "px";
    this._m_TextureCanvas.style.height = height + "px";
    this._m_TextureCanvas.style.padding = "0";
    this._m_TextureCanvas.style.margin = "0";
    this._m_TextureCanvas.style.top = "0";
    this._m_TextureCanvas.style.background = this._m_BackgroundColor;
    this._m_TextureCanvas.style.position = "absolute";
    this._m_TextureCanvas.style.opacity = "1.0";
    this._m_TextureCanvas.style.visibility = "hidden";
    this._m_TextureCanvas.style["z-index"] = 1;
    var body = document.getElementsByTagName("body")[0];
    body.appendChild(this._m_TextureCanvas);
    this._m_Context = this._m_TextureCanvas.getContext("2d");

    this._m_Context.translate(this._m_Width, this._m_Height);

    this._m_Context.scale(-1, -1);

    this.setText(label);
  }
  /**
   * 返回图像。<br/>
   * @return {ImageData}
   */


  _createClass(TextImage, [{
    key: "getImage",
    value: function getImage() {
      return this._m_TextureCanvas;
    }
    /**
     * 设置文本字体像素大小。<br/>
     * @param {Number}[pixelsize 默认60px]
     */

  }, {
    key: "setPixelSize",
    value: function setPixelSize(pixelsize) {
      this._m_Pixelsize = pixelsize;
      this.setText(this._m_CurLabel);
    }
    /**
     * 设置背景颜色，默认为#a0d7ff。<br/>
     * @param {Object}[backgroundColor 可以为十六位颜色表示法，也可以为颜色符号]
     */

  }, {
    key: "setBackgroundColor",
    value: function setBackgroundColor(backgroundColor) {
      this._m_BackgroundColor = backgroundColor;
      this.setText(this._m_CurLabel);
    }
    /**
     * 设置文本。<br/>
     * @param {String}[text]
     */

  }, {
    key: "setText",
    value: function setText(text) {
      this._m_CurLabel = text;
      this._m_Context.fillStyle = this._m_BackgroundColor;
      var xmin = 0,
          ymin = 0;

      this._m_Context.fillRect(xmin, ymin, this._m_Width, this._m_Height);

      this._m_Context.fillStyle = this._m_TextColor;
      this._m_Context.font = this._m_Pixelsize + 'px sans-serif';
      this._m_Context.textAlign = "center";
      var xcenter = xmin + this._m_Width * this._m_AlignLeftOffset;
      var ycenter = ymin + this._m_Height * this._m_AlignTopOffset;

      this._m_Context.fillText(text, xcenter, ycenter, this._m_Width);
    }
    /**
     * 设置文本颜色，默认为black。<br/>
     * @param {Object}[textColor 可以是十六位颜色表示法，也可以是颜色符号]
     */

  }, {
    key: "setTextColor",
    value: function setTextColor(textColor) {
      this._m_TextColor = textColor;
      this.setText(this._m_CurLabel);
    }
    /**
     * 设置文字对齐偏移，默认下leftOffset为0.5，topOffset为0.7，意味着文本绘制在水平中心，垂直百分之三十位置。<br/>
     * @param {Number}[leftOffset 0.0-1.0]
     * @param {Number}[topOffset 0.0-1.0]
     */

  }, {
    key: "setAlign",
    value: function setAlign(leftOffset, topOffset) {
      this._m_AlignLeftOffset = leftOffset;
      this._m_AlignTopOffset = topOffset;
      this.setText(this._m_CurLabel);
    }
  }]);

  return TextImage;
}();

exports["default"] = TextImage;

/***/ }),

/***/ 5397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _BoundingVolume = _interopRequireDefault(__webpack_require__(1322));

var _Vector = _interopRequireDefault(__webpack_require__(5604));

var _Vector2 = _interopRequireDefault(__webpack_require__(9271));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var o = {};

o.lz = function (i, c) {
  if (typeof c != 'number' || c <= 0 || typeof i != 'number' && typeof i != 'string') {
    return i;
  }

  i += '';

  while (i.length < c) {
    i = '0' + i;
  }

  return i;
};

o.getHashCode = function (s) {
  var hash = 0,
      c = typeof s == 'string' ? s.length : 0,
      i = 0;

  while (i < c) {
    hash = (hash << 5) - hash + s.charCodeAt(i++); //hash = hash & hash; // Convert to 32bit integer
  }

  return hash < 0 ? hash * -1 + 0xFFFFFFFF : hash; // convert to unsigned
};

o.uniqueId = function (s, bres) {
  if (s == undefined || typeof s != 'string') {
    if (!o.___uqidc) {
      o.___uqidc = 0;
    } else {
      ++o.___uqidc;
    }

    var od = new Date(),
        i = s = od.getTime() + '' + o.___uqidc;
  } else {
    var i = o.getHashCode(s);
  }

  return (bres ? 'res:' : '') + i.toString(32) + '-' + o.lz((s.length * 4).toString(16), 3);
};

var BS = [[0, 1, 0], [1, 0, 0], [0, 0, 1]];
/**
 * 提供一些常见工具函数。<br/>
 * @author Kkk
 * @date 2021年2月5日16点48分
 */

var Tools = /*#__PURE__*/function () {
  function Tools() {
    _classCallCheck(this, Tools);
  }

  _createClass(Tools, null, [{
    key: "isPowerOfTwo",
    value: function isPowerOfTwo(x) {
      return (x & x - 1) === 0;
    }
  }, {
    key: "nextHighestPowerOfTwo",
    value: function nextHighestPowerOfTwo(x) {
      --x;

      for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
      }

      return x + 1;
    }
    /**
     * 确保图像为2的幂次方。<br/>
     * 在旧的gles规范中，仅支持2的幂次方纹理图像。<br/>
     * @param {ImageData}[image]
     * @return {ImageData}
     */

  }, {
    key: "ensureImageSizePowerOfTwo",
    value: function ensureImageSizePowerOfTwo(image, canvas) {
      if (!Tools.isPowerOfTwo(image.width) || !Tools.isPowerOfTwo(image.height)) {
        canvas.width = Tools.nextHighestPowerOfTwo(image.width);
        canvas.height = Tools.nextHighestPowerOfTwo(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        image = canvas;
      }

      return image;
    }
    /**
     * 检查o是否为有效对象。<br/>
     * @param {Object}[o]
     * @return {Boolean}
     */

  }, {
    key: "checkIsNull",
    value: function checkIsNull(o) {
      return o != null && o != undefined;
    }
    /**
     * 返回系统默认分配的唯一ID。<br/>
     * 以负数+'R3D'编码一个ID返回。<br/>
     * @return {Number}
     */

  }, {
    key: "nextId",
    value: function nextId() {
      return Tools.uniqueId(--Tools._s_Id + 'R3D');
    }
    /**
     * 插入一行到指定源中的指定位置。<br/>
     * @param {String}[source 源]
     * @param {String}[line 行]
     * @param {Number}[index 从0开始,指定插入到源的第几行]
     * @return {String}
     */

  }, {
    key: "insertLine",
    value: function insertLine(source, line, index) {
      source = Tools.trim(source);
      var sourceArr = source.split("\n");
      var result = '';

      for (var i = 0; i < sourceArr.length; i++) {
        if (i == index) {
          result += line + '\n';
        }

        result += sourceArr[i] + '\n';
      }

      return result;
    }
    /**
     * 返回string对应的唯一id。<br/>
     * @param {String}[s]
     * @return {Number}
     */

  }, {
    key: "uniqueId",
    value: function uniqueId(s) {
      return o.uniqueId(s);
    }
    /**
     * 返回目标匹配符。<br/>
     * @param {String}[str 源]
     * @returns {TagPattern}
     */

  }, {
    key: "getTagPattern",
    value: function getTagPattern(str) {
      return eval("/" + str + "/g");
    }
    /**
     * 返回匹配符。<br/>
     * @param {String}[str 源]
     * @returns {Pattern}
     */

  }, {
    key: "getPattern",
    value: function getPattern(str) {
      return eval("/" + str + "/");
    }
    /**
     * 去掉字符串前后空格字符。<br/>
     * @param {String}[str 源]
     * @returns {void | string | *}
     */

  }, {
    key: "trim",
    value: function trim(str) {
      return str.replace(/(^\s*)|(\s*$)/g, "");
    }
    /**
     * 查找str中是否包含指定模板字符串。<br/>
     * @param {String}[str 源]
     * @param {Pattern}[pattern 匹配正则表达式]
     * @return {boolean}
     */

  }, {
    key: "find",
    value: function find(str, pattern) {
      return str.search(pattern) != -1;
    }
  }, {
    key: "find2",
    value: function find2(str, pattern) {
      return str.search(pattern);
    }
    /**
     * 将指定字符串中所有符号匹配字符串替换为指定字符串
     * @param {String}[str 源]
     * @param {Pattern}[pattern 匹配正则表达式]
     * @param {Pattern}[tagPattern 替换正则表达式]
     * @param {String}[tag 替换的字符串内容]
     * @returns {String}
     */

  }, {
    key: "repSrc",
    value: function repSrc(str, pattern, tagPattern, tag) {
      if (str.search(pattern) != -1) {
        return str.replace(tagPattern, tag);
      }

      return str;
    }
    /**
     * 近似计算BoundingVolume在指定视口中的面积。<br/>
     * @param {BoundingVolume}[bound]
     * @param {Number}[distance 距离cam的距离]
     * @param {Number}[viewPortWidth 视口宽度]
     * @return {Number}[返回该bound在视口中的近似像素面积]
     */

  }, {
    key: "approxScreenArea",
    value: function approxScreenArea(bound, distance, viewPortWidth) {
      if (bound.getType() == _BoundingVolume.default.S_TYPE_AABB) {
        var r = bound.getXHalf() * bound.getXHalf() + bound.getYHalf() * bound.getYHalf() + bound.getZHalf() * bound.getZHalf();
        return r * viewPortWidth * viewPortWidth / (distance * distance * 4) * Math.PI;
      } else if (bound.getType() == _BoundingVolume.default.S_TYPE_SPHERE) {}

      return 0;
    }
    /**
     * 使用给定的positions和uvs计算切线数据。<br/>
     * @param {Number[]}[indices]
     * @param {Number[]}[positions]
     * @param {Number[]}[uvs]
     * @param {Number[]}[normals]
     * @return {Float32Array}
     */

  }, {
    key: "generatorTangents2",
    value: function generatorTangents2(indices, positions, uvs, normals) {
      // 每个顶点的切线数据
      var nVertices = positions.length / 3;
      var tangents = new Float32Array(4 * nVertices);
      var tan1 = [],
          tan2 = [];

      for (var i = 0; i < nVertices; i++) {
        tan1[i] = new _Vector.default();
        tan2[i] = new _Vector.default();
      }

      var vA = new _Vector.default(),
          vB = new _Vector.default(),
          vC = new _Vector.default(),
          uvA = new _Vector2.default(),
          uvB = new _Vector2.default(),
          uvC = new _Vector2.default(),
          sdir = new _Vector.default(),
          tdir = new _Vector.default();

      var handleTriangle = function handleTriangle(a, b, c) {
        vA.setToInXYZ(positions[a * 3], positions[a * 3 + 1], positions[a * 3 + 2]);
        vB.setToInXYZ(positions[b * 3], positions[b * 3 + 1], positions[b * 3 + 2]);
        vC.setToInXYZ(positions[c * 3], positions[c * 3 + 1], positions[c * 3 + 2]);
        uvA.setToInXY(uvs[a * 2], uvs[a * 2 + 1]);
        uvB.setToInXY(uvs[b * 2], uvs[b * 2 + 1]);
        uvC.setToInXY(uvs[c * 2], uvs[c * 2 + 1]);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        var r = 1.0 / (uvB._m_X * uvC._m_Y - uvC._m_X * uvB._m_Y); // 忽略具有重合或共线顶点的uv三角形

        if (!isFinite(r)) return;
        sdir.setTo(vB);
        sdir.multLength(uvC._m_Y);
        sdir.addInXYZ(vC._m_X * -uvB._m_Y, vC._m_Y * -uvB._m_Y, vC._m_Z * -uvB._m_Y);
        sdir.multLength(r);
        tdir.setTo(vC);
        tdir.multLength(uvB._m_X);
        tdir.addInXYZ(vB._m_X * -uvC._m_X, vB._m_Y * -uvC._m_X, vB._m_Z * -uvC._m_X);
        tdir.multLength(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      };

      for (var _i = 0; _i < indices.length; _i += 3) {
        handleTriangle(indices[_i + 0], indices[_i + 1], indices[_i + 2]);
      }

      var tmp = new _Vector.default(),
          tmp2 = new _Vector.default();
      var n = new _Vector.default(),
          n2 = new _Vector.default();
      var w, t, test;

      var handleVertex = function handleVertex(v) {
        n.setToInXYZ(normals[v * 3], normals[v * 3 + 1], normals[v * 3 + 2]);
        n2.setTo(n);
        t = tan1[v]; // 格拉姆-施密特正交化

        tmp.setTo(t);
        tmp.sub(n.multLength(n.dot(t))).normal(); // 计算up

        n2.cross(t, tmp2);
        test = tmp2.dot(tan2[v]);
        w = test < 0.0 ? -1.0 : 1.0;
        tangents[v * 4] = tmp._m_X;
        tangents[v * 4 + 1] = tmp._m_Y;
        tangents[v * 4 + 2] = tmp._m_Z;
        tangents[v * 4 + 3] = w;
      };

      for (var _i2 = 0; _i2 < indices.length; _i2 += 3) {
        handleVertex(indices[_i2 + 0]);
        handleVertex(indices[_i2 + 1]);
        handleVertex(indices[_i2 + 2]);
      }

      return tangents;
    }
    /**
     * 返回与positions内存对齐的切线数据。<br/>
     * @param {Number[]}[positions]
     * @return {Number[]}[tangents]
     */

  }, {
    key: "generatorFillTangents2",
    value: function generatorFillTangents2(positions) {
      var nVertices = positions.length / 3;
      var l = 4 * nVertices;
      var tangents = [];

      for (var i = 0; i < l; i++) {
        tangents[i] = 0.0;
      }

      return tangents;
    }
    /**
     * 返回与positions内存对齐的切线数据。<br/>
     * @param {Number[]}[positions]
     * @return {Number[]}[tangents]
     */

  }, {
    key: "generatorFillTangents",
    value: function generatorFillTangents(positions) {
      var tangents = [];

      for (var i = 0; i < positions.length; i++) {
        tangents[i] = positions[i];
      }

      return tangents;
    }
    /**
     * 使用给定的positions和uvs计算切线数据。<br/>
     * @param {Number[]}[indices]
     * @param {Number[]}[positions]
     * @param {Number}[uvs]
     * @return {Number[]}[tangents]
     */

  }, {
    key: "generatorTangents",
    value: function generatorTangents(indices, positions, uvs) {
      // 计算公式
      // E1 = dietaryU1 * T + dietaryV1 * B;
      // E2 = dietaryU2 * T + dietaryV2 * B;
      // 可以联立方程计算T,B;但常规做法使用矩阵乘法求解
      // 如下:
      // [E1x, E1y, E1z,   =   [U1, V1,    *   [Tx, Ty, Tz,
      //  E2x, E2y, E2z]        U2, V2]         Bx, By, Bz]
      // 可得:
      // [Tx, Ty, Tz,      =   [U1, V1,^-1 *   [E1x, E1y, E1z,
      //  Bx, By, Bz]           U2, V2]         E2x, E2y, E2z]
      var e1 = new _Vector.default();
      var e2 = new _Vector.default();
      var dUV = new Array(4).fill(0);
      var ti = 0;
      var tx = 0,
          ty = 0,
          tz = 0;
      var tangents = [];
      var tangentMaps = {};
      var p0 = new _Vector.default();
      var p1 = new _Vector.default();
      var p2 = new _Vector.default();
      var uv0 = new _Vector2.default();
      var uv1 = new _Vector2.default();
      var uv2 = new _Vector2.default();
      var uv = new _Vector2.default();
      var du1 = 0,
          dv1 = 0,
          du2 = 0,
          dv2 = 0;

      for (var i = 0; i < indices.length; i += 3) {
        p0.setToInXYZ(positions[indices[i] * 3], positions[indices[i] * 3 + 1], positions[indices[i] * 3 + 2]);
        p1.setToInXYZ(positions[indices[i + 1] * 3], positions[indices[i + 1] * 3 + 1], positions[indices[i + 1] * 3 + 2]);
        p2.setToInXYZ(positions[indices[i + 2] * 3], positions[indices[i + 2] * 3 + 1], positions[indices[i + 2] * 3 + 2]);
        uv0.setToInXY(uvs[indices[i] * 2], uvs[indices[i] * 2 + 1]);
        uv1.setToInXY(uvs[indices[i + 1] * 2], uvs[indices[i + 1] * 2 + 1]);
        uv2.setToInXY(uvs[indices[i + 2] * 2], uvs[indices[i + 2] * 2 + 1]);
        p1.sub(p0, e1);
        p2.sub(p0, e2);
        uv1.sub(uv0, uv);
        du1 = uv._m_X;
        dv1 = uv._m_Y;
        uv2.sub(uv0, uv);
        du2 = uv._m_X;
        dv2 = uv._m_Y;

        Tools._generatorDietaryUVMat(du1, dv1, du2, dv2, dUV); // 计算加权切线数据


        tx = dUV[0] * e1._m_X + dUV[1] * e2._m_X;
        ty = dUV[0] * e1._m_Y + dUV[1] * e2._m_Y;
        tz = dUV[0] * e1._m_Z + dUV[1] * e2._m_Z;
        var l = tx * tx + ty * ty + tz * tz;
        l = 1.0 / Math.sqrt(l);
        tx *= l;
        ty *= l;
        tz *= l;

        Tools._generatorWeightedTangent(indices[i], indices[i + 1], indices[i + 2], tx, ty, tz, tangentMaps);
      }

      Tools._normalizedTangents(tangentMaps); // 计算加权顶点切线数据


      for (var _i3 in tangentMaps) {
        tangents[ti++] = tangentMaps[_i3][0];
        tangents[ti++] = tangentMaps[_i3][1];
        tangents[ti++] = tangentMaps[_i3][2];
      } // Log.log('tangents:\n',tangents);


      return tangents;
    }
    /**
     * 归一化切线数据。<br/>
     * @param {Map}[tangentMaps]
     * @private
     */

  }, {
    key: "_normalizedTangents",
    value: function _normalizedTangents(tangentMaps) {
      var temp = [];
      var l = 0;

      for (var i in tangentMaps) {
        temp[0] = tangentMaps[i][0];
        temp[1] = tangentMaps[i][1];
        temp[2] = tangentMaps[i][2];
        l = temp[0] * temp[0] + temp[1] * temp[1] + temp[2] * temp[2];

        if (l > 0) {
          l = Math.sqrt(1.0 * l);
          temp[0] /= l;
          temp[1] /= l;
          temp[2] /= l;
        } else {
          temp[0] = temp[1] = temp[2] = 0;
        }

        tangentMaps[i][0] = temp[0];
        tangentMaps[i][1] = temp[1];
        tangentMaps[i][2] = temp[2];
      }
    }
    /**
     * 计算加权切线数据。<br/>
     * @param {Number}[p0 顶点]
     * @param {Number}[p1 顶点]
     * @param {Number}[p2 顶点]
     * @param {Number}[tx 切线x]
     * @param {Number}[ty 切线y]
     * @param {Number}[tz 切线z]
     * @param {Map}[tangentMaps]
     * @private
     */

  }, {
    key: "_generatorWeightedTangent",
    value: function _generatorWeightedTangent(p0, p1, p2, tx, ty, tz, tangentMaps) {
      if (!Tools.checkIsNull(tangentMaps[p0])) {
        tangentMaps[p0] = [tx, ty, tz];
      } else {
        tangentMaps[p0] = [(tx + tangentMaps[p0][0]) * 0.5, (ty + tangentMaps[p0][1]) * 0.5, (tz + tangentMaps[p0][2]) * 0.5];
      }

      if (!Tools.checkIsNull(tangentMaps[p1])) {
        tangentMaps[p1] = [tx, ty, tz];
      } else {
        tangentMaps[p1] = [(tx + tangentMaps[p1][0]) * 0.5, (ty + tangentMaps[p1][1]) * 0.5, (tz + tangentMaps[p1][2]) * 0.5];
      }

      if (!Tools.checkIsNull(tangentMaps[p2])) {
        tangentMaps[p2] = [tx, ty, tz];
      } else {
        tangentMaps[p2] = [(tx + tangentMaps[p2][0]) * 0.5, (ty + tangentMaps[p2][1]) * 0.5, (tz + tangentMaps[p2][2]) * 0.5];
      }
    }
    /**
     * 构建uv矩阵。<br/>
     * @param {Number}[du1]
     * @param {Number}[dv1]
     * @param {Number}[du2]
     * @param {Number}[dv2]
     * @param {Number[]}[result]
     * @return {Number[]}
     * @private
     */

  }, {
    key: "_generatorDietaryUVMat",
    value: function _generatorDietaryUVMat(du1, dv1, du2, dv2, result) {
      var t = 1.0 / (du1 * dv2 - du2 * dv1);
      result[0] = dv2 * t;
      result[1] = -dv1 * t;
      result[2] = -du2 * t;
      result[3] = du1 * t;
      return result;
    }
    /**
     * 根据positions属性与indices数组创建重心坐标属性数据。<br/>
     * @param {Number[]}[positions]
     * @param {Number[]}[indices]
     * @return {Number[]}
     */

  }, {
    key: "generatorBaryCentrics",
    value: function generatorBaryCentrics(positions, indices) {
      var barycentricMaps = {};
      var a, b, c;
      var calc = [];
      var result = null;
      var t = 0;

      for (var i = 0; i < indices.length; i += 3) {
        calc.length = 0;
        a = indices[i];
        b = indices[i + 1];
        c = indices[i + 2];

        if (barycentricMaps[a]) {
          calc.push(barycentricMaps[a]);
        }

        if (barycentricMaps[b]) {
          calc.push(barycentricMaps[b]);
        }

        if (barycentricMaps[c]) {
          calc.push(barycentricMaps[c]);
        }

        result = Tools._nextBarycentrics(calc);

        if (result) {
          t = 0;

          if (!barycentricMaps[a]) {
            barycentricMaps[a] = result[t++];
          }

          if (!barycentricMaps[b]) {
            barycentricMaps[b] = result[t++];
          }

          if (!barycentricMaps[c]) {
            barycentricMaps[c] = result[t++];
          }
        }
      } // 这里，positions属性的长度不一定与barcentricMaps长度一致（但是，正常情况下，positions属性与barcentricMaps数据长度一致）
      // 原因是存在可能未被indices使用的position,所以这里以positions长度为数据填充


      var bs = new Array(positions.length).fill(0);

      for (var _i4 in barycentricMaps) {
        bs[_i4 * 3] = barycentricMaps[_i4][0];
        bs[_i4 * 3 + 1] = barycentricMaps[_i4][1];
        bs[_i4 * 3 + 2] = barycentricMaps[_i4][2];
      }

      return bs;
    }
    /**
     * 计算合适的重心坐标。<br/>
     * @param {Number[]}[calc]
     * @return {Number[]}
     * @private
     */

  }, {
    key: "_nextBarycentrics",
    value: function _nextBarycentrics(calc) {
      if (calc.length == 3) {
        // 检测三个重心坐标是否有重
        // 因为存在金字塔索引绘制的情况，所以会存在相冲重心坐标
        // 一旦相冲，就使用第4个重心坐标（D(0,0,0)）替换其中一个
        if (calc[0][0] == calc[1][0] && calc[0][1] == calc[1][1] && calc[0][2] == calc[1][2]) {
          calc[0] = [0, 0, 0];
        } else if (calc[1][0] == calc[2][0] && calc[1][1] == calc[2][1] && calc[1][2] == calc[2][2]) {
          calc[1] = [0, 0, 0];
        } else if (calc[2][0] == calc[0][0] && calc[2][1] == calc[0][1] && calc[2][2] == calc[0][2]) {
          calc[2] = [0, 0, 0];
        }

        return null;
      } else if (calc.length == 0) {
        // 返回三个重心坐标
        return [[0, 1, 0], [1, 0, 0], [0, 0, 1]];
      } else {
        // 计算余下重心坐标
        var c = [true, true, true];
        var result = [];

        if (calc.length == 2) {
          // 检测是否相冲
          if (calc[0][0] == calc[1][0] && calc[0][1] == calc[1][1] && calc[0][2] == calc[1][2]) {
            calc[0] = [0, 0, 0];
          } else if (calc[1][0] == calc[2][0] && calc[1][1] == calc[2][1] && calc[1][2] == calc[2][2]) {
            calc[1] = [0, 0, 0];
          }
        }

        calc.forEach(function (cc) {
          if (cc[0] == calc[1][0] && cc[1] == calc[1][1] && cc[2] == calc[1][2]) {
            c[1] = false;
          } else if (cc[0] == calc[2][0] && cc[1] == calc[2][1] && cc[2] == calc[2][2]) {
            c[2] = false;
          } else if (cc[0] == calc[0][0] && cc[1] == calc[0][1] && cc[2] == calc[0][2]) {
            c[0] = false;
          }
        });

        for (var i = 0; i < 3; i++) {
          if (c[i]) {
            result.push(BS[i]);
          }
        }

        return result;
      }
    }
  }]);

  return Tools;
}();

exports["default"] = Tools;

_defineProperty(Tools, "_s_Id", 0);

/***/ }),

/***/ 6693:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 包装gl arrayBuf的创建，使用。<br/>
 * @author Kkk
 */
var ArrayBuf = /*#__PURE__*/function () {
  function ArrayBuf() {
    _classCallCheck(this, ArrayBuf);
  }

  _createClass(ArrayBuf, null, [{
    key: "setBufLocal",
    value:
    /**
     * 设置buf属性位置
     * @param gl
     * @param buf
     * @param arrayBufType
     * @param localtion
     * @param arrayBufWidth
     * @param arrayBufValueType
     * @param arrayBufLength
     * @param arrayBufOffset
     */
    function setBufLocal(gl, buf, arrayBufType, localtion, arrayBufWidth, arrayBufValueType, arrayBufLength, arrayBufOffset) {
      gl.bindBuffer(arrayBufType, buf);
      gl.vertexAttribPointer(localtion, arrayBufWidth, arrayBufValueType, false, arrayBufLength, arrayBufOffset);
      gl.enableVertexAttribArray(localtion);
      gl.bindBuffer(arrayBufType, null);
    }
    /**
     * 设置属性列表buf
     * @param gl
     * @param arrayBufType
     * @param arrayBufData
     * @param arrayBufUsage
     * @param localtion
     * @param arrayBufWidth
     * @param arrayBufValueType
     * @param arrayBufStride
     * @param arrayBufOffset
     */

  }, {
    key: "setVertexBuf",
    value: function setVertexBuf(gl, vao, arrayBufType, arrayBufData, arrayBufUsage, localtion, arrayBufWidth, arrayBufValueType, arrayBufStride, arrayBufOffset) {
      gl.bindVertexArray(vao);
      var buf = gl.createBuffer();
      gl.bindBuffer(arrayBufType, buf);
      gl.bufferData(arrayBufType, arrayBufData, arrayBufUsage);
      gl.vertexAttribPointer(localtion, arrayBufWidth, arrayBufValueType, false, arrayBufStride, arrayBufOffset);
      gl.enableVertexAttribArray(localtion);
      gl.bindBuffer(arrayBufType, null);
      gl.bindVertexArray(null);
      return buf;
    }
    /**
     * 设置索引属性列表buf
     * @param gl
     * @param vao
     * @param arrayBufType
     * @param arrayBufData
     * @param arrayBufUsage
     */

  }, {
    key: "setIndicesBuf",
    value: function setIndicesBuf(gl, vao, arrayBufType, arrayBufData, arrayBufUsage) {
      gl.bindVertexArray(vao);
      var buf = gl.createBuffer();
      gl.bindBuffer(arrayBufType, buf);
      gl.bufferData(arrayBufType, arrayBufData, arrayBufUsage);
      gl.bindVertexArray(null);
      gl.bindBuffer(arrayBufType, null);
      return buf;
    }
  }]);

  return ArrayBuf;
}();

exports["default"] = ArrayBuf;

/***/ }),

/***/ 7902:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Buffer = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 对RenderBuffer的封制。<br/>
 * @author Kkk
 * @date 2021年2月12日15点49分
 */
var Buffer = /*#__PURE__*/function () {
  function Buffer(name, loc, w, h, format) {
    _classCallCheck(this, Buffer);

    this._m_Name = name;
    this._m_Loc = loc || null;
    this._m_Width = w || 0;
    this._m_Height = h || 0;
    this._m_Format = format;
  }

  _createClass(Buffer, [{
    key: "setName",
    value: function setName(name) {
      this._m_Name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
  }, {
    key: "setLoc",
    value: function setLoc(loc) {
      this._m_Loc = loc;
    }
  }, {
    key: "getLoc",
    value: function getLoc() {
      return this._m_Loc;
    }
  }, {
    key: "setWidth",
    value: function setWidth(w) {
      this._m_Width = w;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this._m_Width;
    }
  }, {
    key: "setHeight",
    value: function setHeight(h) {
      this._m_Height = h;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this._m_Height;
    }
  }, {
    key: "setFormat",
    value: function setFormat(format) {
      this._m_Format = format;
    }
  }, {
    key: "getFormat",
    value: function getFormat() {
      return this._m_Format;
    }
  }]);

  return Buffer;
}();

exports.Buffer = Buffer;

/***/ }),

/***/ 7341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Buffer = __webpack_require__(7902);

var _Texture = _interopRequireDefault(__webpack_require__(2584));

var _Picture = _interopRequireDefault(__webpack_require__(7280));

var _FramePicture = _interopRequireDefault(__webpack_require__(5776));

var _Log = _interopRequireDefault(__webpack_require__(3846));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * FrameBuffer。<br/>
 * @author Kkk
 * @date 2021年2月28日5点28分
 */
var FrameBuffer = /*#__PURE__*/function () {
  function FrameBuffer(gl, name, w, h) {
    _classCallCheck(this, FrameBuffer);

    this._m_Name = name;
    this._m_Framebuffer = gl.createFramebuffer(); // texture列表

    this._m_Textures = []; // textureName:texture

    this._m_NameTextures = {}; // key:attachId,value:texture

    this._m_MapTextures = {}; // buffer列表

    this._m_Buffers = []; // key:attachId,value:buffer

    this._m_MapBuffers = {}; // 所有启用的drawBuffer

    this._m_DrawBuffers = [];
    this._m_Width = w;
    this._m_Height = h; // frameBuffer元素信息

    this._m_RData = {}; // 当前帧图像输出

    this._m_FramePicture = null; // 固定尺寸

    this._m_FixedSize = false;
  }
  /**
   * 设置是否为固定尺寸。<br/>
   * @param {Boolean}[fixedSize]
   */


  _createClass(FrameBuffer, [{
    key: "setFixedSize",
    value: function setFixedSize(fixedSize) {
      this._m_FixedSize = fixedSize;
    }
    /**
     * 是否为固定尺寸的FrameBuffer。<br/>
     * @return {Boolean}
     */

  }, {
    key: "isFixedSize",
    value: function isFixedSize() {
      return this._m_FixedSize;
    }
    /**
     * 读取指定frameBuffer的像素数据。<br/>
     * @param {WebGL}[gl]
     * @param {String}[name 读取缓存名称]
     * @param {WebGLEnum}[format]
     * @param {WebGLEnum}[type]
     * @param {Number}[x 开始偏移量]
     * @param {Number}[y 开始偏移量]
     * @param {Number}[w 读取宽度]
     * @param {Number}[h 读取高度]
     */

  }, {
    key: "readPixels",
    value: function readPixels(gl, name, format, type, x, y, w, h) {
      x = x || 0;
      y = y || 0;
      w = w || this._m_Width;
      h = h || this._m_Height;
      var pixelUnit = -1;
      var pixelType = null; // 根据类型读取转换

      switch (format) {
        case gl.RGBA16F:
          pixelType = Float32Array;
          pixelUnit = 4;
          break;

        case gl.RGBA8:
        case gl.RGBA:
          pixelType = type != gl.FLOAT ? Uint8Array : Float32Array;
          pixelUnit = 4;
          break;

        case gl.RGB16F:
          pixelType = Float32Array;
          pixelUnit = 3;
          break;

        case gl.RGB8:
        case gl.RGB:
          pixelType = type != gl.FLOAT ? Uint8Array : Float32Array;
          pixelUnit = 3;
          break;
      }

      var _format = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);

      var _type = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);

      var pixels = new pixelType(w * h * pixelUnit);
      gl.readPixels(x, y, w, h, format, type, pixels);
      return pixels;
    }
    /**
     * 返回当前FramePicture。<br/>
     * @return {Picture}
     */

  }, {
    key: "getFramePicture",
    value: function getFramePicture() {
      return this._m_FramePicture;
    }
    /**
     * 返回当前帧缓冲区。<br/>
     * @return {WebGLFramebuffer | *}
     */

  }, {
    key: "getFrameBuffer",
    value: function getFrameBuffer() {
      return this._m_Framebuffer;
    }
    /**
     * 使用该FrameBuffer。<br/>
     * @param {Render}[render]
     */

  }, {
    key: "use",
    value: function use(render) {
      var frameContext = render.getFrameContext();

      if (frameContext.m_LastFrameBuffer != this._m_Framebuffer) {
        var gl = render._m_Scene.getCanvas().getGLContext();

        gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_Framebuffer);
        frameContext.m_LastFrameBuffer = this._m_Framebuffer;
      }
    }
    /**
     * 清楚frameBuffer。<br/>
     * @param gl
     * @private
     */

  }, {
    key: "clear",
    value: function clear(gl) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    /**
     * 附加一个缓存区。<br/>
     * @param {GLContext}[gl]
     * @param {String}[name]
     * @param {GLenum}[format]
     * @param {GLenum}[* @param {GLenum}[format]]
     */

  }, {
    key: "addBuffer",
    value: function addBuffer(gl, name, format, attachId) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_Framebuffer);
      var loc = null;
      loc = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, loc);
      var buffer = new _Buffer.Buffer(name, loc, this._m_Width, this._m_Height, format);
      gl.renderbufferStorage(gl.RENDERBUFFER, format, this._m_Width, this._m_Height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachId, gl.RENDERBUFFER, loc);
      this._m_MapBuffers[attachId] = buffer;

      this._m_Buffers.push(buffer);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);

      this._rData('buffer', {
        name: name,
        format: format,
        attachId: attachId
      });
    }
    /**
     * FrameBuffer元素信息。<br/>
     * @param {String}[type]
     * @param {Object}[cfg]
     * @private
     */

  }, {
    key: "_rData",
    value: function _rData(type, cfg) {
      if (!this._m_RData[type]) {
        this._m_RData[type] = {
          keys: {},
          values: []
        };
      }

      if (!this._m_RData[type].keys[cfg.name]) {
        this._m_RData[type].keys[cfg.name] = true;

        this._m_RData[type].values.push(cfg);
      }
    }
    /**
     * 返回所有缓存区。<br/>
     * @return {Buffer[]}
     */

  }, {
    key: "getBuffers",
    value: function getBuffers() {
      return this._m_Buffers;
    }
    /**
     * 设置渲染使用的mipmap。<br/>
     * 作废，webGL不支持。<br/>
     * @param {WebGL}[gl]
     * @param {String}[name]
     * @param {WebGLEnum}[attachId]
     * @param {Number}[mipmapLevel]
     */

  }, {
    key: "setMipMap",
    value: function setMipMap(gl, name, attachId, mipmapLevel) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachId, gl.TEXTURE_2D, this._m_NameTextures[name].getLoc(), mipmapLevel);
    }
    /**
     * 添加一个纹理缓冲。<br/>
     * @param {GLContext}[gl]
     * @param {String}[name]
     * @param {GLenum}[internalformat]
     * @param {GLenum}[border]
     * @param {GLenum}[format]
     * @param {GLenum}[type]
     * @param {GLenum}[attachId]
     * @param {Boolean}[toDrawBuffer true表示启用该颜色输出缓存]
     */

  }, {
    key: "addTexture",
    value: function addTexture(gl, name, internalformat, border, format, type, attachId, toDrawBuffer, genMipmap) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_Framebuffer);
      var loc = gl.createTexture();
      var texture = new _Texture.default(name, loc, internalformat, this._m_Width, this._m_Height, border, format, type, null);
      gl.bindTexture(gl.TEXTURE_2D, loc);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalformat, this._m_Width, this._m_Height, 0, format, type, null);

      if (genMipmap) {
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      }

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachId, gl.TEXTURE_2D, loc, 0);
      this._m_MapTextures[attachId] = texture;

      this._m_Textures.push(texture);

      this._m_NameTextures[name] = texture;

      if (toDrawBuffer) {
        this._m_DrawBuffers.push(attachId);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, null);

      this._rData('texture', {
        name: name,
        internalformat: internalformat,
        border: border,
        format: format,
        type: type,
        attachId: attachId,
        toDrawBuffer: toDrawBuffer,
        genMipmap: genMipmap
      });
    }
    /**
     * 返回所有纹理附件。<br/>
     * @return {Texture[]}
     */

  }, {
    key: "getTextures",
    value: function getTextures() {
      return this._m_Textures;
    }
    /**
     * 返回指定名称的纹理附件。<br/>
     * @param {String}[name]
     * @return {Texture}
     */

  }, {
    key: "getTexture",
    value: function getTexture(name) {
      return this._m_NameTextures[name];
    }
    /**
     * 重新设置frameBuffer大小。<br/>
     * @param {GLContext}[gl]
     * @param {Number}[w]
     * @param {Number}[h]
     */

  }, {
    key: "resize",
    value: function resize(gl, w, h) {
      var _this = this;

      if (this._m_FixedSize) return;

      if (this._m_Width != w || this._m_Height != h) {
        this._m_Width = w;
        this._m_Height = h; // 删除掉当前帧缓冲

        gl.deleteFramebuffer(this._m_Framebuffer); // 重新创建

        this._m_Framebuffer = gl.createFramebuffer(); // texture列表

        this._m_Textures = []; // textureName:texture

        this._m_NameTextures = {}; // key:attachId,value:texture

        this._m_MapTextures = {}; // buffer列表

        this._m_Buffers = []; // key:attachId,value:buffer

        this._m_MapBuffers = {}; // 所有启用的drawBuffer

        this._m_DrawBuffers = [];
        var data = null;

        for (var type in this._m_RData) {
          data = this._m_RData[type].values;

          if (type == 'buffer') {
            data.forEach(function (d) {
              _this.addBuffer(gl, d.name, d.format, d.attachId);
            });
          } else if (type == 'texture') {
            data.forEach(function (d) {
              _this.addTexture(gl, d.name, d.internalformat, d.border, d.format, d.type, d.attachId, d.toDrawBuffer, d.genMipmap);
            });
          }
        }

        this.finish(gl);
      }
    }
    /**
     * 生成FrameBuffer。<br/>
     * @param {GLContext}[gl]
     */

  }, {
    key: "finish",
    value: function finish(gl, scene, makeFramePicture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._m_Framebuffer);
      if (this._m_DrawBuffers.length > 0) gl.drawBuffers(this._m_DrawBuffers);

      if (!gl.isFramebuffer(this._m_Framebuffer)) {
        _Log.default.error("[[" + this._m_Name + "]]无效frameBuffer!");
      }

      switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        case gl.FRAMEBUFFER_COMPLETE:
          _Log.default.log("[[" + this._m_Name + "]]帧缓冲区已准备好显示。");

          break;

        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          _Log.default.error("[[" + this._m_Name + "]]附件类型不匹配或不是所有的帧缓冲附件点都已完成。");

          break;

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          _Log.default.error("[[" + this._m_Name + "]]没有附件。");

          break;

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          _Log.default.error("[[" + this._m_Name + "]]附件的高度和宽度不同。");

          break;

        case gl.FRAMEBUFFER_UNSUPPORTED:
          _Log.default.error("[[" + this._m_Name + "]]不支持附件的格式，或者深度和模板附件的渲染缓冲区不同。");

          break;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      if (makeFramePicture) {
        this._m_FramePicture = new _FramePicture.default(scene, {
          id: this._m_Name + "_picture"
        });
      }
    }
  }]);

  return FrameBuffer;
}();

exports["default"] = FrameBuffer;

/***/ }),

/***/ 6798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var FrameContext = /*#__PURE__*/function () {
  function FrameContext() {
    _classCallCheck(this, FrameContext);

    this.m_LastMaterial = null;
    this.m_LastIDrawable = null;
    this.m_LastSubShader = null;
    this.m_LastSubShaderId = null;
    this.m_LastFrameBuffer = null; // 统计
    // 每帧切换的材质

    this.m_SM = 0; // 每帧切换的shader

    this.m_SS = 0; // batchLightLastIndex

    this._m_BatchLightLastIndex = 0; // 默认帧缓存(只存在forward渲染路径时,为null,否则创建一个fbo)

    this._m_DefaultFrameBuffer = null; // 当前需要的上下文

    this.m_Contexts = {}; // 保存已计算的当前需要的上下文变量

    this.m_CalcContexts = {}; // 渲染状态

    this.m_RenderState = new _RenderState.default(true); // 渲染frameBuffer(key:id,value:fb}

    this.m_FrameBuffers = {}; // 内存中所有的shader

    this.m_Shaders = {}; // 内存中所有的Blocks

    this._m_ContextBlocks = {};
  }
  /**
   * 返回BatchLightLastIndex。<br/>
   * @return {number}
   */


  _createClass(FrameContext, [{
    key: "getBatchLightLastIndex",
    value: function getBatchLightLastIndex() {
      return this._m_BatchLightLastIndex;
    }
    /**
     * 设置batchLightLastIndex。<br/>
     * @param {Number}[lastIndex]
     * @constructor
     */

  }, {
    key: "BatchLightLastIndex",
    set: function set(lastIndex) {
      this._m_BatchLightLastIndex = lastIndex;
    }
    /**
     * 上下文视口发生变换。<br/>
     * @param {GLContext}[gl]
     * @param {Number}[w]
     * @param {Number}[h]
     */

  }, {
    key: "resize",
    value: function resize(gl, w, h) {
      for (var k in this.m_FrameBuffers) {
        this.m_FrameBuffers[k].resize(gl, w, h);
      }
    }
    /**
     * 返回当前上下文block。<br/>
     * @param {String}[id]
     * @return {*}
     */

  }, {
    key: "getContextBlock",
    value: function getContextBlock(id) {
      return this._m_ContextBlocks[id];
    }
    /**
     * 添加一个上下文block。<br/>
     * @param {String}[id]
     * @param {Object}[block]
     */

  }, {
    key: "addContextBlock",
    value: function addContextBlock(id, block) {
      this._m_ContextBlocks[id] = block;
    }
    /**
     * 返回指定的frameBuffer。<br/>
     * @param {String}[id]
     * @return {*}
     */

  }, {
    key: "getFrameBuffer",
    value: function getFrameBuffer(id) {
      return this.m_FrameBuffers[id];
    }
    /**
     * 添加指定的frameBuffer。<br/>
     * @param {String}[id]
     * @param {*}[fb]
     */

  }, {
    key: "addFrameBuffer",
    value: function addFrameBuffer(id, fb) {
      this.m_FrameBuffers[id] = fb;
    }
    /**
     * 渲染状态。<br/>
     * @return {RenderState}
     */

  }, {
    key: "getRenderState",
    value: function getRenderState() {
      return this.m_RenderState;
    }
    /**
     * 添加当前需要的上下文。<br/>
     * @param {String}[context]
     */

  }, {
    key: "addContext",
    value: function addContext(context) {
      this.m_Contexts[context] = true;
    }
    /**
     * 返回是否存在该上下文变量。<br/>
     * @param {String}[context]
     * @return {Boolean}
     */

  }, {
    key: "getContext",
    value: function getContext(context) {
      return this.m_Contexts[context];
    }
    /**
     * 返回上下文变量值列表。<br/.
     * @return {{}|*}
     */

  }, {
    key: "getCalcContexts",
    value: function getCalcContexts() {
      return this.m_CalcContexts;
    }
    /**
     * 返回指定的上下文变量值。<br/>
     * @param {String}[name 变量名]
     * @return {*}
     */

  }, {
    key: "getCalcContext",
    value: function getCalcContext(name) {
      return this.m_CalcContexts[name];
    }
    /**
     * 保存指定的上下文变量值。<br/>
     * @param {String}[name 变量名]
     * @param {Object}[value 值]
     */

  }, {
    key: "setCalcContext",
    value: function setCalcContext(name, value) {
      this.m_CalcContexts[name] = value;
    }
    /**
     * 重置上下文信息。
     */

  }, {
    key: "reset",
    value: function reset() {
      this._m_BatchLightLastIndex = 0;
      this.m_LastMaterial = null;
      this.m_LastSubShader = null;
      this.m_LastSubShaderId = null;
      this.m_LastFrameBuffer = null;
      this.m_SM = 0;
      this.m_SS = 0;
    }
  }]);

  return FrameContext;
}();

exports["default"] = FrameContext;

/***/ }),

/***/ 307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ArrayBuf = _interopRequireDefault(__webpack_require__(6693));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _SizeOf = _interopRequireDefault(__webpack_require__(2228));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Mesh = /*#__PURE__*/function () {
  // 以下属性表明引擎的Mesh数据块仅支持这些属性(不要设计自定义属性,这样会加大复杂度)
  // 重心坐标属性(用于实现webGL上线框模式)
  // 位置属性
  // 顶点颜色属性
  // 法线属性
  // 索引属性
  // 切线属性
  // 最多支持4道uv(正常来说2道已经足够了)
  // uv0
  // uv1
  // uv2
  // uv3
  // skin joint
  // skin weight
  // 图元类型
  function Mesh() {
    _classCallCheck(this, Mesh);

    this._m_Datas = {};
    this._m_Bufs = {};
    this._m_VAO = null;
    this._m_GL = null;
    this._m_ElementCount = 0;
    this._m_Primitive = Mesh.S_PRIMITIVE_TRIANGLES;
    this._m_DrawPrimitive = null;
    this._m_DrawType = null;
    this._m_CurrentLod = 0;
    this._m_DrawLod = 0;
    this._m_LodLevels = {};
    this._m_LodLevelCount = 0;
  }
  /**
   * 设置图元。<br/>
   * @param {String}[primitive 应该为Mesh枚举值之一]
   */


  _createClass(Mesh, [{
    key: "setPrimitive",
    value: function setPrimitive(primitive) {
      // 检查是否为有效的提供的枚举值
      this._m_Primitive = primitive;

      if (this._m_GL) {
        switch (this._m_Primitive) {
          case Mesh.S_PRIMITIVE_TRIANGLES:
            this._m_DrawPrimitive = this._m_GL.TRIANGLES;
            break;

          case Mesh.S_PRIMITIVE_LINES:
            this._m_DrawPrimitive = this._m_GL.LINES;
            break;
        }
      }
    }
    /**
     * 返回当前图元。<br/>
     * @return {string|*}
     */

  }, {
    key: "getPrimitive",
    value: function getPrimitive() {
      return this._m_Primitive;
    }
  }, {
    key: "_checkDataType",
    value: function _checkDataType(type) {
      if (Mesh.S_DATAS[type]) {
        return true;
      } else {
        console.error('type is undefined:' + type);
        return false;
      }
    }
    /**
     * 设置Mesh数据。<br/>
     * @param {Number}[type Mesh的数据类型枚举]
     * @param {ArrayBuffer}[data 数据]
     * @param {Object}[options]
     */

  }, {
    key: "setData",
    value: function setData(type, data, options) {
      if (this._checkDataType(type)) {
        if (options && options.level != undefined) {
          if (!this._m_Datas[type]) {
            this._m_Datas[type] = {
              lod: true,
              datas: [],
              count: 0
            };
          }

          this._m_Datas[type].count += data.length;

          this._m_Datas[type].datas.push({
            data: data,
            level: options.level,
            count: data.length
          });
        } else {
          this._m_Datas[type] = data;
        }
      } else {
        //根据options来指定参数
        this._m_Datas[type] = data;
      }
    }
    /**
     * 返回Mesh数据。<br/>
     * @param {Number}[type Mesh的数据类型枚举]
     * @return {ArrayBuffer}
     */

  }, {
    key: "getData",
    value: function getData(type) {
      return this._m_Datas[type];
    }
  }, {
    key: "_refreshBufLocal",
    value: function _refreshBufLocal(gl, customAttrs) {
      var _this = this;

      // 更新几何属性列表local属性
      var buf = null;
      customAttrs.forEach(function (attr) {
        buf = _this._m_Bufs[attr.name];

        if (buf) {}
      });
    }
    /**
     * 更新数据列表<br/>
     * @param {Object}[gl]
     * @private
     */

  }, {
    key: "_updateBound",
    value: function _updateBound(gl) {
      this._m_GL = gl;

      if (this._m_Datas) {
        if (!this._m_VAO) {
          this._m_VAO = gl.createVertexArray();
        }

        for (var key in this._m_Datas) {
          switch (key) {
            case Mesh.S_BARYCENTRICS:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_BARYCENTRIC, 3, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_POSITIONS:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_POSITION, 3, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_COLORS:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_COLOR, 4, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_NORMALS:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_NORMAL, 3, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_TANGENTS:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_TANGENT, 4, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_INDICES:
              this._m_DrawType = gl.UNSIGNED_SHORT;

              if (this._m_Datas[key].lod) {
                var datas = this._m_Datas[key].datas;
                var data = new Uint16Array(this._m_Datas[key].count);
                var max = 0;
                var _max = 0;

                for (var i = 0, j = 0; i < datas.length; i++) {
                  this._m_LodLevels[datas[i].level] = {
                    lod: j,
                    count: datas[i].count
                  };
                  this._m_LodLevelCount++;

                  for (var t = 0, os = _max == 0 ? 0 : _max + 1; t < datas[i].data.length; t++) {
                    data[j++] = os + datas[i].data[t];
                    max = Math.max(datas[i].data[t] + os, max);
                  }

                  _max = max;
                  max = 0;
                }

                this._m_CurrentLod = -1;
                this.lod(0);

                _ArrayBuf.default.setIndicesBuf(gl, this._m_VAO, gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
              } else {
                this._m_ElementCount = this._m_Datas[key].length;

                _ArrayBuf.default.setIndicesBuf(gl, this._m_VAO, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this._m_Datas[key]), gl.STATIC_DRAW);
              }

              break;

            case Mesh.S_INDICES_32:
              this._m_DrawType = gl.UNSIGNED_INT;

              if (this._m_Datas[key].lod) {
                var _datas = this._m_Datas[key].datas;

                var _data = new Uint32Array(this._m_Datas[key].count);

                var _max2 = 0;
                var _max3 = 0;

                for (var _i = 0, _j = 0; _i < _datas.length; _i++) {
                  this._m_LodLevels[_datas[_i].level] = {
                    lod: _j,
                    count: _datas[_i].count
                  };
                  this._m_LodLevelCount++;

                  for (var _t = 0, _os = _max3 == 0 ? 0 : _max3 + 1; _t < _datas[_i].data.length; _t++) {
                    _data[_j++] = _os + _datas[_i].data[_t];
                    _max2 = Math.max(_datas[_i].data[_t] + _os, _max2);
                  }

                  _max3 = _max2;
                  _max2 = 0;
                }

                this._m_CurrentLod = -1;
                this.lod(0);

                _ArrayBuf.default.setIndicesBuf(gl, this._m_VAO, gl.ELEMENT_ARRAY_BUFFER, _data, gl.STATIC_DRAW);
              } else {
                this._m_ElementCount = this._m_Datas[key].length;

                _ArrayBuf.default.setIndicesBuf(gl, this._m_VAO, gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(this._m_Datas[key]), gl.STATIC_DRAW);
              }

              break;

            case Mesh.S_UV0:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_UV0, 2, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_UV1:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_UV1, 2, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_UV2:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_UV2, 2, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_UV3:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_UV3, 2, gl.FLOAT, 0, 0);

              break;

            case Mesh.S_JOINTS_0:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Uint16Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_JOINT_0, 4, gl.UNSIGNED_SHORT, 0, 0);

              break;

            case Mesh.S_JOINTS_0_32:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Uint32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_JOINT_0, 4, gl.UNSIGNED_INT, 0, 0);

              break;

            case Mesh.S_WEIGHTS_0:
              _ArrayBuf.default.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, _ShaderSource.default.S_WEIGHT_0, 4, gl.FLOAT, 0, 0);

              break;

            default:
              //自定义,由于自定义的属性在没有绑定着色器之前,是无法显式知道属性位置的,所以需要在绑定着色器后,设定属性位置。
              // ArrayBuf.setVertexBuf(gl, this._m_VAO, gl.ARRAY_BUFFER, new Float32Array(this._m_Datas[key]), gl.STATIC_DRAW, ShaderSource.S_NORMAL, 3, gl.FLOAT, this._m_Datas[key].length, 0);
              break;
          }
        }

        switch (this._m_Primitive) {
          case Mesh.S_PRIMITIVE_TRIANGLES:
            this._m_DrawPrimitive = this._m_GL.TRIANGLES;
            break;

          case Mesh.S_PRIMITIVE_LINES:
            this._m_DrawPrimitive = this._m_GL.LINES;
            break;
        }
      }
    }
    /**
     * 绘制该Mesh。<br/>
     * 由内部引擎调用，通常不应该手动调用。<br/>
     * @param {WebGL}[gl]
     */

  }, {
    key: "draw",
    value: function draw(gl) {
      gl.bindVertexArray(this._m_VAO);
      gl.drawElements(this._m_DrawPrimitive, this._m_ElementCount, this._m_DrawType, this._m_DrawLod);
    }
    /**
     * 设置该Mesh渲染使用的细节层次。<br/>
     * @param {Number}[lod]
     */

  }, {
    key: "lod",
    value: function lod(_lod) {
      if (this._m_CurrentLod == _lod) return;

      if (this._m_LodLevels[_lod] != null) {
        this._m_CurrentLod = _lod;
        this._m_ElementCount = this._m_LodLevels[this._m_CurrentLod].count;
        this._m_DrawLod = this._m_LodLevels[this._m_CurrentLod].lod * _SizeOf.default.sizeof(_SizeOf.default.S_UNSIGNED_SHORT);
      } else {
        _Log.default.error('lod level ' + _lod + '对于当前Mesh无效!');
      }
    }
    /**
     * 返回细节层次级别数量。<br/>
     * @return {Number}
     */

  }, {
    key: "getLodLevelCount",
    value: function getLodLevelCount() {
      return this._m_LodLevelCount;
    }
    /**
     * 返回指定细节层次级别对应的图元数量。<br/>
     * 如果该细节层次级别超过有效级别范围,则返回0。<br/>
     * @param {Number}[lod]
     * @return {Number}
     */

  }, {
    key: "getLodPrimitiveCount",
    value: function getLodPrimitiveCount(lod) {
      if (this._m_LodLevels[lod] != null) {
        var drawCount = this._m_LodLevels[lod].count;

        switch (this._m_Primitive) {
          case Mesh.S_PRIMITIVE_TRIANGLES:
            return drawCount / 3;
            break;

          case Mesh.S_PRIMITIVE_LINES:
            return drawCount / 2;
            break;
        }
      } else {
        _Log.default.error('lod level ' + lod + '对于当前Mesh无效!');
      }

      return 0;
    }
  }]);

  return Mesh;
}();

exports["default"] = Mesh;

_defineProperty(Mesh, "S_BARYCENTRICS", "barycentrics");

_defineProperty(Mesh, "S_POSITIONS", "positions");

_defineProperty(Mesh, "S_COLORS", "colors");

_defineProperty(Mesh, "S_NORMALS", "normals");

_defineProperty(Mesh, "S_INDICES", "indices");

_defineProperty(Mesh, "S_INDICES_32", "indices32");

_defineProperty(Mesh, "S_TANGENTS", "tangents");

_defineProperty(Mesh, "S_UV0", "uv0");

_defineProperty(Mesh, "S_UV1", "uv1");

_defineProperty(Mesh, "S_UV2", "uv2");

_defineProperty(Mesh, "S_UV3", "uv3");

_defineProperty(Mesh, "S_JOINTS_0", "joints_0");

_defineProperty(Mesh, "S_JOINTS_0_32", "joints_0");

_defineProperty(Mesh, "S_WEIGHTS_0", "weights_0");

_defineProperty(Mesh, "S_DATAS", {
  "barycentrics": "barycentrics",
  "positions": "positions",
  "colors": "colors",
  "normals": "normals",
  "indices": "indices",
  "indices32": "indices",
  "tangents": "tangents",
  "uv0": "uv0",
  "uv1": "uv1",
  "uv2": "uv2",
  "uv3": "uv3",
  "joints_0": "joints_0",
  "weights_0": "weights_0"
});

_defineProperty(Mesh, "S_PRIMITIVE_TRIANGLES", 'triangles');

_defineProperty(Mesh, "S_PRIMITIVE_LINES", 'lines');

/***/ }),

/***/ 8435:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 渲染状态。<br/>
 * @author Kkk
 * @date 2021年2月9日15点41分
 */
var RenderState = /*#__PURE__*/function () {
  function RenderState(defaultState) {
    _classCallCheck(this, RenderState);

    this._m_State = {};
    this._m_StoreState = {
      _state: {},
      getState: function getState() {
        return this._state;
      }
    };
    this._m_ResetState = {
      _state: {},
      getState: function getState() {
        return this._state;
      }
    };

    if (defaultState) {
      this._init();
    }
  }

  _createClass(RenderState, [{
    key: "getState",
    value: function getState() {
      return this._m_State;
    }
  }, {
    key: "getFlag",
    value: function getFlag(flag) {
      return this._m_State[flag];
    }
  }, {
    key: "setFlag",
    value: function setFlag(flag, data) {
      this._m_State[flag] = data;
    }
  }, {
    key: "store",
    value: function store() {
      for (var k in this._m_State) {
        this._m_StoreState._state[k] = this._m_State[k];
      }
    }
  }, {
    key: "restore",
    value: function restore() {
      return this._m_StoreState;
    }
  }, {
    key: "_init",
    value: function _init() {
      this._m_State[RenderState.S_STATES[0]] = RenderState.S_FACE_CULL_BACK;
      this._m_State[RenderState.S_STATES[1]] = 'On';
      this._m_State[RenderState.S_STATES[2]] = 'On';
      this._m_State[RenderState.S_STATES[3]] = 'On';
      this._m_State[RenderState.S_STATES[4]] = 'Off';
      this._m_State[RenderState.S_STATES[6]] = 'Off';
      this._m_State[RenderState.S_STATES[7]] = 'Off';
      this._m_ResetState._state[RenderState.S_STATES[0]] = RenderState.S_FACE_CULL_BACK;
      this._m_ResetState._state[RenderState.S_STATES[1]] = 'On';
      this._m_ResetState._state[RenderState.S_STATES[2]] = 'On';
      this._m_ResetState._state[RenderState.S_STATES[3]] = 'On';
      this._m_ResetState._state[RenderState.S_STATES[4]] = 'Off';
      this._m_ResetState._state[RenderState.S_STATES[6]] = 'Off';
      this._m_ResetState._state[RenderState.S_STATES[7]] = 'Off';
    }
  }, {
    key: "reset",
    value: function reset() {
      return this._m_ResetState;
    }
  }]);

  return RenderState;
}();

exports["default"] = RenderState;

_defineProperty(RenderState, "S_FACE_CULL_OFF", 'Off');

_defineProperty(RenderState, "S_FACE_CULL_BACK", 'Back');

_defineProperty(RenderState, "S_FACE_CULL_FRONT", 'Front');

_defineProperty(RenderState, "S_FACE_CULL_FRONT_AND_BACK", 'FrontAndBack');

_defineProperty(RenderState, "S_STATES", ["FaceCull", "DepthWrite", "ColorWrite", "DepthTest", "Blend", "BlendFactor", "ScissorTest", "PolygonOffsetFill", "PolygonOffset"]);

/***/ }),

/***/ 6616:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 着色器对象通过解析vs和fs生成webGL shader对象,并保留句柄，以便后续使用。<br/>
 * @author Kkk
 */
var Shader = /*#__PURE__*/function () {
  /**
   * 全局变量
   * @type {string}
   */

  /**
   * 全局参数
   * @type {{viewMatrix: string, projectMatrix: string, viewProjectMatrix: string}}
   */
  function Shader(gl, type, soucre) {
    _classCallCheck(this, Shader);

    this._m_GL = gl;
    this._m_Shader = gl.createShader(type);
    gl.shaderSource(this._m_Shader, soucre);
    gl.compileShader(this._m_Shader);
    this.compile = gl.getShaderParameter(this._m_Shader, gl.COMPILE_STATUS);

    if (!this.compile) {
      this.error = gl.getShaderInfoLog(this._m_Shader);
      console.log("编译[" + (type == gl.VERTEX_SHADER ? 'vertex_shader' : type == gl.FRAGMENT_SHADER ? 'fragment_shader' : 'unknow_shader') + "]失败!原因:\n" + this.error);
    }
  }

  _createClass(Shader, [{
    key: "getShader",
    value: function getShader() {
      return this._m_Shader;
    }
  }, {
    key: "deleteShader",
    value: function deleteShader() {
      var gl = this._m_GL;
      gl.deleteShader(this._m_Shader);
      this._m_Shader = null;
    }
  }]);

  return Shader;
}();

exports["default"] = Shader;

_defineProperty(Shader, "S_TYPE", {
  "float": "float",
  "mat4": "mat4"
});

_defineProperty(Shader, "S_GLOBALS_MAT", 'layout (std140) uniform S_GLOBALS_MAT\n' + '{\n' + 'mat4 Globals_ViewMatrix;\n' + 'mat4 Globals_ProjectMatrix;\n' + 'mat4 Globals_ViewProjectMatrix;\n' + '};\n');

_defineProperty(Shader, "S_GLOBALS_PARAMS", {
  "viewMatrix": "Globals_ViewProjectMatrix",
  "projectMatrix": "Globals_ProjectMatrix",
  "viewProjectMatrix": "Globals_ViewProjectMatrix"
});

/***/ }),

/***/ 9836:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Shader = _interopRequireDefault(__webpack_require__(6616));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * ShaderProgram定义了着色器程序对象,解析shaderSource并生成指定的着色器程序对象,以便后续使用。<br/>
 * 其中shaderSource包含了vs,gs,fs等的源码，这些源码可以从外部解析读取得到，也可以通过js脚本定义得到。<br/>
 * @author Kkk
 */
var ShaderProgram = /*#__PURE__*/function () {
  function ShaderProgram(gl, defId, shaderSource, defines, delayCompile) {
    _classCallCheck(this, ShaderProgram);

    this._m_DefId = defId;
    this._m_vs_s = shaderSource.get(_ShaderSource.default.VERTEX_SHADER);
    this._m_fs_s = shaderSource.get(_ShaderSource.default.FRAGMENT_SHADER);
    this._m_vsDefines = defines ? defines[_ShaderSource.default.VERTEX_SHADER] : null;
    this._m_fsDefines = defines ? defines[_ShaderSource.default.FRAGMENT_SHADER] : null;
    this._m_Hold = 0;
    this._m_Holds = {};

    if (delayCompile) {
      // this._compile();
      this._m_needCompile = true;
    } else {
      this._compile(gl);
    }
  }
  /**
   * 是否应该销毁。<br/>
   * @return {Boolean}
   */


  _createClass(ShaderProgram, [{
    key: "canDestroy",
    value: function canDestroy() {
      return this._m_Hold <= 0;
    }
    /**
     * 销毁。<br/>
     * @param {WebGL}[gl]
     * @param {FrameContext}[frameContext]
     */

  }, {
    key: "destroy",
    value: function destroy(gl, frameContext) {
      if (this._m_Program) {
        // 删除
        gl.deleteProgram(this._m_Program);
        frameContext.m_Shaders[this._m_DefId] = null;
        this._m_Program = null;
      }
    }
    /**
     * 增加一个句柄。<br/>
     */

  }, {
    key: "addHold",
    value: function addHold(hold) {
      this._m_Hold++;
      this._m_Holds[hold._m_ObjId] = hold;
    }
    /**
     * 删除一个句柄。<br/>
     */

  }, {
    key: "deleteHold",
    value: function deleteHold(hold) {
      this._m_Hold--;
      this._m_Holds[hold._m_ObjId] = null;
    }
    /**
     * 是否需要编译。<br/>
     * @return {Boolean}
     */

  }, {
    key: "needCompile",
    value: function needCompile() {
      return this._m_needCompile;
    }
    /**
     * 编译源码。<br/>
     * @private
     */

  }, {
    key: "_compile",
    value: function _compile(gl) {
      this._m_needCompile = false;

      if (this._m_vs_s) {
        if (this._m_vsDefines) {
          // 追加宏定义
          this._m_vs_s = _Tools.default.insertLine(this._m_vs_s, this._m_vsDefines, 1);
        }

        this._m_vs = new _Shader.default(gl, gl.VERTEX_SHADER, this._m_vs_s);
      }

      if (this._m_fs_s) {
        if (this._m_fsDefines) {
          // 追加宏定义
          this._m_fs_s = _Tools.default.insertLine(this._m_fs_s, this._m_fsDefines, 1);
        }

        this._m_fs = new _Shader.default(gl, gl.FRAGMENT_SHADER, this._m_fs_s);
      }

      this._m_Program = null;

      if (this._m_vs && this._m_fs) {
        if (this._m_vs.compile && this._m_fs.compile) {
          this._m_Program = gl.createProgram();
          gl.attachShader(this._m_Program, this._m_vs.getShader());
          gl.attachShader(this._m_Program, this._m_fs.getShader());
          gl.linkProgram(this._m_Program);
          var linkStatus = gl.getProgramParameter(this._m_Program, gl.LINK_STATUS);

          if (!linkStatus) {
            var pil = gl.getProgramInfoLog(this._m_Program);
            console.error("[[" + name + "]]链接ShaderProgram异常:" + pil);
            console.log("vs:\n" + this._m_vs_s);
            console.log("fs:\n" + this._m_fs_s);
          }

          this._m_vs.deleteShader();

          this._m_fs.deleteShader();
        } else {
          console.error("[[" + name + "]]无法创建着色器程序,vs或fs编译失败!!");
          console.log("vs:\n" + this._m_vs_s);
          console.log("fs:\n" + this._m_fs_s);
        }
      }
    }
  }, {
    key: "use",
    value: function use(gl) {
      gl.useProgram(this._m_Program);
    }
  }, {
    key: "getProgram",
    value: function getProgram() {
      return this._m_Program;
    }
  }]);

  return ShaderProgram;
}();

exports["default"] = ShaderProgram;

/***/ }),

/***/ 9784:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 着色器源码,定义一个着色器程序源码,一个着色器程序至少应该包含vertex_shader源码和fragment_shader源码。<br/>
 * @author Kkk
 */
var ShaderSource = /*#__PURE__*/function () {
  function ShaderSource() {
    _classCallCheck(this, ShaderSource);

    this._m_Source = {};
  }

  _createClass(ShaderSource, [{
    key: "set",
    value: function set(type, src) {
      if (ShaderSource.SOURCE_ENUM[type]) {
        this._m_Source[type] = src;
      } else {
        console.error("未知着色器类型:" + type);
      }
    }
  }, {
    key: "get",
    value: function get(type) {
      if (ShaderSource.SOURCE_ENUM[type]) {
        return this._m_Source[type];
      } else {
        console.error("未知着色器类型:" + type);
        return null;
      }
    }
  }], [{
    key: "resizeBatchLightSize",
    value: // 枚举,这些是作为引擎内置可能存在的输入属性，变量
    // 灯光系统
    // multi pass 下每个光源的三个信息
    // 默认为4个灯光批次
    function resizeBatchLightSize(size) {
      if (size != ShaderSource.S_BATCH_LIGHT_SIZE) {
        ShaderSource.S_BATCH_LIGHT_SIZE = size * 3;
        ShaderSource.Context_Data["Context.VLightData"].modifier = '[' + ShaderSource.S_BATCH_LIGHT_SIZE + ']';
        ShaderSource.Context_Data["Context.WLightData"].modifier = '[' + ShaderSource.S_BATCH_LIGHT_SIZE + ']';
      }
    }
  }]);

  return ShaderSource;
}();

exports["default"] = ShaderSource;

_defineProperty(ShaderSource, "VERTEX_SHADER", "vertex_shader");

_defineProperty(ShaderSource, "FRAGMENT_SHADER", "fragment_shader");

_defineProperty(ShaderSource, "SOURCE_ENUM", {
  "vertex_shader": "vertex_shader",
  "fragment_shader": "fragment_shader"
});

_defineProperty(ShaderSource, "S_BARYCENTRIC", 0x000);

_defineProperty(ShaderSource, "S_POSITION", 0x001);

_defineProperty(ShaderSource, "S_COLOR", 0x002);

_defineProperty(ShaderSource, "S_NORMAL", 0x003);

_defineProperty(ShaderSource, "S_TANGENT", 0x004);

_defineProperty(ShaderSource, "S_UV0", 0x005);

_defineProperty(ShaderSource, "S_UV1", 0x006);

_defineProperty(ShaderSource, "S_UV2", 0x007);

_defineProperty(ShaderSource, "S_UV3", 0x008);

_defineProperty(ShaderSource, "S_JOINT_0", 0x009);

_defineProperty(ShaderSource, "S_WEIGHT_0", 0x00A);

_defineProperty(ShaderSource, "S_MODEL_MATRIX", 0x011);

_defineProperty(ShaderSource, "S_VIEW_MATRIX", 0x012);

_defineProperty(ShaderSource, "S_PROJECT_MATRIX", 0x013);

_defineProperty(ShaderSource, "S_MVP", 0x014);

_defineProperty(ShaderSource, "S_MV", 0x015);

_defineProperty(ShaderSource, "S_VP", 0x016);

_defineProperty(ShaderSource, "S_NDP", 0x017);

_defineProperty(ShaderSource, "S_G_BUFFER0", 0);

_defineProperty(ShaderSource, "S_G_BUFFER1", 1);

_defineProperty(ShaderSource, "S_G_BUFFER2", 2);

_defineProperty(ShaderSource, "S_G_DEPTH", 3);

_defineProperty(ShaderSource, "S_BARYCENTRIC_SRC", "_barycentric");

_defineProperty(ShaderSource, "S_POSITION_SRC", "_position");

_defineProperty(ShaderSource, "S_COLOR_SRC", "_color");

_defineProperty(ShaderSource, "S_NORMAL_SRC", "_normal");

_defineProperty(ShaderSource, "S_TANGENT_SRC", "_tangent");

_defineProperty(ShaderSource, "S_UV0_SRC", "_uv0");

_defineProperty(ShaderSource, "S_UV1_SRC", "_uv1");

_defineProperty(ShaderSource, "S_UV2_SRC", "_uv2");

_defineProperty(ShaderSource, "S_UV3_SRC", "_uv3");

_defineProperty(ShaderSource, "S_JOINT_0_SRC", "_joint_0");

_defineProperty(ShaderSource, "S_WEIGHT_0_SRC", "_weight_0");

_defineProperty(ShaderSource, "S_JOINTS_SRC", "_joints");

_defineProperty(ShaderSource, "S_OUT_COLOR", "_outColor");

_defineProperty(ShaderSource, "S_OUT_POSITION", "gl_Position");

_defineProperty(ShaderSource, "S_MODEL_MATRIX_SRC", "_model_matrix");

_defineProperty(ShaderSource, "S_VIEW_MATRIX_SRC", "_view_matrix");

_defineProperty(ShaderSource, "S_PROJECT_MATRIX_SRC", "_project_matrix");

_defineProperty(ShaderSource, "S_MVP_SRC", "_model_view_project_matrix");

_defineProperty(ShaderSource, "S_MV_SRC", "_model_view_matrix");

_defineProperty(ShaderSource, "S_VP_SRC", "_view_project_matrix");

_defineProperty(ShaderSource, "S_NDP", "");

_defineProperty(ShaderSource, "S_V_LIGHT_DATA_SRC", '_vLightData');

_defineProperty(ShaderSource, "S_W_LIGHT_DATA_SRC", '_wLightData');

_defineProperty(ShaderSource, "S_MULTI_ID_SRC", '_multiId');

_defineProperty(ShaderSource, "S_BLEND_GI_PROBES", '_blend_gi_probes');

_defineProperty(ShaderSource, "S_V_LIGHT_DATA0_SRC", '_vLight_Data_0');

_defineProperty(ShaderSource, "S_V_LIGHT_DATA1_SRC", '_vLight_Data_1');

_defineProperty(ShaderSource, "S_V_LIGHT_DATA2_SRC", '_vLight_Data_2');

_defineProperty(ShaderSource, "S_W_LIGHT_DATA0_SRC", '_wLight_Data_0');

_defineProperty(ShaderSource, "S_W_LIGHT_DATA1_SRC", '_wLight_Data_1');

_defineProperty(ShaderSource, "S_W_LIGHT_DATA2_SRC", '_wLight_Data_2');

_defineProperty(ShaderSource, "S_AMBIENT_LIGHT_COLOR", '_ambientLightColor');

_defineProperty(ShaderSource, "S_CUR_LIGHT_COUNT_SRC", '_curLightCount');

_defineProperty(ShaderSource, "S_NB_LIGHTS", '_NB_LIGHTS');

_defineProperty(ShaderSource, "S_BATCH_LIGHT_SIZE", 4 * 3);

_defineProperty(ShaderSource, "S_CAMERA_POSITION_SRC", "_cameraPosition");

_defineProperty(ShaderSource, "S_MAX_BONE", 256);

_defineProperty(ShaderSource, "S_SKINS_SRC", '_C_SKINS');

_defineProperty(ShaderSource, "S_SRGB_SRC", '_C_SRGB');

_defineProperty(ShaderSource, "S_GIPROBES_SRC", '_C_GIPROBES');

_defineProperty(ShaderSource, "S_PSSM_SRC", '_C_PSSM');

_defineProperty(ShaderSource, "S_POINTLIGHT_SHADOWS_SRC", '_C_POINTLIGHT_SHADOWS');

_defineProperty(ShaderSource, "S_SPOTLIGHT_SHADOWS_SRC", '_C_SPOTLIGHT_SHADOWS');

_defineProperty(ShaderSource, "S_FADE_SRC", '_C_FADE');

_defineProperty(ShaderSource, "S_G_BUFFER0_SRC", "_gBuffer0");

_defineProperty(ShaderSource, "S_G_BUFFER1_SRC", "_gBuffer1");

_defineProperty(ShaderSource, "S_G_BUFFER2_SRC", "_gBuffer2");

_defineProperty(ShaderSource, "S_G_DEPTH_SRC", "_gDepth");

_defineProperty(ShaderSource, "S_G_DEPTH_RENDER_BUFFER_SRC", "_gDepthRenderBuffer");

_defineProperty(ShaderSource, "S_SCREEN_SRC", "_screen");

_defineProperty(ShaderSource, "S_FORWARD_COLOR_MAP_SRC", "_forwardColorMap");

_defineProperty(ShaderSource, "S_IN_SCREEN_SRC", "_inScreenMap");

_defineProperty(ShaderSource, "S_IN_DEPTH_SRC", "_inDepthMap");

_defineProperty(ShaderSource, "S_LIGHT_NUM_SRC", "_lightNum");

_defineProperty(ShaderSource, "S_TILE_LIGHT_DECODE_SRC", "_tileLightDecode");

_defineProperty(ShaderSource, "S_TILE_LIGHT_INDEX_SRC", "_tileLightIndex");

_defineProperty(ShaderSource, "S_TILE_LIGHT_OFFSET_SIZE", "_tileLightOffsetSize");

_defineProperty(ShaderSource, "S_TILE_W_LIGHT_DATA_0", "_tileWLightData0");

_defineProperty(ShaderSource, "S_TILE_V_LIGHT_DATA_0", "_tileVLightData0");

_defineProperty(ShaderSource, "S_TILE_W_LIGHT_DATA_1", "_tileWLightData1");

_defineProperty(ShaderSource, "S_TILE_V_LIGHT_DATA_1", "_tileVLightData1");

_defineProperty(ShaderSource, "S_TILE_W_LIGHT_DATA_2", "_tileWLightData2");

_defineProperty(ShaderSource, "S_TILE_V_LIGHT_DATA_2", "_tileVLightData2");

_defineProperty(ShaderSource, "S_PREF_ENV_MAP_SRC", "_prefEnvMap");

_defineProperty(ShaderSource, "S_WGIPROBE_SRC", "_wGIProbe");

_defineProperty(ShaderSource, "S_SH_COEFFS_SRC", "_ShCoeffs");

_defineProperty(ShaderSource, "S_RESOLUTION_INVERSE", '_ResolutionInverse');

_defineProperty(ShaderSource, "S_SHADOW_MAP_ARRAY_SRC", {
  0: '_shadowMap0',
  1: '_shadowMap1',
  2: '_shadowMap2',
  3: '_shadowMap3',
  4: '_shadowMap4',
  5: '_shadowMap5',
  6: '_shadowMap6'
});

_defineProperty(ShaderSource, "S_LIGHT_SHADOW_VP_ARRAY_SRC", {
  0: '_lightViewProjectMatrix0',
  1: '_lightViewProjectMatrix1',
  2: '_lightViewProjectMatrix2',
  3: '_lightViewProjectMatrix3',
  4: '_lightViewProjectMatrix4',
  5: '_lightViewProjectMatrix5',
  6: '_lightViewProjectMatrix6'
});

_defineProperty(ShaderSource, "S_LIGHT_DIR", "_lightDir");

_defineProperty(ShaderSource, "S_LIGHT_POS", "_lightPos");

_defineProperty(ShaderSource, "S_SPLITS", "_splits");

_defineProperty(ShaderSource, "S_FADEINFO", "_fadeInfo");

_defineProperty(ShaderSource, "S_SHADOW_MAP_SIZE", "_shadowMapSize");

_defineProperty(ShaderSource, "S_SHADOW_MAP_SIZE_INVERSE", "_sMapSizeInverse");

_defineProperty(ShaderSource, "ContextBlocks", {
  S_VIEW_MATRIX_SRC: true,
  S_PROJECT_MATRIX_SRC: true,
  S_VP_SRC: true
});

_defineProperty(ShaderSource, "MAT", 'layout (std140) uniform MAT\n' + '{\n' + 'mat4 ' + ShaderSource.S_VIEW_MATRIX_SRC + ';\n' + 'mat4 ' + ShaderSource.S_PROJECT_MATRIX_SRC + ';\n' + 'mat4 ' + ShaderSource.S_VP_SRC + ';\n' + '};\n');

_defineProperty(ShaderSource, "VIEW", 'layout (std140) uniform VIEW\n' + '{\n' + 'vec3 ' + ShaderSource.S_CAMERA_POSITION_SRC + ';\n' + '};\n');

_defineProperty(ShaderSource, "BLOCKS", {
  'MAT': {
    blockIndex: 0x001,
    blockDef: ShaderSource.MAT
  },
  'VIEW': {
    blockIndex: 0x002,
    blockDef: ShaderSource.VIEW
  }
});

_defineProperty(ShaderSource, "Context_RenderDataRefFBs", {
  "_gBuffer0": 'DefaultDeferredShadingFrameBuffer',
  "_gBuffer1": 'DefaultDeferredShadingFrameBuffer',
  "_gBuffer2": 'DefaultDeferredShadingFrameBuffer',
  "_gDepth": 'DefaultDeferredShadingFrameBuffer',
  "_forwardColorMap": 'DefaultForwardShadingFrameBuffer',
  "_inScreenMap": 'DefaultPostFilterShadingFrameBuffer',
  "_inDepthMap": 'DefaultPostFilterShadingFrameBuffer'
});

_defineProperty(ShaderSource, "Context_Data", {
  "Context.InPosition": {
    src: ShaderSource.S_POSITION_SRC,
    loc: ShaderSource.S_POSITION,
    pattern: /Context.InPosition/,
    pattern2: /Context.InPosition[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InPosition/g,
    tag: ShaderSource.S_POSITION_SRC,
    type: "vec3"
  },
  "Context.InBarycentric": {
    src: ShaderSource.S_BARYCENTRIC_SRC,
    loc: ShaderSource.S_BARYCENTRIC,
    pattern: /Context.InBarycentric/,
    pattern2: /Context.InBarycentric[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InBarycentric/g,
    tag: ShaderSource.S_BARYCENTRIC_SRC,
    type: "vec3"
  },
  "Context.InNormal": {
    src: ShaderSource.S_NORMAL_SRC,
    loc: ShaderSource.S_NORMAL,
    pattern: /Context.InNormal/,
    pattern2: /Context.InNormal[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InNormal/g,
    tag: ShaderSource.S_NORMAL_SRC,
    type: "vec3"
  },
  "Context.InTangent": {
    src: ShaderSource.S_TANGENT_SRC,
    loc: ShaderSource.S_TANGENT,
    pattern: /Context.InTangent/,
    pattern2: /Context.InTangent[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTangent/g,
    tag: ShaderSource.S_TANGENT_SRC,
    type: "vec4"
  },
  "Context.InUv0": {
    src: ShaderSource.S_UV0_SRC,
    loc: ShaderSource.S_UV0,
    pattern: /Context.InUv0/,
    pattern2: /Context.InUv0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InUv0/g,
    tag: ShaderSource.S_UV0_SRC,
    type: "vec2"
  },
  "Context.InJoint0": {
    src: ShaderSource.S_JOINT_0_SRC,
    loc: ShaderSource.S_JOINT_0,
    pattern: /Context.InJoint0/,
    pattern2: /Context.InJoint0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InJoint0/g,
    tag: ShaderSource.S_JOINT_0_SRC,
    type: "vec4"
  },
  "Context.InWeight0": {
    src: ShaderSource.S_WEIGHT_0_SRC,
    loc: ShaderSource.S_WEIGHT_0,
    pattern: /Context.InWeight0/,
    pattern2: /Context.InWeight0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InWeight0/g,
    tag: ShaderSource.S_WEIGHT_0_SRC,
    type: "vec4"
  },
  "Context.OutPosition": {
    src: ShaderSource.S_OUT_POSITION,
    pattern: /Context.OutPosition/,
    pattern2: /Context.OutPosition[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutPosition/g,
    tag: "gl_Position"
  },
  "Context.ProjectViewModelMatrix": {
    src: ShaderSource.S_MVP_SRC,
    pattern: /Context.ProjectViewModelMatrix/,
    pattern2: /Context.ProjectViewModelMatrix[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ProjectViewModelMatrix/g,
    tag: "_model_view_project_matrix",
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.ViewMatrix": {
    src: ShaderSource.S_VIEW_MATRIX_SRC,
    pattern: /Context.ViewMatrix/,
    pattern2: /Context.ViewMatrix[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ViewMatrix/g,
    tag: ShaderSource.S_VIEW_MATRIX_SRC,
    def: 'MAT'
  },
  "Context.ProjectMatrix": {
    src: ShaderSource.S_PROJECT_MATRIX_SRC,
    pattern: /Context.ProjectMatrix/,
    pattern2: /Context.ProjectMatrix[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ProjectMatrix/g,
    tag: ShaderSource.S_PROJECT_MATRIX_SRC,
    def: 'MAT'
  },
  "Context.ModelMatrix": {
    src: ShaderSource.S_MODEL_MATRIX_SRC,
    pattern: /Context.ModelMatrix/,
    pattern2: /Context.ModelMatrix[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ModelMatrix/g,
    tag: ShaderSource.S_MODEL_MATRIX_SRC,
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.ProjectViewMatrix": {
    src: ShaderSource.S_VP_SRC,
    pattern: /Context.ProjectViewMatrix/,
    pattern2: /Context.ProjectViewMatrix[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ProjectViewMatrix/g,
    tag: ShaderSource.S_VP_SRC,
    def: 'MAT'
  },
  "Context.OutColor": {
    src: ShaderSource.S_OUT_COLOR,
    pattern: /Context.OutColor/,
    pattern2: /Context.OutColor[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutColor/g,
    tag: "_outColor",
    type: "out vec4"
  },
  "Context.Joints": {
    src: ShaderSource.S_JOINTS_SRC,
    pattern: /Context.Joints/,
    pattern2: /Context.Joints[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Joints/g,
    tag: ShaderSource.S_JOINTS_SRC,
    type: "vec4",
    utype: "uniform mat4",
    modifier: '[' + ShaderSource.S_MAX_BONE + ']'
  },
  "Context.VLightData": {
    src: ShaderSource.S_V_LIGHT_DATA_SRC,
    pattern: /Context.VLightData/,
    pattern2: /Context.VLightData[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.VLightData/g,
    tag: ShaderSource.S_V_LIGHT_DATA_SRC,
    type: "vec4",
    utype: "uniform vec4",
    modifier: '[' + ShaderSource.S_BATCH_LIGHT_SIZE + ']'
  },
  "Context.MultiId": {
    src: ShaderSource.S_MULTI_ID_SRC,
    pattern: /Context.MultiId/,
    pattern2: /Context.MultiId[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.MultiId/g,
    tag: ShaderSource.S_MULTI_ID_SRC,
    type: "int",
    utype: "uniform int"
  },
  "Context.TileLightNum": {
    src: ShaderSource.S_LIGHT_NUM_SRC,
    pattern: /Context.TileLightNum/,
    pattern2: /Context.TileLightNum[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.TileLightNum/g,
    tag: ShaderSource.S_LIGHT_NUM_SRC,
    type: "int",
    utype: "uniform int"
  },
  "Context.TileLightOffsetSize": {
    src: ShaderSource.S_TILE_LIGHT_OFFSET_SIZE,
    pattern: /Context.TileLightOffsetSize/,
    pattern2: /Context.TileLightOffsetSize[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.TileLightOffsetSize/g,
    tag: ShaderSource.S_TILE_LIGHT_OFFSET_SIZE,
    type: "float",
    utype: "uniform float"
  },
  "Context.BlendGiProbes": {
    src: ShaderSource.S_BLEND_GI_PROBES,
    pattern: /Context.BlendGiProbes/,
    pattern2: /Context.BlendGiProbes[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.BlendGiProbes/g,
    tag: ShaderSource.S_BLEND_GI_PROBES,
    type: "bool",
    utype: "uniform bool"
  },
  "Context.VLight_Data_0": {
    src: ShaderSource.S_V_LIGHT_DATA0_SRC,
    pattern: /Context.VLight_Data_0/,
    pattern2: /Context.VLight_Data_0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.VLight_Data_0/g,
    tag: ShaderSource.S_V_LIGHT_DATA0_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.VLight_Data_1": {
    src: ShaderSource.S_V_LIGHT_DATA1_SRC,
    pattern: /Context.VLight_Data_1/,
    pattern2: /Context.VLight_Data_1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.VLight_Data_1/g,
    tag: ShaderSource.S_V_LIGHT_DATA1_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.VLight_Data_2": {
    src: ShaderSource.S_V_LIGHT_DATA2_SRC,
    pattern: /Context.VLight_Data_2/,
    pattern2: /Context.VLight_Data_2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.VLight_Data_2/g,
    tag: ShaderSource.S_V_LIGHT_DATA2_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.WLightData": {
    src: ShaderSource.S_W_LIGHT_DATA_SRC,
    pattern: /Context.WLightData/,
    pattern2: /Context.WLightData[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.WLightData/g,
    tag: ShaderSource.S_W_LIGHT_DATA_SRC,
    type: "vec4",
    utype: "uniform vec4",
    modifier: '[' + ShaderSource.S_BATCH_LIGHT_SIZE + ']'
  },
  "Context.WLight_Data_0": {
    src: ShaderSource.S_W_LIGHT_DATA0_SRC,
    pattern: /Context.WLight_Data_0/,
    pattern2: /Context.WLight_Data_0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.WLight_Data_0/g,
    tag: ShaderSource.S_W_LIGHT_DATA0_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.WLight_Data_1": {
    src: ShaderSource.S_W_LIGHT_DATA1_SRC,
    pattern: /Context.WLight_Data_1/,
    pattern2: /Context.WLight_Data_1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.WLight_Data_1/g,
    tag: ShaderSource.S_W_LIGHT_DATA1_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.WLight_Data_2": {
    src: ShaderSource.S_W_LIGHT_DATA2_SRC,
    pattern: /Context.WLight_Data_2/,
    pattern2: /Context.WLight_Data_2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.WLight_Data_2/g,
    tag: ShaderSource.S_W_LIGHT_DATA2_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.AmbientLightColor": {
    src: ShaderSource.S_AMBIENT_LIGHT_COLOR,
    pattern: /Context.AmbientLightColor/,
    pattern2: /Context.AmbientLightColor[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.AmbientLightColor/g,
    tag: ShaderSource.S_AMBIENT_LIGHT_COLOR,
    type: "vec3",
    utype: "uniform vec3"
  },
  "Context.CurLightCount": {
    src: ShaderSource.S_CUR_LIGHT_COUNT_SRC,
    pattern: /Context.CurLightCount/,
    pattern2: /Context.CurLightCount[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.CurLightCount/g,
    tag: ShaderSource.S_CUR_LIGHT_COUNT_SRC,
    type: "int",
    utype: 'uniform int'
  },
  "Context.CameraPosition": {
    src: ShaderSource.S_CAMERA_POSITION_SRC,
    pattern: /Context.CameraPosition/,
    pattern2: /Context.CameraPosition[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.CameraPosition/g,
    tag: ShaderSource.S_CAMERA_POSITION_SRC,
    def: 'VIEW'
  },
  "Context.WGIProbe": {
    src: ShaderSource.S_WGIPROBE_SRC,
    pattern: /Context.WGIProbe/,
    pattern2: /Context.WGIProbe[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.WGIProbe/g,
    tag: ShaderSource.S_WGIPROBE_SRC,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.ShCoeffs": {
    src: ShaderSource.S_SH_COEFFS_SRC,
    pattern: /Context.ShCoeffs/,
    pattern2: /Context.ShCoeffs[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ShCoeffs/g,
    tag: ShaderSource.S_SH_COEFFS_SRC,
    type: "vec3",
    utype: "uniform vec3",
    modifier: '[' + 9 + ']'
  },
  // 输入类型缓存
  "Context.InGBuffer0": {
    src: ShaderSource.S_G_BUFFER0_SRC,
    pattern: /Context.InGBuffer0/,
    pattern2: /Context.InGBuffer0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InGBuffer0/g,
    tag: ShaderSource.S_G_BUFFER0_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InGBuffer1": {
    src: ShaderSource.S_G_BUFFER1_SRC,
    pattern: /Context.InGBuffer1/,
    pattern2: /Context.InGBuffer1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InGBuffer1/g,
    tag: ShaderSource.S_G_BUFFER1_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InGBuffer2": {
    src: ShaderSource.S_G_BUFFER2_SRC,
    pattern: /Context.InGBuffer2/,
    pattern2: /Context.InGBuffer2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InGBuffer2/g,
    tag: ShaderSource.S_G_BUFFER2_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InGDepth": {
    src: ShaderSource.S_G_DEPTH_SRC,
    pattern: /Context.InGDepth/,
    pattern2: /Context.InGDepth[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InGDepth/g,
    tag: ShaderSource.S_G_DEPTH_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InScreen": {
    src: ShaderSource.S_IN_SCREEN_SRC,
    pattern: /Context.InScreen/,
    pattern2: /Context.InScreen[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InScreen/g,
    tag: ShaderSource.S_IN_SCREEN_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InDepth": {
    src: ShaderSource.S_IN_DEPTH_SRC,
    pattern: /Context.InDepth/,
    pattern2: /Context.InDepth[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InDepth/g,
    tag: ShaderSource.S_IN_DEPTH_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InForwardColorMap": {
    src: ShaderSource.S_FORWARD_COLOR_MAP_SRC,
    pattern: /Context.InForwardColorMap/,
    pattern2: /Context.InForwardColorMap[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InForwardColorMap/g,
    tag: ShaderSource.S_FORWARD_COLOR_MAP_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D",
    flag: "renderData"
  },
  "Context.InPrefEnvMap": {
    src: ShaderSource.S_PREF_ENV_MAP_SRC,
    pattern: /Context.InPrefEnvMap/,
    pattern2: /Context.InPrefEnvMap[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InPrefEnvMap/g,
    tag: ShaderSource.S_PREF_ENV_MAP_SRC,
    type: "samplerCube",
    utype: "uniform samplerCube"
  },
  "Context.InTileLightDecode": {
    src: ShaderSource.S_TILE_LIGHT_DECODE_SRC,
    pattern: /Context.InTileLightDecode/,
    pattern2: /Context.InTileLightDecode[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileLightDecode/g,
    tag: ShaderSource.S_TILE_LIGHT_DECODE_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileLightIndex": {
    src: ShaderSource.S_TILE_LIGHT_INDEX_SRC,
    pattern: /Context.InTileLightIndex/,
    pattern2: /Context.InTileLightIndex[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileLightIndex/g,
    tag: ShaderSource.S_TILE_LIGHT_INDEX_SRC,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileWLightData0": {
    src: ShaderSource.S_TILE_W_LIGHT_DATA_0,
    pattern: /Context.InTileWLightData0/,
    pattern2: /Context.InTileWLightData0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileWLightData0/g,
    tag: ShaderSource.S_TILE_W_LIGHT_DATA_0,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileVLightData0": {
    src: ShaderSource.S_TILE_V_LIGHT_DATA_0,
    pattern: /Context.InTileVLightData0/,
    pattern2: /Context.InTileVLightData0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileVLightData0/g,
    tag: ShaderSource.S_TILE_V_LIGHT_DATA_0,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileWLightData1": {
    src: ShaderSource.S_TILE_W_LIGHT_DATA_1,
    pattern: /Context.InTileWLightData1/,
    pattern2: /Context.InTileWLightData1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileWLightData1/g,
    tag: ShaderSource.S_TILE_W_LIGHT_DATA_1,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileVLightData1": {
    src: ShaderSource.S_TILE_V_LIGHT_DATA_1,
    pattern: /Context.InTileVLightData1/,
    pattern2: /Context.InTileVLightData1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileVLightData1/g,
    tag: ShaderSource.S_TILE_V_LIGHT_DATA_1,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileWLightData2": {
    src: ShaderSource.S_TILE_W_LIGHT_DATA_2,
    pattern: /Context.InTileWLightData2/,
    pattern2: /Context.InTileWLightData2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileWLightData2/g,
    tag: ShaderSource.S_TILE_W_LIGHT_DATA_2,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InTileVLightData2": {
    src: ShaderSource.S_TILE_V_LIGHT_DATA_2,
    pattern: /Context.InTileVLightData2/,
    pattern2: /Context.InTileVLightData2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InTileVLightData2/g,
    tag: ShaderSource.S_TILE_V_LIGHT_DATA_2,
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap0": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[0],
    pattern: /Context.InShadowMap0/,
    pattern2: /Context.InShadowMap0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap0/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[0],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap1": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[1],
    pattern: /Context.InShadowMap1/,
    pattern2: /Context.InShadowMap1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap1/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[1],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap2": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[2],
    pattern: /Context.InShadowMap2/,
    pattern2: /Context.InShadowMap2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap2/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[2],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap3": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[3],
    pattern: /Context.InShadowMap3/,
    pattern2: /Context.InShadowMap3[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap3/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[3],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap4": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[4],
    pattern: /Context.InShadowMap4/,
    pattern2: /Context.InShadowMap4[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap4/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[4],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap5": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[5],
    pattern: /Context.InShadowMap5/,
    pattern2: /Context.InShadowMap5[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap5/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[5],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.InShadowMap6": {
    src: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[6],
    pattern: /Context.InShadowMap6/,
    pattern2: /Context.InShadowMap6[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.InShadowMap6/g,
    tag: ShaderSource.S_SHADOW_MAP_ARRAY_SRC[6],
    type: "sampler2D",
    utype: "uniform sampler2D"
  },
  "Context.LightViewProjectMatrix0": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[0],
    pattern: /Context.LightViewProjectMatrix0/,
    pattern2: /Context.LightViewProjectMatrix0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix0/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[0],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix1": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[1],
    pattern: /Context.LightViewProjectMatrix1/,
    pattern2: /Context.LightViewProjectMatrix1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix1/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[1],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix2": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[2],
    pattern: /Context.LightViewProjectMatrix2/,
    pattern2: /Context.LightViewProjectMatrix2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix2/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[2],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix3": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[3],
    pattern: /Context.LightViewProjectMatrix3/,
    pattern2: /Context.LightViewProjectMatrix3[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix3/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[3],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix4": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[4],
    pattern: /Context.LightViewProjectMatrix4/,
    pattern2: /Context.LightViewProjectMatrix4[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix4/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[4],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix5": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[5],
    pattern: /Context.LightViewProjectMatrix5/,
    pattern2: /Context.LightViewProjectMatrix5[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix5/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[5],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightViewProjectMatrix6": {
    src: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[6],
    pattern: /Context.LightViewProjectMatrix6/,
    pattern2: /Context.LightViewProjectMatrix6[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightViewProjectMatrix6/g,
    tag: ShaderSource.S_LIGHT_SHADOW_VP_ARRAY_SRC[6],
    type: "mat4",
    utype: "uniform mat4"
  },
  "Context.LightDir": {
    src: ShaderSource.S_LIGHT_DIR,
    pattern: /Context.LightDir/,
    pattern2: /Context.LightDir[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightDir/g,
    tag: ShaderSource.S_LIGHT_DIR,
    type: "vec3",
    utype: "uniform vec3"
  },
  "Context.LightPos": {
    src: ShaderSource.S_LIGHT_POS,
    pattern: /Context.LightPos/,
    pattern2: /Context.LightPos[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.LightPos/g,
    tag: ShaderSource.S_LIGHT_POS,
    type: "vec3",
    utype: "uniform vec3"
  },
  "Context.Splits": {
    src: ShaderSource.S_SPLITS,
    pattern: /Context.Splits/,
    pattern2: /Context.Splits[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Splits/g,
    tag: ShaderSource.S_SPLITS,
    type: "vec4",
    utype: "uniform vec4"
  },
  "Context.Fadeinfo": {
    src: ShaderSource.S_FADEINFO,
    pattern: /Context.Fadeinfo/,
    pattern2: /Context.Fadeinfo[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Fadeinfo/g,
    tag: ShaderSource.S_FADEINFO,
    type: "vec2",
    utype: "uniform vec2"
  },
  "Context.ResolutionInverse": {
    src: ShaderSource.S_RESOLUTION_INVERSE,
    pattern: /Context.ResolutionInverse/,
    pattern2: /Context.ResolutionInverse[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ResolutionInverse/g,
    tag: ShaderSource.S_RESOLUTION_INVERSE,
    type: "vec2",
    utype: "uniform vec2"
  },
  "Context.ShadowMapSize": {
    src: ShaderSource.S_SHADOW_MAP_SIZE,
    pattern: /Context.ShadowMapSize/,
    pattern2: /Context.ShadowMapSize[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.ShadowMapSize/g,
    tag: ShaderSource.S_SHADOW_MAP_SIZE,
    type: "float",
    utype: "uniform float"
  },
  "Context.SMapSizeInverse": {
    src: ShaderSource.S_SHADOW_MAP_SIZE_INVERSE,
    pattern: /Context.SMapSizeInverse/,
    pattern2: /Context.SMapSizeInverse[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.SMapSizeInverse/g,
    tag: ShaderSource.S_SHADOW_MAP_SIZE_INVERSE,
    type: "vec2",
    utype: "uniform vec2"
  },
  // 输出类型缓存
  "Context.OutGBuffer0": {
    src: ShaderSource.S_G_BUFFER0_SRC,
    loc: ShaderSource.S_G_BUFFER0,
    pattern: /Context.OutGBuffer0/,
    pattern2: /Context.OutGBuffer0[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutGBuffer0/g,
    tag: ShaderSource.S_G_BUFFER0_SRC,
    type: "vec4"
  },
  "Context.OutGBuffer1": {
    src: ShaderSource.S_G_BUFFER1_SRC,
    loc: ShaderSource.S_G_BUFFER1,
    pattern: /Context.OutGBuffer1/,
    pattern2: /Context.OutGBuffer1[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutGBuffer1/g,
    tag: ShaderSource.S_G_BUFFER1_SRC,
    type: "vec4"
  },
  "Context.OutGBuffer2": {
    src: ShaderSource.S_G_BUFFER2_SRC,
    loc: ShaderSource.S_G_BUFFER2,
    pattern: /Context.OutGBuffer2/,
    pattern2: /Context.OutGBuffer2[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutGBuffer2/g,
    tag: ShaderSource.S_G_BUFFER2_SRC,
    type: "vec4"
  },
  "Context.OutGDepth": {
    src: ShaderSource.S_G_DEPTH_SRC,
    loc: ShaderSource.S_G_DEPTH,
    pattern: /Context.OutGDepth/,
    pattern2: /Context.OutGDepth[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.OutGDepth/g,
    tag: ShaderSource.S_G_DEPTH_SRC,
    type: "vec4"
  },
  // 全局变量
  "Context.Skins": {
    src: ShaderSource.S_SKINS_SRC,
    pattern: /Context.Skins/,
    pattern2: /Context.Skins[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Skins/g,
    tag: ShaderSource.S_SKINS_SRC,
    isFlagVariable: true
  },
  "Context.Srgb": {
    src: ShaderSource.S_SRGB_SRC,
    pattern: /Context.Srgb/,
    pattern2: /Context.Srgb[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Srgb/g,
    tag: ShaderSource.S_SRGB_SRC,
    isFlagVariable: true
  },
  "Context.GIProbes": {
    src: ShaderSource.S_GIPROBES_SRC,
    pattern: /Context.GIProbes/,
    pattern2: /Context.GIProbes[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.GIProbes/g,
    tag: ShaderSource.S_GIPROBES_SRC,
    isFlagVariable: true
  },
  "Context.Pssm": {
    src: ShaderSource.S_PSSM_SRC,
    pattern: /Context.Pssm/,
    pattern2: /Context.Pssm[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Pssm/g,
    tag: ShaderSource.S_PSSM_SRC,
    isFlagVariable: true
  },
  "Context.PointLightShadows": {
    src: ShaderSource.S_POINTLIGHT_SHADOWS_SRC,
    pattern: /Context.PointLightShadows/,
    pattern2: /Context.PointLightShadows[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.PointLightShadows/g,
    tag: ShaderSource.S_POINTLIGHT_SHADOWS_SRC,
    isFlagVariable: true
  },
  "Context.SpotLightShadows": {
    src: ShaderSource.S_SPOTLIGHT_SHADOWS_SRC,
    pattern: /Context.SpotLightShadows/,
    pattern2: /Context.SpotLightShadows[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.SpotLightShadows/g,
    tag: ShaderSource.S_SPOTLIGHT_SHADOWS_SRC,
    isFlagVariable: true
  },
  "Context.Fade": {
    src: ShaderSource.S_FADE_SRC,
    pattern: /Context.Fade/,
    pattern2: /Context.Fade[\s+-;.,\*\\]{1,}/,
    tagPattern: /Context.Fade/g,
    tag: ShaderSource.S_FADE_SRC,
    isFlagVariable: true
  },
  // 上下文定义
  '_C_SKINS': "#define " + ShaderSource.S_SKINS_SRC + " " + ShaderSource.S_SKINS_SRC,
  '_C_SRGB': "#define " + ShaderSource.S_SRGB_SRC + " " + ShaderSource.S_SRGB_SRC,
  '_C_GIPROBES': "#define " + ShaderSource.S_GIPROBES_SRC + " " + ShaderSource.S_GIPROBES_SRC,
  '_C_PSSM': "#define " + ShaderSource.S_PSSM_SRC + " " + ShaderSource.S_PSSM_SRC,
  '_C_POINTLIGHT_SHADOWS': "#define " + ShaderSource.S_POINTLIGHT_SHADOWS_SRC + " " + ShaderSource.S_POINTLIGHT_SHADOWS_SRC,
  '_C_SPOTLIGHT_SHADOWS': "#define " + ShaderSource.S_SPOTLIGHT_SHADOWS_SRC + " " + ShaderSource.S_SPOTLIGHT_SHADOWS_SRC,
  '_FADE': "#define " + ShaderSource.S_FADE_SRC + " " + ShaderSource.S_FADE_SRC
});

/***/ }),

/***/ 2228:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * SizeOf。<br/>
 * 提供获取GL数据长度的枚举。<br/>
 * @author Kkk
 * @date 2021年3月14日13点26分
 */
var SizeOf = /*#__PURE__*/function () {
  function SizeOf() {
    _classCallCheck(this, SizeOf);
  }

  _createClass(SizeOf, null, [{
    key: "sizeof",
    value: function sizeof(src) {
      switch (src) {
        case SizeOf.S_UNSIGNED_SHORT:
          return 2;
      }

      return -1;
    }
  }]);

  return SizeOf;
}();

exports["default"] = SizeOf;

_defineProperty(SizeOf, "S_UNSIGNED_SHORT", 0x001);

/***/ }),

/***/ 2584:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Texture = /*#__PURE__*/function () {
  function Texture(name, loc, internalformat, w, h, border, format, type, data) {
    _classCallCheck(this, Texture);

    this._m_Name = name;
    this._m_Loc = loc;
    this._m_InternalFormat = internalformat;
    this._m_Widht = w;
    this._m_Height = h;
    this._m_Border = border;
    this._m_Format = format;
    this._m_Type = type;
    this._m_Data = data;
  }

  _createClass(Texture, [{
    key: "setName",
    value: function setName(name) {
      this._m_Name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this._m_Name;
    }
  }, {
    key: "setLoc",
    value: function setLoc(loc) {
      this._m_Loc = loc;
    }
  }, {
    key: "getLoc",
    value: function getLoc() {
      return this._m_Loc;
    }
  }, {
    key: "setInternalFormat",
    value: function setInternalFormat(internalFormat) {
      this._m_InternalFormat = internalFormat;
    }
  }, {
    key: "getInternalFormat",
    value: function getInternalFormat() {
      return this._m_InternalFormat;
    }
  }, {
    key: "setWidth",
    value: function setWidth(w) {
      this._m_Widht = w;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this._m_Widht;
    }
  }, {
    key: "setHeihgt",
    value: function setHeihgt(h) {
      this._m_Height = h;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this._m_Height;
    }
  }, {
    key: "setBorder",
    value: function setBorder(border) {
      this._m_Border = border;
    }
  }, {
    key: "getBorder",
    value: function getBorder() {
      return this._m_Border;
    }
  }, {
    key: "setFormat",
    value: function setFormat(format) {
      this._m_Format = format;
    }
  }, {
    key: "getFormat",
    value: function getFormat() {
      return this._m_Format;
    }
  }, {
    key: "setType",
    value: function setType(type) {
      this._m_Type = type;
    }
  }, {
    key: "getType",
    value: function getType() {
      return this._m_Type;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      this._m_Data = data;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this._m_Data;
    }
  }]);

  return Texture;
}();

exports["default"] = Texture;

/***/ }),

/***/ 1446:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 对Uniform数据的封装。<br/>
 * @author Kkk
 * @date 2021年2月18日15点49分
 */
var UniformBuffer = /*#__PURE__*/function () {
  function UniformBuffer(l) {
    _classCallCheck(this, UniformBuffer);

    this._m_Buffer = new Float32Array(l);
    this._m_Array = new Array(l).fill(0);
  }
  /**
   * 返回当前数据数组。<br/>
   * @return {any[] | *}
   */


  _createClass(UniformBuffer, [{
    key: "getArray",
    value: function getArray() {
      return this._m_Array;
    }
    /**
     * 返回当前数据缓存。<br/>
     * @return {Float32Array}
     */

  }, {
    key: "getBufferData",
    value: function getBufferData() {
      this._m_Buffer.set(this._m_Array);

      return this._m_Buffer;
    }
  }]);

  return UniformBuffer;
}();

exports["default"] = UniformBuffer;

/***/ }),

/***/ 6140:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 对Uniform数据的封装。<br/>
 * @author Kkk
 * @date 2021年2月18日15点49分
 */
var UniformBufferI = /*#__PURE__*/function () {
  function UniformBufferI(l) {
    _classCallCheck(this, UniformBufferI);

    this._m_Buffer = new Uint8Array(l);
    this._m_Array = new Array(l).fill(0);
  }
  /**
   * 返回当前数据数组。<br/>
   * @return {any[] | *}
   */


  _createClass(UniformBufferI, [{
    key: "getArray",
    value: function getArray() {
      return this._m_Array;
    }
    /**
     * 返回当前数据缓存。<br/>
     * @return {Float32Array}
     */

  }, {
    key: "getBufferData",
    value: function getBufferData() {
      this._m_Buffer.set(this._m_Array);

      return this._m_Buffer;
    }
  }]);

  return UniformBufferI;
}();

exports["default"] = UniformBufferI;

/***/ }),

/***/ 1491:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * BoolVars。<br/>
 * 布尔变量。<br/>
 * @author Kkk
 * @date 2021年3月19日21点44分
 */
var BoolVars = /*#__PURE__*/function (_Vars) {
  _inherits(BoolVars, _Vars);

  var _super = _createSuper(BoolVars);

  function BoolVars(props) {
    var _this;

    _classCallCheck(this, BoolVars);

    _this = _super.call(this, props);
    _this._m_Bool = false;
    return _this;
  }

  _createClass(BoolVars, [{
    key: "valueOf",
    value: function valueOf(bool) {
      this._m_Bool = bool;
      return this;
    }
    /**
     * 比较值。<br/>
     * @param {BoolVars}[boolVars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(boolVars) {
      // return this._m_Bool == boolVars._m_Bool;
      return false;
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.uniform1i(loc, this._m_Bool);
    }
  }]);

  return BoolVars;
}(_Vars2.default);

exports["default"] = BoolVars;

/***/ }),

/***/ 1759:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * FloatVars。<br/>
 * Float变量。<br/>
 * @author Kkk
 * @date 2021年3月15日20点43分
 */
var FloatVars = /*#__PURE__*/function (_Vars) {
  _inherits(FloatVars, _Vars);

  var _super = _createSuper(FloatVars);

  function FloatVars(props) {
    var _this;

    _classCallCheck(this, FloatVars);

    _this = _super.call(this, props);
    _this._m_Float = 0;
    return _this;
  }

  _createClass(FloatVars, [{
    key: "valueOf",
    value: function valueOf(float) {
      this._m_Float = float;
      return this;
    }
    /**
     * 比较值。<br/>
     * @param {FloatVars}[floatVars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(floatVars) {
      // return this._m_Float == floatVars._m_Float;
      return false;
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.uniform1f(loc, this._m_Float);
    }
  }]);

  return FloatVars;
}(_Vars2.default);

exports["default"] = FloatVars;

/***/ }),

/***/ 1359:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

var _UniformBufferI = _interopRequireDefault(__webpack_require__(6140));

var _UniformBuffer = _interopRequireDefault(__webpack_require__(1446));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Texture2DTargetVars。<br/>
 * 表示目标纹理对象，通常其用于包装FrameBuffer中的纹理附件数据。<br/>
 * @author Kkk
 * @date 2021年9月18日12点10分
 */
var Texture2DTargetVars = /*#__PURE__*/function (_Vars) {
  _inherits(Texture2DTargetVars, _Vars);

  var _super = _createSuper(Texture2DTargetVars);

  // static _S_TEMP_COLOR = new UniformBufferI(4);
  // 纹理滤波常量
  // 纹理参数常量
  // 纹理格式
  function Texture2DTargetVars(scene) {
    var _this;

    _classCallCheck(this, Texture2DTargetVars);

    _this = _super.call(this, scene);

    _defineProperty(_assertThisInitialized(_this), "_m_Target", void 0);

    _this._m_Scene = scene;
    var gl = scene.getCanvas().getGLContext();
    Texture2DTargetVars.S_TEXTURE_FORMAT = {
      S_RGB: gl.RGB,
      S_RGBA: gl.RGBA,
      S_RGB16F: gl.RGB16F,
      S_RGB32F: gl.RGB32F,
      S_RGBA16F: gl.RGBA16F,
      S_RGBA32F: gl.RGBA32F,
      S_RGBE5: gl.RGB9_E5,
      S_SRGB: gl.SRGB,
      S_SRGB8: gl.SRGB8,
      S_SRGBA: gl.SRGB8_ALPHA8,
      S_DEPTH_COMPONENT24: gl.DEPTH_COMPONENT24,
      S_DEPTH_COMPONENT: gl.DEPTH_COMPONENT,
      S_SHORT: gl.SHORT,
      S_INT: gl.INT,
      S_BYTE: gl.BYTE,
      S_UNSIGNED_BYTE: gl.UNSIGNED_BYTE,
      S_FLOAT: gl.FLOAT
    }; // 创建纹理目标

    _this._m_Texture = gl.createTexture(); // 设置默认纹理滤波

    _this._setFilter(scene, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    _this._setFilter(scene, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 内部格式（默认为RGBA）


    _this._m_Internalformat = gl.RGBA16F; // 外部格式（默认为RGBA）

    _this._m_Format = gl.RGBA; // 数据类型

    _this._m_Type = gl.FLOAT; // 数据更新标记

    _this._m_UpdateImage = false;
    _this._m_Image = null;
    _this._m_Rgbe = false;
    _this._m_Width = _this._m_Scene.getCanvas().getWidth();
    _this._m_Height = _this._m_Scene.getCanvas().getHeight(); // 翻转y(需要在设置图像之前设置)

    _this._m_FlipY = false; // 默认4字节对齐

    _this._m_Alignment = 4;
    _this._m_WrapS = null;
    _this._m_WrapT = null;
    _this._m_MinFilter = Texture2DTargetVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST;
    _this._m_MagFilter = Texture2DTargetVars.S_FILTERS.S_LINEAR;
    return _this;
  }
  /**
   * 关联渲染目标。<br/>
   * @param {Object}[target]
   */


  _createClass(Texture2DTargetVars, [{
    key: "target",
    value: function target(_target) {
      this._m_Target = _target;
    }
    /**
     * 设置纹理格式。<br/>
     * @param {Number}[internalFormat]
     * @param {Number}[format]
     * @param {Number}[type]
     */

  }, {
    key: "setTextureFormat",
    value: function setTextureFormat(internalFormat, format, type) {
      this._m_Internalformat = internalFormat;
      this._m_Format = format;
      this._m_Type = type;
    }
    /**
     * 设置对齐模式。<br/>
     * @param {Number}[alignment]
     */

  }, {
    key: "setAlignment",
    value: function setAlignment(alignment) {
      if (this._m_Alignment != alignment) {
        this._m_Alignment = alignment; // const gl = this._m_Scene.getCanvas().getGLContext();
        // gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
        // gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
        // gl.bindTexture(gl.TEXTURE_2D, null);
      }
    }
    /**
     * 更新纹理滤波设置。<br/>
     */

  }, {
    key: "updateTextureFilter",
    value: function updateTextureFilter() {
      // 设置默认纹理滤波
      var gl = this._m_Scene.getCanvas().getGLContext();

      if (this._m_WrapS) {
        this._setWrap(this._m_Scene, gl.TEXTURE_WRAP_S, this._parseWrap(gl, this._m_WrapS));
      }

      if (this._m_WrapT) {
        this._setWrap(this._m_Scene, gl.TEXTURE_WRAP_T, this._parseWrap(gl, this._m_WrapT));
      }

      if (this._m_MinFilter) {
        this._setFilter(this._m_Scene, gl.TEXTURE_MIN_FILTER, this._parseFilter(gl, this._m_MinFilter));
      }

      if (this._m_MagFilter) {
        this._setFilter(this._m_Scene, gl.TEXTURE_MAG_FILTER, this._parseFilter(gl, this._m_MagFilter));
      }
    }
    /**
     * 直接上载指定数组数据到纹理中。<br/>
     * @param {Number}[loc 纹理地址]
     * @param {Number}[w 纹理数据宽度]
     * @param {Number}[h 纹理数据高度]
     * @param {ArrayBuffer}[data]
     */

  }, {
    key: "uploadArrayData",
    value: function uploadArrayData(loc, w, h, data) {
      var gl = this._m_Scene.getCanvas().getGLContext();

      gl.activeTexture(gl.TEXTURE0 + loc);
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._m_FlipY);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, this._m_Alignment);
      gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, w, h, 0, this._m_Format, this._m_Type, data);
    }
    /**
     * 翻转图像。<br/>
     * 需要在设置图像数据之前设置。<br/>
     * @param {Boolean}[flipY true表示翻转,默认为false]
     */

  }, {
    key: "setFlipY",
    value: function setFlipY(flipY) {
      this._m_FlipY = flipY;
    }
    /**
     * 硬件mipmap。<br/>
     * @param {Scene}[scene]
     */

  }, {
    key: "genMipmap",
    value: function genMipmap(scene) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[minfilter Texture2DTargetVars.S_FILTERS常量枚举之一]
     * @param {Number}[magfilter Texture2DTargetVars.S_FILTERS常量枚举之一]
     */

  }, {
    key: "setFilter",
    value: function setFilter(scene, minfilter, magfilter) {
      this._m_MinFilter = minfilter;
      this._m_MagFilter = magfilter; // const gl = scene.getCanvas().getGLContext();
      // this._setFilter(scene, gl.TEXTURE_MIN_FILTER, this._parseFilter(gl, minfilter));
      // this._setFilter(scene, gl.TEXTURE_MAG_FILTER, this._parseFilter(gl, magfilter));
    }
    /**
     * 解析纹理滤波枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[filterEnum]
     * @return {WebGLObject}
     * @private
     */

  }, {
    key: "_parseFilter",
    value: function _parseFilter(gl, filterEnum) {
      switch (filterEnum) {
        case Texture2DTargetVars.S_FILTERS.S_LINEAR:
          return gl.LINEAR;

        case Texture2DTargetVars.S_FILTERS.S_NEAREST:
          return gl.NEAREST;

        case Texture2DTargetVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST:
          return gl.LINEAR_MIPMAP_NEAREST;

        case Texture2DTargetVars.S_FILTERS.S_LINEAR_MIPMAP_LINEAR:
          return gl.LINEAR_MIPMAP_LINEAR;

        case Texture2DTargetVars.S_FILTERS.S_NEAREST_MIPMAP_LINEAR:
          return gl.NEAREST_MIPMAP_LINEAR;

        case Texture2DTargetVars.S_FILTERS.S_NEAREST_MIPMAP_NEAREST:
          return gl.NEAREST_MIPMAP_NEAREST;
      }

      return null;
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[filter]
     */

  }, {
    key: "_setFilter",
    value: function _setFilter(scene, texEnum, filter) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_2D, texEnum, filter);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[wrapS Texture2DTargetVars.S_WRAP枚举常量之一]
     * @param {Number}[wrapT Texture2DTargetVars.S_WRAP枚举常量之一]
     */

  }, {
    key: "setWrap",
    value: function setWrap(scene, wrapS, wrapT) {
      this._m_WrapS = wrapS;
      this._m_WrapT = wrapT; // const gl = scene.getCanvas().getGLContext();
      // this._setWrap(scene, gl.TEXTURE_WRAP_S, this._parseWrap(gl, wrapS));
      // this._setWrap(scene, gl.TEXTURE_WRAP_T, this._parseWrap(gl, wrapT));
    }
    /**
     * 解析纹理边缘处理枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[wrapEnum]
     * @return {Number}
     * @private
     */

  }, {
    key: "_parseWrap",
    value: function _parseWrap(gl, wrapEnum) {
      switch (wrapEnum) {
        case Texture2DTargetVars.S_WRAPS.S_CLAMP:
          return gl.CLAMP;

        case Texture2DTargetVars.S_WRAPS.S_REPEAT:
          return gl.REPEAT;

        case Texture2DTargetVars.S_WRAPS.S_CLAMP_TO_EDGE:
          return gl.CLAMP_TO_EDGE;

        case Texture2DTargetVars.S_WRAPS.S_CLAMP_TO_BORDER:
          return gl.CLAMP_TO_BORDER;
      }

      return null;
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[wrap]
     * @private
     */

  }, {
    key: "_setWrap",
    value: function _setWrap(scene, texEnum, wrap) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_2D, texEnum, wrap);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置预设颜色值,由于web纹理需要异步加载,所以可以提供一个预设颜色纹理。<br/>
     * @param {Scene}[scene]
     * @param {Vector4}[value]
     */

  }, {
    key: "setPreloadColor",
    value: function setPreloadColor(scene, value) {
      var color = Texture2DTargetVars._S_TEMP_COLOR.getArray();

      if (!value) {
        color[0] = 0;
        color[1] = 0;
        color[2] = 0;
        color[3] = 255;
      } else {
        color[0] = Math.floor(value._m_X * 255);
        color[1] = Math.floor(value._m_Y * 255);
        color[2] = Math.floor(value._m_Z * 255);
        color[3] = Math.floor(value._m_W * 255);
      }

      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, 1, 1, 0, this._m_Format, this._m_Type, Texture2DTargetVars._S_TEMP_COLOR.getBufferData());
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理图素路径。<br/>
     * @param {Scene}[scene]
     * @param {String}[src]
     * @param {Boolean}[options.linearFloat 表示rgbe数据的辐射度纹理为线性空间]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     */

  }, {
    key: "setImageSrc",
    value: function setImageSrc(scene, src, options) {
      var _this2 = this;

      // 加载完毕设置纹理图素
      var image = options && options.rgbe ? RadianceLoader.rgbeImg() : new Image();

      image.onload = function () {
        // 某些图形驱动api规范仅支持2的幂次方
        // image = Tools.ensureImageSizePowerOfTwo(image, scene.getCanvas());
        _this2._m_Image = options && options.rgbe ? options.linearFloat ? image.dataFloat : image.dataRGBE : image;

        if (options && options.rgbe) {
          _this2._m_Rgbe = true;
        }

        _this2._m_Width = image.width;
        _this2._m_Height = image.height;
        _this2._m_UpdateImage = true; // //self._image = image; // 为了更快的 WebGL 上下文恢复 - 内存效率低下
        // this.setImage(scene, image);
        // // 为该image生成硬件mipmap
        // this.genMipmap(scene);
        // // 设置默认纹理滤波
        // const gl = scene.getCanvas().getGLContext();
        // this.setFilter(scene, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        // this.setFilter(scene, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        // 刷新所有材质持有

        for (var owner in _this2._m_OwnerFlags) {
          _this2._m_OwnerFlags[owner].owner.setParam(_this2._m_OwnerFlags[owner].flag, _this2);
        }
      };

      image.src = src;
    }
    /**
     * 直接设置已加载的图像数据。<br/>
     * @param {Scene}[scene]
     * @param {BufferData}[imgData]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     * @param {Boolean}[options.linearFloat 表示rgbe数据的辐射度纹理为线性空间]
     * @param {Number}[options.width 当imgData是二进制数据数组时,需要单独设置纹理宽度]
     * @param {Number}[options.height 当imgData是二进制数据数组时,需要单独设置纹理高度]
     */

  }, {
    key: "setImage",
    value: function setImage(scene, imgData, options) {
      this._m_Image = options && options.rgbe ? options.linearFloat ? imgData.dataFloat : imgData.dataRGBE : imgData;

      if (options && options.rgbe) {
        this._m_Rgbe = true;
      }

      this._m_Width = options && options.width != null ? options.width : imgData.width;
      this._m_Height = options && options.height != null ? options.height : imgData.height;
      this._m_UpdateImage = true; // 刷新所有材质持有

      for (var owner in this._m_OwnerFlags) {
        this._m_OwnerFlags[owner].owner.setParam(this._m_OwnerFlags[owner].flag, this);
      }
    }
    /**
     * 设置纹理的图素数据。<br/>
     * @param {Scene}[scene]
     * @param {ImgData}[image]
     * @param props
     */

  }, {
    key: "_setImage",
    value: function _setImage(scene, image, props) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._m_FlipY);

      if (this._m_Rgbe) {
        gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, this._m_Width, this._m_Height, 0, this._m_Format, this._m_Type, image);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, this._m_Width, this._m_Height, 0, this._m_Format, this._m_Type, image);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.activeTexture(gl.TEXTURE0 + loc);
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);

      if (this._m_Target) {
        var frameContext = this._m_Scene.getRender().getFrameContext();

        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._m_Target.getFrameBuffer()); // 某些图形驱动api规范仅支持2的
        //self._image = image; // 为了更快地恢复WebGL上下文-内存效率低下？
        // this._setImage(this._m_Scene, this._m_Image);
        // gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, this._m_Scene.getCanvas().getWidth(), this._m_Scene.getCanvas().getHeight(), 0, this._m_Format, this._m_Type, null);

        gl.copyTexImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, 0, 0, this._m_Target._m_Width, this._m_Target._m_Height, 0); // 为该image生成硬件mipmap

        if (this._m_MinFilter != Texture2DTargetVars.S_FILTERS.S_NEAREST && this._m_MinFilter != Texture2DTargetVars.S_FILTERS.S_LINEAR) {// this.genMipmap(this._m_Scene);
        } // this.updateTextureFilter();


        gl.bindFramebuffer(gl.FRAMEBUFFER, frameContext.m_LastFrameBuffer);
      }
    }
    /**
     * 暂时未想好比较方式。<br/>
     * @param {Texture2DTargetVars}[texture2DTargetVars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(texture2DTargetVars) {
      return false;
    }
  }]);

  return Texture2DTargetVars;
}(_Vars2.default);

exports["default"] = Texture2DTargetVars;

_defineProperty(Texture2DTargetVars, "_S_TEMP_COLOR", new _UniformBuffer.default(4));

_defineProperty(Texture2DTargetVars, "S_FILTERS", {
  S_NEAREST: 0x001,
  S_LINEAR: 0x002,
  S_LINEAR_MIPMAP_NEAREST: 0x003,
  S_NEAREST_MIPMAP_LINEAR: 0x004,
  S_LINEAR_MIPMAP_LINEAR: 0x005,
  S_NEAREST_MIPMAP_NEAREST: 0x006
});

_defineProperty(Texture2DTargetVars, "S_WRAPS", {
  S_REPEAT: 0x001,
  S_CLAMP: 0X002,
  S_CLAMP_TO_EDGE: 0x003,
  S_CLAMP_TO_BORDER: 0x004
});

_defineProperty(Texture2DTargetVars, "S_TEXTURE_FORMAT", {});

/***/ }),

/***/ 5141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

var _UniformBufferI = _interopRequireDefault(__webpack_require__(6140));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _RadianceLoader = _interopRequireDefault(__webpack_require__(6797));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Texture2DVars。<br/>
 * 表示2D纹理数据。<br/>
 * @author Kkk
 * @date 2021年3月3日16点39分
 * @lastdate 2021年3月17日14点53分
 */
var Texture2DVars = /*#__PURE__*/function (_Vars) {
  _inherits(Texture2DVars, _Vars);

  var _super = _createSuper(Texture2DVars);

  // 纹理滤波常量
  // 纹理参数常量
  // 纹理格式
  function Texture2DVars(scene) {
    var _this;

    _classCallCheck(this, Texture2DVars);

    _this = _super.call(this, scene);
    _this._m_Scene = scene;
    var gl = scene.getCanvas().getGLContext();
    Texture2DVars.S_TEXTURE_FORMAT = {
      S_RGB: gl.RGB,
      S_RGBA: gl.RGBA,
      S_RGB16F: gl.RGB16F,
      S_RGB32F: gl.RGB32F,
      S_RGBA16F: gl.RGBA16F,
      S_RGBA32F: gl.RGBA32F,
      S_RGBE5: gl.RGB9_E5,
      S_SRGB: gl.SRGB,
      S_SRGB8: gl.SRGB8,
      S_SRGBA: gl.SRGB8_ALPHA8,
      S_SHORT: gl.SHORT,
      S_INT: gl.INT,
      S_BYTE: gl.BYTE,
      S_UNSIGNED_BYTE: gl.UNSIGNED_BYTE,
      S_FLOAT: gl.FLOAT
    }; // 创建纹理目标

    _this._m_Texture = gl.createTexture(); // 设置默认纹理滤波

    _this._setFilter(scene, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    _this._setFilter(scene, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 内部格式（默认为RGBA）


    _this._m_Internalformat = gl.RGBA; // 外部格式（默认为RGBA）

    _this._m_Format = gl.RGBA; // 数据类型

    _this._m_Type = gl.UNSIGNED_BYTE; // 数据更新标记

    _this._m_UpdateImage = false;
    _this._m_Image = null;
    _this._m_Rgbe = false;
    _this._m_Width = -1;
    _this._m_Height = -1; // 翻转y(需要在设置图像之前设置)

    _this._m_FlipY = false; // 默认4字节对齐

    _this._m_Alignment = 4;
    _this._m_WrapS = null;
    _this._m_WrapT = null;
    _this._m_MinFilter = Texture2DVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST;
    _this._m_MagFilter = Texture2DVars.S_FILTERS.S_LINEAR;
    return _this;
  }
  /**
   * 设置纹理格式。<br/>
   * @param {Number}[internalFormat]
   * @param {Number}[format]
   * @param {Number}[type]
   */


  _createClass(Texture2DVars, [{
    key: "setTextureFormat",
    value: function setTextureFormat(internalFormat, format, type) {
      this._m_Internalformat = internalFormat;
      this._m_Format = format;
      this._m_Type = type;
    }
    /**
     * 设置对齐模式。<br/>
     * @param {Number}[alignment]
     */

  }, {
    key: "setAlignment",
    value: function setAlignment(alignment) {
      if (this._m_Alignment != alignment) {
        this._m_Alignment = alignment; // const gl = this._m_Scene.getCanvas().getGLContext();
        // gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
        // gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
        // gl.bindTexture(gl.TEXTURE_2D, null);
      }
    }
    /**
     * 更新纹理滤波设置。<br/>
     */

  }, {
    key: "updateTextureFilter",
    value: function updateTextureFilter() {
      // 设置默认纹理滤波
      var gl = this._m_Scene.getCanvas().getGLContext();

      if (this._m_WrapS) {
        this._setWrap(this._m_Scene, gl.TEXTURE_WRAP_S, this._parseWrap(gl, this._m_WrapS));
      }

      if (this._m_WrapT) {
        this._setWrap(this._m_Scene, gl.TEXTURE_WRAP_T, this._parseWrap(gl, this._m_WrapT));
      }

      if (this._m_MinFilter) {
        this._setFilter(this._m_Scene, gl.TEXTURE_MIN_FILTER, this._parseFilter(gl, this._m_MinFilter));
      }

      if (this._m_MagFilter) {
        this._setFilter(this._m_Scene, gl.TEXTURE_MAG_FILTER, this._parseFilter(gl, this._m_MagFilter));
      }
    }
    /**
     * 直接上载指定数组数据到纹理中。<br/>
     * @param {Number}[loc 纹理地址]
     * @param {Number}[w 纹理数据宽度]
     * @param {Number}[h 纹理数据高度]
     * @param {ArrayBuffer}[data]
     */

  }, {
    key: "uploadArrayData",
    value: function uploadArrayData(loc, w, h, data) {
      var gl = this._m_Scene.getCanvas().getGLContext();

      gl.activeTexture(gl.TEXTURE0 + loc);
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._m_FlipY);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, this._m_Alignment);
      gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, w, h, 0, this._m_Format, this._m_Type, data);
    }
    /**
     * 翻转图像。<br/>
     * 需要在设置图像数据之前设置。<br/>
     * @param {Boolean}[flipY true表示翻转,默认为false]
     */

  }, {
    key: "setFlipY",
    value: function setFlipY(flipY) {
      this._m_FlipY = flipY;
    }
    /**
     * 硬件mipmap。<br/>
     * @param {Scene}[scene]
     */

  }, {
    key: "genMipmap",
    value: function genMipmap(scene) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[minfilter Texture2DVars.S_FILTERS常量枚举之一]
     * @param {Number}[magfilter Texture2DVars.S_FILTERS常量枚举之一]
     */

  }, {
    key: "setFilter",
    value: function setFilter(scene, minfilter, magfilter) {
      this._m_MinFilter = minfilter;
      this._m_MagFilter = magfilter; // const gl = scene.getCanvas().getGLContext();
      // this._setFilter(scene, gl.TEXTURE_MIN_FILTER, this._parseFilter(gl, minfilter));
      // this._setFilter(scene, gl.TEXTURE_MAG_FILTER, this._parseFilter(gl, magfilter));
    }
    /**
     * 解析纹理滤波枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[filterEnum]
     * @return {WebGLObject}
     * @private
     */

  }, {
    key: "_parseFilter",
    value: function _parseFilter(gl, filterEnum) {
      switch (filterEnum) {
        case Texture2DVars.S_FILTERS.S_LINEAR:
          return gl.LINEAR;

        case Texture2DVars.S_FILTERS.S_NEAREST:
          return gl.NEAREST;

        case Texture2DVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST:
          return gl.LINEAR_MIPMAP_NEAREST;

        case Texture2DVars.S_FILTERS.S_LINEAR_MIPMAP_LINEAR:
          return gl.LINEAR_MIPMAP_LINEAR;

        case Texture2DVars.S_FILTERS.S_NEAREST_MIPMAP_LINEAR:
          return gl.NEAREST_MIPMAP_LINEAR;

        case Texture2DVars.S_FILTERS.S_NEAREST_MIPMAP_NEAREST:
          return gl.NEAREST_MIPMAP_NEAREST;
      }

      return null;
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[filter]
     */

  }, {
    key: "_setFilter",
    value: function _setFilter(scene, texEnum, filter) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_2D, texEnum, filter);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[wrapS Texture2DVars.S_WRAP枚举常量之一]
     * @param {Number}[wrapT Texture2DVars.S_WRAP枚举常量之一]
     */

  }, {
    key: "setWrap",
    value: function setWrap(scene, wrapS, wrapT) {
      this._m_WrapS = wrapS;
      this._m_WrapT = wrapT; // const gl = scene.getCanvas().getGLContext();
      // this._setWrap(scene, gl.TEXTURE_WRAP_S, this._parseWrap(gl, wrapS));
      // this._setWrap(scene, gl.TEXTURE_WRAP_T, this._parseWrap(gl, wrapT));
    }
    /**
     * 解析纹理边缘处理枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[wrapEnum]
     * @return {Number}
     * @private
     */

  }, {
    key: "_parseWrap",
    value: function _parseWrap(gl, wrapEnum) {
      switch (wrapEnum) {
        case Texture2DVars.S_WRAPS.S_CLAMP:
          return gl.CLAMP;

        case Texture2DVars.S_WRAPS.S_REPEAT:
          return gl.REPEAT;

        case Texture2DVars.S_WRAPS.S_CLAMP_TO_EDGE:
          return gl.CLAMP_TO_EDGE;

        case Texture2DVars.S_WRAPS.S_CLAMP_TO_BORDER:
          return gl.CLAMP_TO_BORDER;
      }

      return null;
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[wrap]
     * @private
     */

  }, {
    key: "_setWrap",
    value: function _setWrap(scene, texEnum, wrap) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_2D, texEnum, wrap);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置预设颜色值,由于web纹理需要异步加载,所以可以提供一个预设颜色纹理。<br/>
     * @param {Scene}[scene]
     * @param {Vector4}[value]
     */

  }, {
    key: "setPreloadColor",
    value: function setPreloadColor(scene, value) {
      var color = Texture2DVars._S_TEMP_COLOR.getArray();

      if (!value) {
        color[0] = 0;
        color[1] = 0;
        color[2] = 0;
        color[3] = 255;
      } else {
        color[0] = Math.floor(value._m_X * 255);
        color[1] = Math.floor(value._m_Y * 255);
        color[2] = Math.floor(value._m_Z * 255);
        color[3] = Math.floor(value._m_W * 255);
      }

      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, 1, 1, 0, this._m_Format, this._m_Type, Texture2DVars._S_TEMP_COLOR.getBufferData());
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    /**
     * 设置纹理图素路径。<br/>
     * @param {Scene}[scene]
     * @param {String}[src]
     * @param {Boolean}[options.linearFloat 表示rgbe数据的辐射度纹理为线性空间]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     */

  }, {
    key: "setImageSrc",
    value: function setImageSrc(scene, src, options) {
      var _this2 = this;

      // 加载完毕设置纹理图素
      var image = options && options.rgbe ? _RadianceLoader.default.rgbeImg() : new Image();

      image.onload = function () {
        // 某些图形驱动api规范仅支持2的幂次方
        // image = Tools.ensureImageSizePowerOfTwo(image, scene.getCanvas());
        _this2._m_Image = options && options.rgbe ? options.linearFloat ? image.dataFloat : image.dataRGBE : image;

        if (options && options.rgbe) {
          _this2._m_Rgbe = true;
        }

        _this2._m_Width = image.width;
        _this2._m_Height = image.height;
        _this2._m_UpdateImage = true; // //self._image = image; // 为了更快的 WebGL 上下文恢复 - 内存效率低下
        // this.setImage(scene, image);
        // // 为该image生成硬件mipmap
        // this.genMipmap(scene);
        // // 设置默认纹理滤波
        // const gl = scene.getCanvas().getGLContext();
        // this.setFilter(scene, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        // this.setFilter(scene, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        // 刷新所有材质持有

        for (var owner in _this2._m_OwnerFlags) {
          _this2._m_OwnerFlags[owner].owner.setParam(_this2._m_OwnerFlags[owner].flag, _this2);
        }
      };

      image.src = src;
    }
    /**
     * 直接设置已加载的图像数据。<br/>
     * @param {Scene}[scene]
     * @param {BufferData}[imgData]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     * @param {Boolean}[options.linearFloat 表示rgbe数据的辐射度纹理为线性空间]
     * @param {Number}[options.width 当imgData是二进制数据数组时,需要单独设置纹理宽度]
     * @param {Number}[options.height 当imgData是二进制数据数组时,需要单独设置纹理高度]
     */

  }, {
    key: "setImage",
    value: function setImage(scene, imgData, options) {
      this._m_Image = options && options.rgbe ? options.linearFloat ? imgData.dataFloat : imgData.dataRGBE : imgData;

      if (options && options.rgbe) {
        this._m_Rgbe = true;
      }

      this._m_Width = options && options.width != null ? options.width : imgData.width;
      this._m_Height = options && options.height != null ? options.height : imgData.height;
      this._m_UpdateImage = true; // 刷新所有材质持有

      for (var owner in this._m_OwnerFlags) {
        this._m_OwnerFlags[owner].owner.setParam(this._m_OwnerFlags[owner].flag, this);
      }
    }
    /**
     * 设置纹理的图素数据。<br/>
     * @param {Scene}[scene]
     * @param {ImgData}[image]
     * @param props
     */

  }, {
    key: "_setImage",
    value: function _setImage(scene, image, props) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._m_FlipY);

      if (this._m_Rgbe) {
        gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, this._m_Width, this._m_Height, 0, this._m_Format, this._m_Type, image);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, this._m_Internalformat, this._m_Width, this._m_Height, 0, this._m_Format, this._m_Type, image);
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.activeTexture(gl.TEXTURE0 + loc);

      if (this._m_UpdateImage) {
        // 某些图形驱动api规范仅支持2的
        //self._image = image; // 为了更快地恢复WebGL上下文-内存效率低下？
        this._setImage(this._m_Scene, this._m_Image); // 为该image生成硬件mipmap


        if (this._m_MinFilter != Texture2DVars.S_FILTERS.S_NEAREST && this._m_MinFilter != Texture2DVars.S_FILTERS.S_LINEAR) {
          this.genMipmap(this._m_Scene);
        }

        this.updateTextureFilter();
        this._m_UpdateImage = false;
        this._m_Image = null;
        this._m_Width = this._m_Height = -1;
        this._m_Rgbe = false;
      }

      gl.bindTexture(gl.TEXTURE_2D, this._m_Texture);
    }
    /**
     * 暂时未想好比较方式。<br/>
     * @param {Texture2DVars}[texture2DVars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(texture2DVars) {
      return false;
    }
  }]);

  return Texture2DVars;
}(_Vars2.default);

exports["default"] = Texture2DVars;

_defineProperty(Texture2DVars, "_S_TEMP_COLOR", new _UniformBufferI.default(4));

_defineProperty(Texture2DVars, "S_FILTERS", {
  S_NEAREST: 0x001,
  S_LINEAR: 0x002,
  S_LINEAR_MIPMAP_NEAREST: 0x003,
  S_NEAREST_MIPMAP_LINEAR: 0x004,
  S_LINEAR_MIPMAP_LINEAR: 0x005,
  S_NEAREST_MIPMAP_NEAREST: 0x006
});

_defineProperty(Texture2DVars, "S_WRAPS", {
  S_REPEAT: 0x001,
  S_CLAMP: 0X002,
  S_CLAMP_TO_EDGE: 0x003,
  S_CLAMP_TO_BORDER: 0x004
});

_defineProperty(Texture2DVars, "S_TEXTURE_FORMAT", {});

/***/ }),

/***/ 4048:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

var _UniformBufferI = _interopRequireDefault(__webpack_require__(6140));

var _UniformBuffer = _interopRequireDefault(__webpack_require__(1446));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * TextureCubeVars。<br/>
 * TextureCube立方体纹理，其数据可以由环境图像(HDR或球形纹理)或6张环境纹理图像定义。<br/>
 * @author Kkk
 * @date 2021年3月20日16点46分
 */
var TextureCubeVars = /*#__PURE__*/function (_Vars) {
  _inherits(TextureCubeVars, _Vars);

  var _super = _createSuper(TextureCubeVars);

  /**
   * 面标记，如下:<br/>
   * 1    --  Positive X (+x)<br/>
   * 2    --  Negative X (-x)<br/>
   * 3    --  Positive Y (+y)<br/>
   * 4    --  Negative Y (-y)<br/>
   * 5    --  Positive Z (+z)<br/>
   * 6    --  Negative Z (-z)<br/>
   * @type {{PositiveY: number, PositiveZ: number, NegativeY: number, NegativeZ: number, PositiveX: number, NegativeX: number}}
   */
  // 纹理滤波常量
  // 纹理参数常量
  // 纹理格式
  function TextureCubeVars(scene) {
    var _this;

    _classCallCheck(this, TextureCubeVars);

    _this = _super.call(this, scene);
    _this._m_Scene = scene;
    var gl = scene.getCanvas().getGLContext();
    TextureCubeVars.S_TEXTURE_FORMAT = {
      S_RGB: gl.RGB,
      S_RGBA: gl.RGBA,
      S_RGB16F: gl.RGB16F,
      S_RGB32F: gl.RGB32F,
      S_RGBA16F: gl.RGBA16F,
      S_RGBA32F: gl.RGBA32F,
      S_RGBE5: gl.RGB9_E5,
      S_SHORT: gl.SHORT,
      S_SRGB: gl.SRGB,
      S_SRGB8: gl.SRGB8,
      S_SRGBA: gl.SRGB8_ALPHA8,
      S_INT: gl.INT,
      S_BYTE: gl.BYTE,
      S_UNSIGNED_BYTE: gl.UNSIGNED_BYTE,
      S_FLOAT: gl.FLOAT
    }; // 创建纹理目标

    _this._m_Texture = gl.createTexture(); // 设置默认纹理滤波

    _this._setFilter(scene, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    _this._setFilter(scene, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // 内部格式（默认为RGBA）


    _this._m_Internalformat = gl.RGBA; // 外部格式（默认为RGBA）

    _this._m_Format = gl.RGBA; // 数据类型

    _this._m_Type = gl.UNSIGNED_BYTE; // 数据

    _this._m_CubeMaps = {};
    _this._m_UpdateImage = false; // 翻转y(需要在设置图像之前设置)

    _this._m_FlipY = false;
    _this._m_WrapS = null;
    _this._m_WrapT = null;
    _this._m_WrapR = null;
    _this._m_MinFilter = TextureCubeVars.S_FILTERS.S_LINEAR;
    _this._m_MagFilter = TextureCubeVars.S_FILTERS.S_LINEAR;
    return _this;
  }
  /**
   * 设置纹理格式。<br/>
   * @param {Number}[internalFormat]
   * @param {Number}[format]
   * @param {Number}[type]
   */


  _createClass(TextureCubeVars, [{
    key: "setTextureFormat",
    value: function setTextureFormat(internalFormat, format, type) {
      this._m_Internalformat = internalFormat;
      this._m_Format = format;
      this._m_Type = type;
    }
    /**
     * 翻转图像。<br/>
     * 需要在设置图像数据之前设置。<br/>
     * @param {Boolean}[flipY true表示翻转,默认为false]
     */

  }, {
    key: "setFlipY",
    value: function setFlipY(flipY) {
      this._m_FlipY = flipY;
    }
    /**
     * 硬件mipmap。<br/>
     * @param {Scene}[scene]
     */

  }, {
    key: "genMipmap",
    value: function genMipmap(scene) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[minfilter TextureCubeVars.S_FILTERS常量枚举之一]
     * @param {Number}[magfilter TextureCubeVars.S_FILTERS常量枚举之一]
     */

  }, {
    key: "setFilter",
    value: function setFilter(scene, minfilter, magfilter) {
      this._m_MinFilter = minfilter;
      this._m_MagFilter = magfilter;
    }
    /**
     * 解析纹理滤波枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[filterEnum]
     * @return {WebGLObject}
     * @private
     */

  }, {
    key: "_parseFilter",
    value: function _parseFilter(gl, filterEnum) {
      switch (filterEnum) {
        case TextureCubeVars.S_FILTERS.S_LINEAR:
          return gl.LINEAR;

        case TextureCubeVars.S_FILTERS.S_NEAREST:
          return gl.NEAREST;

        case TextureCubeVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST:
          return gl.LINEAR_MIPMAP_NEAREST;
      }

      return null;
    }
    /**
     * 设置纹理滤波。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[filter]
     */

  }, {
    key: "_setFilter",
    value: function _setFilter(scene, texEnum, filter) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, texEnum, filter);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[wrapS TextureCubeVars.S_WRAP枚举常量之一]
     * @param {Number}[wrapT TextureCubeVars.S_WRAP枚举常量之一]
     * @param {Number}[wrapR TextureCubeVars.S_WRAP枚举常量之一]
     */

  }, {
    key: "setWrap",
    value: function setWrap(scene, wrapS, wrapT, wrapR) {
      this._m_WrapS = wrapS;
      this._m_WrapT = wrapT;
      this._m_WrapR = wrapR;
    }
    /**
     * 解析纹理边缘处理枚举常量。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[wrapEnum]
     * @return {Number}
     * @private
     */

  }, {
    key: "_parseWrap",
    value: function _parseWrap(gl, wrapEnum) {
      switch (wrapEnum) {
        case TextureCubeVars.S_WRAPS.S_CLAMP:
          return gl.CLAMP;

        case TextureCubeVars.S_WRAPS.S_REPEAT:
          return gl.REPEAT;

        case TextureCubeVars.S_WRAPS.S_CLAMP_TO_EDGE:
          return gl.CLAMP_TO_EDGE;

        case TextureCubeVars.S_WRAPS.S_CLAMP_TO_BORDER:
          return gl.CLAMP_TO_BORDER;
      }

      return null;
    }
    /**
     * 设置纹理边缘处理。<br/>
     * @param {Scene}[scene]
     * @param {Number}[texEnum]
     * @param {Number}[wrap]
     * @private
     */

  }, {
    key: "_setWrap",
    value: function _setWrap(scene, texEnum, wrap) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, texEnum, wrap);
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
    /**
     * 设置预设颜色值,由于web纹理需要异步加载,所以可以提供一个预设颜色纹理。<br/>
     * @param {Scene}[scene]
     * @param {Vector4}[value]
     */

  }, {
    key: "setPreloadColor",
    value: function setPreloadColor(scene, value) {
      var date = this._m_Type != TextureCubeVars.S_TEXTURE_FORMAT.S_FLOAT ? TextureCubeVars._S_TEMP_COLOR : TextureCubeVars._S_TEMP_COLORF;
      var color = date.getArray();

      if (!value) {
        color[0] = 0;
        color[1] = 0;
        color[2] = 0;
        color[3] = 255;
      } else {
        color[0] = Math.floor(value._m_X * 255);
        color[1] = Math.floor(value._m_Y * 255);
        color[2] = Math.floor(value._m_Z * 255);
        color[3] = Math.floor(value._m_W * 255);
      }

      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);

      for (var i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this._m_Internalformat, 1, 1, 0, this._m_Format, this._m_Type, date.getBufferData());
      }

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
    /**
     * 设置纹理图素路径。<br/>
     * @param {Scene}[scene]
     * @param {Number}[TextureCubeVars.Face]
     * @param {String}[src]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     */

  }, {
    key: "setImageSrc",
    value: function setImageSrc(scene, face, src, options) {
      var _this2 = this;

      // 加载完毕设置纹理图素
      var image = options && options.rgbe ? RadianceLoader.rgbeImg() : new Image();

      image.onload = function () {
        _this2._m_UpdateImage = true; // 某些图形驱动api规范仅支持2的幂次方
        // image = Tools.ensureImageSizePowerOfTwo(image, scene.getCanvas());

        _this2._m_CubeMaps[face] = {
          imgData: options && options.rgbe ? image.dataRGBE : image
        };

        if (options && options.rgbe) {
          _this2._m_CubeMaps[face].rgbe = true;
        }

        _this2._m_CubeMaps[face].width = image.width;
        _this2._m_CubeMaps[face].height = image.height;
        _this2._m_CubeMaps[face].updateImage = true; // 刷新所有材质持有

        for (var owner in _this2._m_OwnerFlags) {
          _this2._m_OwnerFlags[owner].owner.setParam(_this2._m_OwnerFlags[owner].flag, _this2);
        }
      };

      image.src = src;
    }
    /**
     * 直接设置已加载的图像数据。<br/>
     * @param {Scene}[scene]
     * @param {Number}[TextureCubeVars.Face]
     * @param {BufferData}[imgData]
     * @param {Boolean}[options.rgbe 表示rgbe数据的辐射度纹理]
     * @param {Number}[options.width 当imgData是二进制数据数组时,需要单独设置纹理宽度]
     * @param {Number}[options.height 当imgData是二进制数据数组时,需要单独设置纹理高度]
     * @param {Number}[options.mipmapLevel]
     */

  }, {
    key: "setImage",
    value: function setImage(scene, face, imgData, options) {
      this._m_UpdateImage = true;
      var mipmapLevel = options && options.mipmapLevel != null ? options.mipmapLevel : null;
      var faceImgData = null;

      if (mipmapLevel != null) {
        if (!this._m_CubeMaps[face]) {
          this._m_CubeMaps[face] = [];
        }

        this._m_CubeMaps[face].push({
          imgData: options && options.rgbe ? imgData.dataRGBE : imgData,
          mipmapLevel: mipmapLevel
        });

        faceImgData = this._m_CubeMaps[face][this._m_CubeMaps[face].length - 1];
      } else {
        this._m_CubeMaps[face] = {
          imgData: options && options.rgbe ? imgData.dataRGBE : imgData
        };
        faceImgData = this._m_CubeMaps[face];
      }

      if (options && options.rgbe) {
        faceImgData.rgbe = true;
      }

      faceImgData.width = options && options.width != null ? options.width : imgData.width;
      faceImgData.height = options && options.height != null ? options.height : imgData.height;
      faceImgData.updateImage = true;
      faceImgData.mipmapLevel = options && options.mipmapLevel ? options.mipmapLevel : 0; // 刷新所有材质持有

      for (var owner in this._m_OwnerFlags) {
        this._m_OwnerFlags[owner].owner.setParam(this._m_OwnerFlags[owner].flag, this);
      }
    }
    /**
     * 设置纹理的图素数据。<br/>
     * @param {Scene}[scene]
     * @param {Number}[face]
     * @param {ImgData}[image]
     * @param {Object}[props]
     */

  }, {
    key: "_setImage",
    value: function _setImage(scene, face, image, props) {
      var gl = scene.getCanvas().getGLContext();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._m_FlipY);

      if (image.rgbe) {
        gl.texImage2D(this._parseFace(gl, face), image.mipmapLevel, this._m_Internalformat, image.width, image.height, 0, this._m_Format, this._m_Type, image.imgData);
      } else {
        if (Array.isArray(image)) {
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_BASE_LEVEL, 0);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, image.length);
          var img = null;

          for (var i = 0; i < image.length; i++) {
            img = image[i];
            gl.texImage2D(this._parseFace(gl, face), img.mipmapLevel, this._m_Internalformat, img.width, img.height, 0, this._m_Format, this._m_Type, img.imgData);
          }
        } else {
          gl.texImage2D(this._parseFace(gl, face), image.mipmapLevel, this._m_Internalformat, image.width, image.height, 0, this._m_Format, this._m_Type, image.imgData);
        }
      }

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
    /**
     * 返回对应的cubeMapFace。<br/>
     * @param {WebGL}[gl]
     * @param {Number}[TextureCubeVars.Face]
     * @return {number | GLenum}
     * @private
     */

  }, {
    key: "_parseFace",
    value: function _parseFace(gl, face) {
      switch (face) {
        case TextureCubeVars.S_FACE.PositiveX:
          return gl.TEXTURE_CUBE_MAP_POSITIVE_X;

        case TextureCubeVars.S_FACE.NegativeX:
          return gl.TEXTURE_CUBE_MAP_NEGATIVE_X;

        case TextureCubeVars.S_FACE.PositiveY:
          return gl.TEXTURE_CUBE_MAP_POSITIVE_Y;

        case TextureCubeVars.S_FACE.NegativeY:
          return gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;

        case TextureCubeVars.S_FACE.PositiveZ:
          return gl.TEXTURE_CUBE_MAP_POSITIVE_Z;

        case TextureCubeVars.S_FACE.NegativeZ:
          return gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
      }
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.activeTexture(gl.TEXTURE0 + loc);

      if (this._m_UpdateImage) {
        // 某些图形驱动api规范仅支持2的
        //self._image = image; // 为了更快地恢复WebGL上下文-内存效率低下？
        for (var face in this._m_CubeMaps) {
          if (this._m_CubeMaps[face]) {
            this._setImage(this._m_Scene, face, this._m_CubeMaps[face]);

            this._m_CubeMaps[face] = null;
          }
        } // 为该image生成硬件mipmap


        if (this._m_MinFilter == TextureCubeVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST || this._m_MagFilter == TextureCubeVars.S_FILTERS.S_LINEAR_MIPMAP_NEAREST) {
          this.genMipmap(this._m_Scene);
        } // 设置默认纹理滤波


        var _gl = this._m_Scene.getCanvas().getGLContext();

        if (this._m_WrapS) {
          this._setWrap(this._m_Scene, _gl.TEXTURE_WRAP_S, this._parseWrap(_gl, this._m_WrapS));
        }

        if (this._m_WrapT) {
          this._setWrap(this._m_Scene, _gl.TEXTURE_WRAP_T, this._parseWrap(_gl, this._m_WrapT));
        }

        if (this._m_WrapR) {
          this._setWrap(this._m_Scene, _gl.TEXTURE_WRAP_R, this._parseWrap(_gl, this._m_WrapR));
        }

        if (this._m_MinFilter) {
          this._setFilter(this._m_Scene, _gl.TEXTURE_MIN_FILTER, this._parseFilter(_gl, this._m_MinFilter));
        }

        if (this._m_MagFilter) {
          this._setFilter(this._m_Scene, _gl.TEXTURE_MAG_FILTER, this._parseFilter(_gl, this._m_MagFilter));
        }

        this._m_UpdateImage = false;
      }

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._m_Texture);
    }
    /**
     * 暂时未想好比较方式。<br/>
     * @param {TextureCubeVars}[textureCubeVars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(textureCubeVars) {
      return false;
    }
  }]);

  return TextureCubeVars;
}(_Vars2.default);

exports["default"] = TextureCubeVars;

_defineProperty(TextureCubeVars, "_S_TEMP_COLOR", new _UniformBufferI.default(4));

_defineProperty(TextureCubeVars, "_S_TEMP_COLORF", new _UniformBuffer.default(4));

_defineProperty(TextureCubeVars, "S_FACE", {
  PositiveX: '1',
  NegativeX: '2',
  PositiveY: '3',
  NegativeY: '4',
  PositiveZ: '5',
  NegativeZ: '6'
});

_defineProperty(TextureCubeVars, "S_FILTERS", {
  S_NEAREST: 0x001,
  S_LINEAR: 0x002,
  S_LINEAR_MIPMAP_NEAREST: 0x003
});

_defineProperty(TextureCubeVars, "S_WRAPS", {
  S_REPEAT: 0x001,
  S_CLAMP: 0X002,
  S_CLAMP_TO_EDGE: 0x003,
  S_CLAMP_TO_BORDER: 0x004
});

_defineProperty(TextureCubeVars, "S_TEXTURE_FORMAT", {});

/***/ }),

/***/ 3552:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * 变量的根类。<br/>
 * @author Kkk
 * @date 2021年3月3日14点37分
 */
var Vars = /*#__PURE__*/function () {
  function Vars(props) {
    _classCallCheck(this, Vars);

    this._m_OwnerFlags = {};
  }
  /**
   * 比较两个变量。<br/>
   * @param {Vars}[vars]
   * @return {Boolean}
   */


  _createClass(Vars, [{
    key: "compare",
    value: function compare(vars) {
      return false;
    }
    /**
     * 上载。<br/>
     * @param {WebGL}[gl]
     * @param {WebGLUniformLocation}[loc]
     * @param {WebGLFunction}[fun]
     * @private
     */

  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {}
    /**
     * 设置持有者。<br/>
     * @param {Object}[owner]
     */

  }, {
    key: "owner",
    value: function owner(_owner, flag) {
      if (!this._m_OwnerFlags[_owner.getId()]) {
        this._m_OwnerFlags[_owner.getId()] = {
          owner: _owner,
          flag: flag
        };
      }
    }
    /**
     * 移除持有者。<br/>
     * @param {Object}[owner]
     */

  }, {
    key: "unowner",
    value: function unowner(owner) {
      if (this._m_OwnerFlags[owner.getId()]) {
        delete this._m_OwnerFlags[owner.getId()];
      }
    }
  }]);

  return Vars;
}();

exports["default"] = Vars;

/***/ }),

/***/ 4690:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Vec2Vars。<br/>
 * 定义vec2变量。<br/>
 * @author Kkk
 * @date 2021年9月21日17点06分
 */
var Vec2Vars = /*#__PURE__*/function (_Vars) {
  _inherits(Vec2Vars, _Vars);

  var _super = _createSuper(Vec2Vars);

  function Vec2Vars(props) {
    var _this;

    _classCallCheck(this, Vec2Vars);

    _this = _super.call(this, props);
    _this._m_X = 0;
    _this._m_Y = 0;
    return _this;
  }

  _createClass(Vec2Vars, [{
    key: "valueFromXY",
    value: function valueFromXY(x, y) {
      this._m_X = x;
      this._m_Y = y;
      return this;
    }
    /**
     * 比较变量。<br/>
     * @param {Vec2Vars}[vec2Vars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(vec2Vars) {
      return false;
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.uniform2f(loc, this._m_X, this._m_Y);
    }
  }]);

  return Vec2Vars;
}(_Vars2.default);

exports["default"] = Vec2Vars;

/***/ }),

/***/ 2462:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Vars2 = _interopRequireDefault(__webpack_require__(3552));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Vec4Vars。<br/>
 * 定义vec4变量。<br/>
 * @author Kkk
 * @date 2021年3月3日14点12分
 */
var Vec4Vars = /*#__PURE__*/function (_Vars) {
  _inherits(Vec4Vars, _Vars);

  var _super = _createSuper(Vec4Vars);

  function Vec4Vars(props) {
    var _this;

    _classCallCheck(this, Vec4Vars);

    _this = _super.call(this, props);
    _this._m_X = 0;
    _this._m_Y = 0;
    _this._m_Z = 0;
    _this._m_W = 1;
    return _this;
  }

  _createClass(Vec4Vars, [{
    key: "valueFromXYZW",
    value: function valueFromXYZW(x, y, z, w) {
      this._m_X = x;
      this._m_Y = y;
      this._m_Z = z;
      this._m_W = w;
      return this;
    }
    /**
     * 比较变量。<br/>
     * @param {Vec4Vars}[vec4Vars]
     * @return {Boolean}
     */

  }, {
    key: "compare",
    value: function compare(vec4Vars) {
      // return this._m_X == vec4Vars._m_X && this._m_Y == vec4Vars._m_X && this._m_Z == vec4Vars._m_Z && this._m_W == vec4Vars._m_W;
      return false;
    }
  }, {
    key: "_upload",
    value: function _upload(gl, loc, fun) {
      gl.uniform4f(loc, this._m_X, this._m_Y, this._m_Z, this._m_W);
    }
  }]);

  return Vec4Vars;
}(_Vars2.default);

exports["default"] = Vec4Vars;

/***/ }),

/***/ 4620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _AssetLoader = _interopRequireDefault(__webpack_require__(1193));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Geometry = _interopRequireDefault(__webpack_require__(4720));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Bone = _interopRequireDefault(__webpack_require__(9586));

var _SkinGeometry = _interopRequireDefault(__webpack_require__(6858));

var _AnimationAction = _interopRequireDefault(__webpack_require__(479));

var _TrackMixer = _interopRequireDefault(__webpack_require__(7938));

var _ActionClip = _interopRequireDefault(__webpack_require__(4755));

var _TrackBinding = _interopRequireDefault(__webpack_require__(1245));

var _AnimKeyframeEnum = _interopRequireDefault(__webpack_require__(7868));

var _Skeleton = _interopRequireDefault(__webpack_require__(1608));

var _Joint = _interopRequireDefault(__webpack_require__(8649));

var _AnimationProcessor = _interopRequireDefault(__webpack_require__(1648));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _Vec4Vars = _interopRequireDefault(__webpack_require__(2462));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

var _Texture2DVars = _interopRequireDefault(__webpack_require__(5141));

var _BoolVars = _interopRequireDefault(__webpack_require__(1491));

var _Vector = _interopRequireDefault(__webpack_require__(7141));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * GLTFLoader。<br/>
 * 提供GLTF模型加载支持,支持二进制glb,gltf+bin,嵌入式gltf。<br/>
 * 参考官方wiki:https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md。<br/>
 * 我实现了很大整个gltf的一个子集，这个子集基本上涵盖了通用的部分内容，但是部分枚举我并没有全部引入。<br/>
 * 有需要请自寻拓展这个加载器或使用第三方加载器。<br/>
 * @author Kkk
 * @date 2021年3月5日13点43分
 */
var GLTFLoader = /*#__PURE__*/function () {
  function GLTFLoader() {
    _classCallCheck(this, GLTFLoader);

    _defineProperty(this, "_m_CustomMatDef", "PrincipledLightingDef");
  }

  _createClass(GLTFLoader, [{
    key: "load",
    value:
    /**
     * 加载一个GLTF模型。<br/>
     * @param {Scene}[scene]
     * @param {String}[src]
     * @param {Function}[callback]
     * @param {Boolean}[options.batch 对于静态场景,可以设置为true以进行优化数据,对于包含动画场景的模型,静止使用该变量]
     */
    function load(scene, src, callback, options) {
      this._m_Scene = scene;
      this._m_Batch = options && options.batch;
      this._m_GLTFRootNode = null;
      this._m_PrincipledMatDef = null;
      this._m_DefaultMatDef = null;
      this._m_Joints = {};
      this._m_Bones = [];
      this._m_Nodes = {};
      this._m_Aps = [];
      this._m_Skeletons = {};
      this._m_AnimationProcessors = {};
      this._m_Mats = {};
      this._m_MatMeshs = {};
      this._m_BasePath = _AssetLoader.default.getBasePath(src);

      this._loadGLTF(src, callback);
    }
    /**
     * 重置加载器。<br/>
     */

  }, {
    key: "reset",
    value: function reset() {
      this._m_GLTFRootNode = null;
      this._m_PrincipledMatDef = null;
      this._m_DefaultMatDef = null;
      this._m_Joints = {};
      this._m_Bones = [];
      this._m_Nodes = {};
      this._m_Aps = [];
      this._m_Skeletons = {};
      this._m_AnimationProcessors = {};
      this._m_Mats = {};
      this._m_MatMeshs = {};
    }
    /**
     * 设置Assets路径和自定义材质定义。<br/>
     * @param {String}[assetsPath]
     * @param {String}[customMatDef]
     */

  }, {
    key: "setAssetsPath",
    value: function setAssetsPath(assetsPath, customMatDef) {
      this._m_AssetsPath = assetsPath;
      if (customMatDef) this._m_CustomMatDef = customMatDef;
    }
  }, {
    key: "_loadBIN",
    value: function _loadBIN(gltf, buffers, i, length, ok) {
      var _this = this;

      if (length > 0) {
        _AssetLoader.default.loadFile(this._m_BasePath + gltf.buffers[i].uri, function (data) {
          length--;
          buffers.push({
            data: data,
            byteLength: gltf.buffers[i].byteLength
          });

          _this._loadBIN(gltf, buffers, ++i, length, ok);
        }, null, {
          inflate: true
        });
      } else {
        // 结束
        if (ok) {
          ok();
        }
      }
    }
    /**
     * 加载GLTF。<br/>
     * @param {String}[src]
     * @param {Function}[callback]
     * @private
     */

  }, {
    key: "_loadGLTF",
    value: function _loadGLTF(src, callback) {
      var _this2 = this;

      _AssetLoader.default.loadFile(src, function (gltf) {
        gltf = JSON.parse(gltf);

        if (gltf) {
          // 开始解析
          // 先把二进制数据载入内存
          // 后续改为根据优先加载策略(比如min,max非常小的可以先不加载对应的bin)
          // 还有就是可以根据需要显示的scene加载对应的bin,只应该在需要对应的bin时才去加载,但目前先全部载入内存
          if (gltf.buffers && gltf.buffers.length > 0) {
            // 假设都是分离式gltf
            var length = gltf.buffers.length;
            var i = 0;
            var buffers = [];

            _this2._loadBIN(gltf, buffers, i, length, function () {
              // 所有二进制数据全部加载完成
              // Log.log("所有二进制加载完成!",buffers);
              gltf.buffers = buffers;
              var scene = null; // 开始解析场景

              if (_Tools.default.checkIsNull(gltf.scene)) {
                scene = _this2._addScene(gltf);
              }

              if (!_this2._m_Batch) {
                _this2._bindBone(); // 解析动画剪辑


                if (_Tools.default.checkIsNull(gltf.animations)) {
                  _this2._parseAnimations(gltf);

                  _this2._m_Aps.forEach(function (ap) {
                    ap.skeleton.finished();
                  });
                }
              } else {
                // 创建batch场景
                _this2._batchScene();
              }

              _Log.default.log('当前材质:', _this2._m_Mats); // 预编译所有材质


              if (_this2._m_Mats) {
                for (var matId in _this2._m_Mats) {
                  _this2._m_Mats[matId].preload();
                }
              }

              if (callback) {
                callback(_this2._m_GLTFRootNode);
              }
            });
          }
        }

        _Log.default.log('gltf:', gltf);
      });
    }
  }, {
    key: "_batchScene",
    value: function _batchScene() {
      if (this._m_MatMeshs) {
        var mesh = null;
        var geometry = null;

        for (var matId in this._m_MatMeshs) {
          mesh = this._m_MatMeshs[matId].mesh;
          geometry = new _Geometry.default(this._m_Scene, {
            id: matId + "_" + _Tools.default.nextId()
          });
          geometry.setMesh(mesh);
          geometry.updateBound();
          geometry.setMaterial(this._m_Mats[matId]);

          if (this._m_Mats[matId].renderState) {
            // 暂时先这么简陋实现,后期再封装完整的渲染状态系统
            if (this._m_Mats[matId].renderState.alphaMode == 'BLEND' || this._m_Mats[matId].renderState.alphaMode == 'MASK') {
              geometry.setTranslucent();
            }
          }

          this._m_GLTFRootNode.addChildren(geometry);
        }
      }
    }
  }, {
    key: "_bindBone",
    value: function _bindBone() {
      var jis = null;
      var bone = null;

      for (var i = 0; i < this._m_Aps.length; i++) {
        jis = this._m_Aps[i].skeleton.getJoints();

        _Log.default.log('jointcount:' + jis.length);

        for (var j = 0; j < jis.length; j++) {
          bone = this._m_Nodes[jis[j].getId()]; // 这里一个潜在性问题是，为了加速解析，这里并非首先遍历所有skin（因为skin并非顺序存储在gltf中）
          // 所以为了避免某些joint引用自node,在这里手动转换为bone

          if (!(bone instanceof _Bone.default) && !bone._update2) {
            bone.getType = function () {
              return 'Bone';
            };

            bone._update2 = bone._updateLocalMatrix;

            bone.bind = function (b) {
              this._m_Bind = b;
            };

            bone.getBind = function () {
              return this._m_Bind;
            };

            bone._updateLocalMatrix = function () {
              this._update2();

              if (this._m_Bind) {
                this._m_Bind.actived();
              }
            };
          }

          if (bone) {
            jis[j].link(bone);
          }
        }
      }
    }
  }, {
    key: "_parseAnimations",
    value: function _parseAnimations(gltf) {
      var _this3 = this;

      var trackMixer = null;
      var animationAction = null;
      var actionClip = null;
      var jis = null;
      var t = false;
      gltf.animations.forEach(function (anim) {
        animationAction = new _AnimationAction.default(_this3._getName(anim.name));
        trackMixer = new _TrackMixer.default();
        anim.channels.forEach(function (channel) {
          var node = channel.target.node;
          actionClip = new _ActionClip.default(channel.target.path);

          if (_this3._m_Nodes[node]) {
            // 创建轨迹
            _TrackBinding.default.createTrack(actionClip, _this3._m_Nodes[node]); // 采样轨迹


            var sampler = anim.samplers[channel.sampler];

            _this3._parseSampler(gltf, sampler.input, sampler.output, sampler.interpolation, _AnimKeyframeEnum.default.S_KEY_FRAME[channel.target.path], actionClip);

            trackMixer.addClip(actionClip);
            t = false;

            for (var i = 0; i < _this3._m_Aps.length; i++) {
              jis = _this3._m_Aps[i].skeleton.getJoints();

              for (var j = 0; j < jis.length; j++) {
                if (jis[j].getId() == node) {
                  t = true; // jis[j].link(this._m_Nodes[node]);

                  _this3._m_Aps[i].animationProcessor.addAnimationAction(animationAction);

                  break;
                }
              }

              if (t) {
                break;
              }
            }

            if (!t) {
              // 非skin动画
              _Log.default.log(node + '非skin动画!path:' + channel.target.path);

              var animationProcessor = null;

              if (!_this3._m_AnimationProcessors[node]) {
                var _animationProcessor = new _AnimationProcessor.default(_this3._m_GLTFRootNode, {
                  id: _Tools.default.nextId() + "_" + node + "_animationProcessor"
                });

                _this3._m_AnimationProcessors[node] = _animationProcessor;
              }

              animationProcessor = _this3._m_AnimationProcessors[node];
              animationProcessor.addAnimationAction(animationAction);
            } // this._m_Aps[0].animationProcessor.addAnimationAction(animationAction);

          } else {
            _Log.default.log('animation_node:' + node);
          }
        });
        animationAction.setTrackMixer(trackMixer);
      });
    }
  }, {
    key: "_getAccessorData",
    value: function _getAccessorData(gltf, i) {
      var _accessors = gltf.accessors[i];
      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_accessors.bufferView];
      var dataCount = GLTFLoader.DATA_COMPONENT[_accessors.type];
      return new GLTFLoader.DATA[_accessors.componentType](_buffers[_bufferView.buffer].data, (_bufferView.byteOffset || 0) + (_accessors.byteOffset || 0), _accessors.count * dataCount);
    }
  }, {
    key: "_parseSampler",
    value: function _parseSampler(gltf, i, o, ip, keyframe, actionClip) {
      var _i = this._getAccessorData(gltf, i);

      var _o = this._getAccessorData(gltf, o);

      var clipCount = gltf.accessors[i].count;
      var dataCount = GLTFLoader.DATA_COMPONENT[gltf.accessors[o].type];
      var _keyframe = null;
      var offset = 0;

      for (var _i2 = 0; _i2 < clipCount; _i2++) {
        offset = _i2 * dataCount;

        if (dataCount > 3) {
          if (!keyframe) {
            _Log.default.warn("未知keyframe!");
          }

          _keyframe = new keyframe(_i[_i2], _o[offset], _o[offset + 1], _o[offset + 2], _o[offset + 3]); // Log.log('_keyframe,time:' + _keyframe.getTime() + ',value:' + _keyframe.getValue().toString());
        } else {
          if (!keyframe) {
            _Log.default.warn("未知keyframe!");
          }

          _keyframe = new keyframe(_i[_i2], _o[offset], _o[offset + 1], _o[offset + 2]);
        }

        _keyframe.setInterpolationMode(ip);

        actionClip.addKeyframe(_keyframe);
      }
    }
  }, {
    key: "_addScene",
    value: function _addScene(gltf) {
      var _this4 = this;

      if (_Tools.default.checkIsNull(gltf.scene)) {
        var _scene = gltf.scenes[gltf.scene];
        var sceneNode = new _Node.default(this._m_Scene, {
          id: _scene.name
        });

        if (this._m_Batch) {
          // 因为batchScene已经执行了合并变换操作,所以在这里消除
          this._m_GLTFRootNode = new _Node.default(this._m_Scene, {
            id: _Tools.default.nextId() + "_scene"
          });

          this._m_GLTFRootNode.addChildren(sceneNode);
        } else {
          this._m_GLTFRootNode = sceneNode;
        } // 检查子节点


        if (_Tools.default.checkIsNull(_scene.nodes)) {
          // 添加子节点
          _scene.nodes.forEach(function (node) {
            _this4._addNode(gltf, sceneNode, node);
          });
        }

        return this._m_GLTFRootNode;
      }

      return null;
    }
  }, {
    key: "_getName",
    value: function _getName(name) {
      if (name == null || name == undefined || name == '') {
        return _Tools.default.nextId();
      }

      return name;
    }
  }, {
    key: "_parseSkins",
    value: function _parseSkins(gltf, i) {
      var _this5 = this;

      var skin = gltf.skins[i];
      var skeleton = new _Skeleton.default(this._getName(skin.name));
      var skeletonJoint = null;

      var jointSpaceData = this._getAccessorData(gltf, skin.inverseBindMatrices);

      var ji = 0;
      var array = [];
      skin.joints.forEach(function (joint) {
        _this5._m_Joints[joint] = true;
        array.length = 0;

        for (var _i3 = 0, offset = ji * 16; _i3 < 16; _i3++) {
          array.push(jointSpaceData[_i3 + offset]);
        }

        skeletonJoint = new _Joint.default(joint, ji);
        skeletonJoint.setJointSpace(array);
        skeleton.addJoint(skeletonJoint);
        ji++;
      });
      return skeleton;
    }
  }, {
    key: "_addNode",
    value: function _addNode(gltf, parent, nodeI) {
      var _this6 = this;

      // Log.log('nodeI:' + nodeI + ";name:" + gltf.nodes[nodeI].name);
      var _node = gltf.nodes[nodeI];
      var node = null; // 创建Node

      if (this._m_Joints[nodeI]) {
        node = new _Bone.default(parent, {
          id: this._getName(_node.name)
        });

        this._m_Bones.push(node); // Log.log('添加Bone' + nodeI);

      } else {
        node = new _Node.default(parent, {
          id: this._getName(_node.name)
        });
      }

      this._m_Nodes[nodeI] = node;
      parent.addChildren(node);

      if (_Tools.default.checkIsNull(_node.children)) {
        // 解析子节点
        _node.children.forEach(function (nodeI) {
          _this6._addNode(gltf, node, nodeI);
        });
      }

      if (node) {
        // 变换
        if (_Tools.default.checkIsNull(_node.scale)) {
          node.setLocalScaleXYZ(_node.scale[0], _node.scale[1], _node.scale[2]);
        }

        if (_Tools.default.checkIsNull(_node.rotation)) {
          node.setLocalRotationFromXYZW(_node.rotation[0], _node.rotation[1], _node.rotation[2], _node.rotation[3]);
        }

        if (_Tools.default.checkIsNull(_node.translation)) {
          node.setLocalTranslationXYZ(_node.translation[0], _node.translation[1], _node.translation[2]);
        }

        if (_Tools.default.checkIsNull(_node.matrix)) {
          node.setLocalMatrixFromArray(_node.matrix);
        }
      } // 解析mesh结构


      if (_Tools.default.checkIsNull(_node.mesh)) {
        if (this._m_Batch) {
          // batch将一致处理，所以这里会忽略导致动画数据被过滤掉
          this._parseMeshBatch(gltf, node, _node.mesh);
        } else {
          this._parseMesh(gltf, node, _node.mesh, _Tools.default.checkIsNull(_node.skin));

          if (_Tools.default.checkIsNull(_node.skin)) {
            // 添加骨架
            // 如果已经存在skin则直接应用这套骨架
            var skeleton = null;

            if (this._m_Skeletons[_node.skin]) {
              skeleton = this._m_Skeletons[_node.skin];
            } else {
              skeleton = this._parseSkins(gltf, _node.skin);
              this._m_Skeletons[_node.skin] = skeleton;

              _Log.default.log('创建Skeleton!');
            }

            node.getChildren().forEach(function (skinGeometryNode) {
              skinGeometryNode.setSkeleton(skeleton);
            }); // 添加AnimationProcessor

            if (this._m_AnimationProcessors[_node.skin]) {// 说明该ap被多个skin引用,应该将其附加到这些skin的父类
            } else {
              // 这里将所有animationProcessor附加到根节点中,而不再附加到最近层级,虽然没有了层级描述性,但方便了使用和管理
              var animationProcessor = new _AnimationProcessor.default(this._m_GLTFRootNode, {
                id: _Tools.default.nextId() + "_animationProcessor"
              });

              this._m_Aps.push({
                skeleton: skeleton,
                animationProcessor: animationProcessor
              });

              this._m_AnimationProcessors[_node.skin] = animationProcessor;
            }
          }
        }
      }
    }
  }, {
    key: "_transformVertex",
    value: function _transformVertex(inPosition, inMat4) {
      var inVec4 = new _Vector.default();
      var outVec4 = new _Vector.default();
      var outPositions = [];

      for (var i = 0; i < inPosition.length; i += 3) {
        inVec4.setToInXYZW(inPosition[i], inPosition[i + 1], inPosition[i + 2], 1.0);

        _Matrix.default.multiplyMV(outVec4, inVec4, inMat4);

        outPositions.push(outVec4._m_X);
        outPositions.push(outVec4._m_Y);
        outPositions.push(outVec4._m_Z);
      }

      return outPositions;
    }
  }, {
    key: "_transformNormal",
    value: function _transformNormal(inPosition, inMat4) {
      var normalMatrix = new _Matrix.default();
      normalMatrix.set(inMat4);
      normalMatrix.inert();
      normalMatrix.transpose();
      var inVec4 = new _Vector.default();
      var outVec4 = new _Vector.default();
      var outPositions = [];

      for (var i = 0; i < inPosition.length; i += 3) {
        inVec4.setToInXYZW(inPosition[i], inPosition[i + 1], inPosition[i + 2], 0.0);

        _Matrix.default.multiplyMV(outVec4, inVec4, inMat4);

        outPositions.push(outVec4._m_X);
        outPositions.push(outVec4._m_Y);
        outPositions.push(outVec4._m_Z);
      }

      return outPositions;
    }
  }, {
    key: "_parseMeshBatch",
    value: function _parseMeshBatch(gltf, parrent, meshI) {
      var _this7 = this;

      var _mesh = gltf.meshes[meshI];
      var _primitives = _mesh.primitives;
      var _primitive = null;
      var geometryNode = null;
      var mesh = null;

      for (var i = 0; i < _primitives.length; i++) {
        _primitive = _primitives[i];
        var matId = null;

        if (_Tools.default.checkIsNull(_primitive.material)) {
          // 后续完善时,这里单独到一个函数中进行,因为解析PBR材质参数最好独立到一个解析函数中
          if (!this._m_PrincipledMatDef) {
            if (this._m_AssetsPath && this._m_CustomMatDef) {
              this._m_PrincipledMatDef = _MaterialDef.default.load(this._m_AssetsPath + this._m_CustomMatDef);
            } else {
              this._m_PrincipledMatDef = _MaterialDef.default.parse(_Internal.default.S_PRINCIPLED_LIGHTING_DEF);
            }
          }

          matId = this._getName(gltf.materials[_primitive.material].name);
          var material = null;

          if (this._m_Mats[matId]) {
            material = this._m_Mats[matId];
          } else {
            material = new _Material.default(this._m_Scene, {
              id: matId,
              materialDef: this._m_PrincipledMatDef
            });

            this._parseMaterial(gltf, _primitive.material, material);

            this._m_Mats[matId] = material;
          }
        } else {
          // 添加一个默认材质
          if (!this._m_DefaultMatDef) {
            this._m_DefaultMatDef = _MaterialDef.default.load(this._m_AssetsPath + "ColorDef");
          }

          matId = 'default_gltf_mat';
          var _material2 = null;

          if (this._m_Mats[matId]) {
            _material2 = this._m_Mats[matId];
          } else {
            // 创建新材质,后续移到独立方法创建适配的pbr材质或转换phong材质
            _material2 = new _Material.default(this._m_Scene, {
              id: matId,
              materialDef: this._m_DefaultMatDef
            });
            this._m_Mats[matId] = _material2;
          }
        }

        if (!this._m_MatMeshs[matId]) {
          // 解析mesh
          mesh = new _Mesh.default(); // 首先是几何属性

          if (_Tools.default.checkIsNull(_primitive.attributes.POSITION)) {
            // position属性
            var positions = this._parsePositions(gltf, _primitive.attributes.POSITION);

            if (parrent) {
              positions.data = this._transformVertex(positions.data, parrent.getWorldMatrix());
            }

            mesh.setData(_Mesh.default.S_POSITIONS, positions.data);
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.NORMAL)) {
            // normal属性
            var normals = this._parseNormals(gltf, _primitive.attributes.NORMAL);

            if (parrent) {
              normals.data = this._transformNormal(normals.data, parrent.getWorldMatrix());
            }

            mesh.setData(_Mesh.default.S_NORMALS, normals.data);
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.TEXCOORD_0)) {
            // 第一道texCoord属性(暂时跳过lightMap)
            var texcoords = this._parseTexcoords(gltf, _primitive.attributes.TEXCOORD_0);

            var _t = [];

            for (var _i4 = 0; _i4 < texcoords.data.length; _i4++) {
              _t.push(texcoords.data[_i4]);
            }

            mesh.setData(_Mesh.default.S_UV0, _t);
          } // 其次是索引


          if (_Tools.default.checkIsNull(_primitive.indices)) {
            // indices数据
            var indices = this._parseIndices(gltf, _primitive.indices); // 因为ArrayBuffer不存在push方法,所以这里转换为array


            var _t2 = [];

            for (var _i5 = 0; _i5 < indices.data.length; _i5++) {
              _t2.push(indices.data[_i5]);
            }

            mesh.setData(indices.bufType == 5125 ? _Mesh.default.S_INDICES_32 : _Mesh.default.S_INDICES, _t2);
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.TANGENT)) {
            // normal属性
            var tangents = this._parseTangents(gltf, _primitive.attributes.TANGENT);

            var _t3 = [];

            for (var _i6 = 0; _i6 < tangents.data.length; _i6++) {
              _t3.push(tangents.data[_i6]);
            }

            mesh.setData(_Mesh.default.S_TANGENTS, _t3);
          } else {
            // 生成切线数据
            if (mesh.getData(_Mesh.default.S_UV0)) {
              var _tangents = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES) ? mesh.getData(_Mesh.default.S_INDICES) : mesh.getData(_Mesh.default.S_INDICES_32), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

              var _t4 = [];

              for (var _i7 = 0; _i7 < _tangents.length; _i7++) {
                _t4.push(_tangents[_i7]);
              }

              mesh.setData(_Mesh.default.S_TANGENTS, _t4);
            } else {
              // 为了内存对齐
              var _tangents2 = _Tools.default.generatorFillTangents2(mesh.getData(_Mesh.default.S_INDICES) ? mesh.getData(_Mesh.default.S_INDICES) : mesh.getData(_Mesh.default.S_INDICES_32), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0));

              for (var _i8 = 0; _i8 < _tangents2.length; _i8++) {
                t.push(_tangents2[_i8]);
              }

              mesh.setData(_Mesh.default.S_TANGENTS, t);
            }
          }

          this._m_MatMeshs[matId] = {
            mesh: mesh
          };
        } else {
          mesh = this._m_MatMeshs[matId].mesh;
          var meshPositionsLength = 0; // 首先是几何属性

          if (_Tools.default.checkIsNull(_primitive.attributes.POSITION)) {
            (function () {
              // position属性
              var positions = _this7._parsePositions(gltf, _primitive.attributes.POSITION);

              if (parrent) {
                positions.data = _this7._transformVertex(positions.data, parrent.getWorldMatrix());
              }

              var meshPositions = mesh.getData(_Mesh.default.S_POSITIONS);

              if (meshPositions) {
                meshPositionsLength = meshPositions.length;
                positions.data.forEach(function (pos) {
                  meshPositions.push(pos);
                });
                mesh.setData(_Mesh.default.S_POSITIONS, meshPositions);
              }
            })();
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.NORMAL)) {
            (function () {
              // normal属性
              var normals = _this7._parseNormals(gltf, _primitive.attributes.NORMAL);

              if (parrent) {
                normals.data = _this7._transformNormal(normals.data, parrent.getWorldMatrix());
              }

              var meshNormals = mesh.getData(_Mesh.default.S_NORMALS);

              if (meshNormals) {
                normals.data.forEach(function (nor) {
                  meshNormals.push(nor);
                });
                mesh.setData(_Mesh.default.S_NORMALS, meshNormals);
              }
            })();
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.TEXCOORD_0)) {
            (function () {
              // 第一道texCoord属性(暂时跳过lightMap)
              var texcoords = _this7._parseTexcoords(gltf, _primitive.attributes.TEXCOORD_0);

              var meshTexCoords = mesh.getData(_Mesh.default.S_UV0);

              if (meshTexCoords) {
                texcoords.data.forEach(function (tex) {
                  meshTexCoords.push(tex);
                });
                mesh.setData(_Mesh.default.S_UV0, meshTexCoords);
              }
            })();
          } // 其次是索引


          if (_Tools.default.checkIsNull(_primitive.indices)) {
            (function () {
              // indices数据
              var indices = _this7._parseIndices(gltf, _primitive.indices);

              var meshIndices = mesh.getData(_Mesh.default.S_INDICES);
              var offset = 0;

              if (meshIndices) {
                offset = meshPositionsLength / 3;
                indices.data.forEach(function (ind) {
                  meshIndices.push(ind + offset);
                });
                mesh.setData(indices.bufType == 5125 ? _Mesh.default.S_INDICES_32 : _Mesh.default.S_INDICES, meshIndices);

                if (indices.bufType != 5125) {
                  mesh.setData(_Mesh.default.S_INDICES, null);
                }
              } else {
                meshIndices = mesh.getData(_Mesh.default.S_INDICES_32);

                if (meshIndices) {
                  offset = meshPositionsLength / 3;
                  indices.data.forEach(function (ind) {
                    meshIndices.push(ind + offset);
                  });
                  mesh.setData(_Mesh.default.S_INDICES_32, meshIndices);
                }
              }
            })();
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.TANGENT)) {
            (function () {
              // normal属性
              var tangents = _this7._parseTangents(gltf, _primitive.attributes.TANGENT);

              var meshTangents = mesh.getData(_Mesh.default.S_TANGENTS);

              if (meshTangents) {
                tangents.data.forEach(function (tan) {
                  meshTangents.push(tan);
                });
                mesh.setData(_Mesh.default.S_TANGENTS, meshTangents);
              }
            })();
          } else {
            // 生成切线数据
            if (mesh.getData(_Mesh.default.S_UV0)) {
              (function () {
                var tangents = _Tools.default.generatorTangents(mesh.getData(_Mesh.default.S_INDICES) ? mesh.getData(_Mesh.default.S_INDICES) : mesh.getData(_Mesh.default.S_INDICES_32), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0));

                var meshTangents = mesh.getData(_Mesh.default.S_TANGENTS);

                if (meshTangents) {
                  tangents.forEach(function (tan) {
                    meshTangents.push(tan);
                  });
                  mesh.setData(_Mesh.default.S_TANGENTS, meshTangents);
                }
              })();
            } else {
              (function () {
                // 为了内存对齐
                var tangents = _Tools.default.generatorFillTangents(mesh.getData(_Mesh.default.S_INDICES) ? mesh.getData(_Mesh.default.S_INDICES) : mesh.getData(_Mesh.default.S_INDICES_32), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0));

                var meshTangents = mesh.getData(_Mesh.default.S_TANGENTS);

                if (meshTangents) {
                  tangents.forEach(function (tan) {
                    meshTangents.push(tan);
                  });
                  mesh.setData(_Mesh.default.S_TANGENTS, meshTangents);
                }
              })();
            }
          }
        }
      }
    }
  }, {
    key: "_parseMesh",
    value: function _parseMesh(gltf, parrent, meshI, isSkin) {
      var _mesh = gltf.meshes[meshI];
      var _primitives = _mesh.primitives;
      var _primitive = null;
      var geometryNode = null;
      var mesh = null;

      for (var i = 0; i < _primitives.length; i++) {
        _primitive = _primitives[i];

        if (isSkin) {
          geometryNode = new _SkinGeometry.default(parrent, {
            id: this._getName(_mesh.name) + i
          });
        } else {
          geometryNode = new _Geometry.default(parrent, {
            id: this._getName(_mesh.name) + i
          });
        }

        parrent.addChildren(geometryNode); // 解析mesh

        mesh = new _Mesh.default(); // 首先是几何属性

        if (_Tools.default.checkIsNull(_primitive.attributes.POSITION)) {
          // position属性
          var positions = this._parsePositions(gltf, _primitive.attributes.POSITION);

          mesh.setData(_Mesh.default.S_POSITIONS, positions.data);
        }

        if (_Tools.default.checkIsNull(_primitive.attributes.NORMAL)) {
          // normal属性
          var normals = this._parseNormals(gltf, _primitive.attributes.NORMAL);

          mesh.setData(_Mesh.default.S_NORMALS, normals.data);
        }

        if (_Tools.default.checkIsNull(_primitive.attributes.TEXCOORD_0)) {
          // 第一道texCoord属性(暂时跳过lightMap)
          var texcoords = this._parseTexcoords(gltf, _primitive.attributes.TEXCOORD_0);

          mesh.setData(_Mesh.default.S_UV0, texcoords.data);
        } // skin部分


        if (isSkin) {
          if (_Tools.default.checkIsNull(_primitive.attributes.JOINTS_0)) {
            var joints_0 = this._parseJoints(gltf, _primitive.attributes.JOINTS_0);

            mesh.setData(joints_0.bufType == 5125 ? _Mesh.default.S_JOINTS_0_32 : _Mesh.default.S_JOINTS_0, joints_0.data);
          }

          if (_Tools.default.checkIsNull(_primitive.attributes.WEIGHTS_0)) {
            var weights_0 = this._parseWeights(gltf, _primitive.attributes.WEIGHTS_0);

            mesh.setData(_Mesh.default.S_WEIGHTS_0, weights_0.data);
          }
        } // 其次是索引


        if (_Tools.default.checkIsNull(_primitive.indices)) {
          // indices数据
          var indices = this._parseIndices(gltf, _primitive.indices);

          mesh.setData(indices.bufType == 5125 ? _Mesh.default.S_INDICES_32 : _Mesh.default.S_INDICES, indices.data);
        }

        if (_Tools.default.checkIsNull(_primitive.attributes.TANGENT)) {
          // normal属性
          var tangents = this._parseTangents(gltf, _primitive.attributes.TANGENT);

          mesh.setData(_Mesh.default.S_TANGENTS, tangents.data);
        } else {
          // 生成切线数据
          if (mesh.getData(_Mesh.default.S_UV0)) {
            console.log('生成切线数据');

            var _tangents3 = _Tools.default.generatorTangents2(mesh.getData(_Mesh.default.S_INDICES) ? mesh.getData(_Mesh.default.S_INDICES) : mesh.getData(_Mesh.default.S_INDICES_32), mesh.getData(_Mesh.default.S_POSITIONS), mesh.getData(_Mesh.default.S_UV0), mesh.getData(_Mesh.default.S_NORMALS));

            mesh.setData(_Mesh.default.S_TANGENTS, _tangents3);
          } else {
            console.log('-----------------------------');
          }
        } // 然后是材质(这里先跳过PBR材质)


        if (_Tools.default.checkIsNull(_primitive.material)) {
          // 后续完善时,这里单独到一个函数中进行,因为解析PBR材质参数最好独立到一个解析函数中
          if (!this._m_PrincipledMatDef) {
            this._m_PrincipledMatDef = _MaterialDef.default.load(this._m_AssetsPath + "PrincipledLightingDef");
          }

          var matId = this._getName(gltf.materials[_primitive.material].name);

          var material = null;

          if (this._m_Mats[matId]) {
            material = this._m_Mats[matId];
          } else {
            material = new _Material.default(this._m_Scene, {
              id: matId,
              materialDef: this._m_PrincipledMatDef
            });

            this._parseMaterial(gltf, _primitive.material, material);

            this._m_Mats[matId] = material;
          }

          geometryNode.setMaterial(material);

          if (material.renderState) {
            // 暂时先这么简陋实现,后期再封装完整的渲染状态系统
            if (material.renderState.alphaMode == 'BLEND' || material.renderState.alphaMode == 'MASK') {
              geometryNode.setTranslucent();
            }
          }
        } else {
          // 添加一个默认材质
          if (!this._m_DefaultMatDef) {
            this._m_DefaultMatDef = _MaterialDef.default.load(this._m_AssetsPath + "ColorDef");
          }

          var _matId = 'default_gltf_mat';
          var _material3 = null;

          if (this._m_Mats[_matId]) {
            _material3 = this._m_Mats[_matId];
          } else {
            // 创建新材质,后续移到独立方法创建适配的pbr材质或转换phong材质
            _material3 = new _Material.default(this._m_Scene, {
              id: _matId,
              materialDef: this._m_DefaultMatDef
            });
            this._m_Mats[_matId] = _material3;
          }

          geometryNode.setMaterial(_material3);
        }

        geometryNode.setMesh(mesh);
        geometryNode.updateBound(); // 如果是skinGeometry,则添加skin数据

        if (isSkin) {
          geometryNode.getMaterial().addDefine(_ShaderSource.default.S_SKINS_SRC); // Log.log("重新编译:" , geometryNode.getMaterial());
        }
      }
    }
  }, {
    key: "_samplerMap",
    value: function _samplerMap(gltf, i, srgb) {
      var map = gltf.textures[i];
      var img = gltf.images[map.source];
      var texture = new _Texture2DVars.default(this._m_Scene);
      if (srgb) texture.setTextureFormat(_Texture2DVars.default.S_TEXTURE_FORMAT.S_SRGBA, _Texture2DVars.default.S_TEXTURE_FORMAT.S_RGBA, _Texture2DVars.default.S_TEXTURE_FORMAT.S_UNSIGNED_BYTE);
      texture.setImageSrc(this._m_Scene, this._m_BasePath + img.uri);

      if (_Tools.default.checkIsNull(map.sampler)) {
        var sampler = gltf.samplers[map.sampler]; // 设置纹理采样参数

        if (_Tools.default.checkIsNull(sampler)) {
          var magFilter = sampler.magFilter;
          var minFilter = sampler.minFilter;

          if (magFilter && minFilter) {
            texture.setFilter(this._m_Scene, GLTFLoader.FILTERS[minFilter], GLTFLoader.FILTERS[magFilter]);
          }

          var wrapS = sampler.wrapS;
          var wrapT = sampler.wrapT;

          if (wrapS && wrapT) {
            texture.setWrap(this._m_Scene, GLTFLoader.WRAPS[wrapS], GLTFLoader.WRAPS[wrapT]);
          }
        }
      }

      return texture;
    }
  }, {
    key: "_parseMaterial",
    value: function _parseMaterial(gltf, i, material) {
      var _material = gltf.materials[i]; // metallic管道

      if (_material['pbrMetallicRoughness']) {
        var pbrMetallicRoughness = _material['pbrMetallicRoughness'];
        var baseColorFactor = pbrMetallicRoughness.baseColorFactor;

        if (_Tools.default.checkIsNull(baseColorFactor)) {
          material.setParam('baseColor', new _Vec4Vars.default().valueFromXYZW(baseColorFactor[0], baseColorFactor[1], baseColorFactor[2], baseColorFactor[3]));
        }

        var roughnessFactor = pbrMetallicRoughness.roughnessFactor;

        if (_Tools.default.checkIsNull(roughnessFactor)) {
          material.setParam('roughness', new _FloatVars.default().valueOf(roughnessFactor));
        }

        var metallicFactor = pbrMetallicRoughness.metallicFactor;

        if (_Tools.default.checkIsNull(metallicFactor)) {
          material.setParam('metallic', new _FloatVars.default().valueOf(metallicFactor));
        }

        var baseColorTexture = pbrMetallicRoughness.baseColorTexture;

        if (_Tools.default.checkIsNull(baseColorTexture)) {
          material.setParam('baseColorMap', this._samplerMap(gltf, baseColorTexture.index, true));
        }

        var metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;

        if (_Tools.default.checkIsNull(metallicRoughnessTexture)) {
          material.setParam('metallicRoughnessMap', this._samplerMap(gltf, metallicRoughnessTexture.index));
        }
      } // specular管道


      if (_material.extensions && _material.extensions['KHR_materials_pbrSpecularGlossiness']) {
        var KHR_materials_pbrSpecularGlossiness = _material.extensions["KHR_materials_pbrSpecularGlossiness"];
        material.setParam('useSpecGloss', new _BoolVars.default().valueOf(true));
        var diffuseTexture = KHR_materials_pbrSpecularGlossiness.diffuseTexture;

        if (_Tools.default.checkIsNull(diffuseTexture)) {
          material.setParam('baseColorMap', this._samplerMap(gltf, diffuseTexture.index, true));
        }

        var specularGlossinessTexture = KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture;

        if (_Tools.default.checkIsNull(specularGlossinessTexture)) {
          material.setParam('specularGlossinessMap', this._samplerMap(gltf, specularGlossinessTexture.index, true));
        }
      }

      var normalTexture = _material.normalTexture;

      if (_Tools.default.checkIsNull(normalTexture)) {
        // 可能还需要解析scale
        material.setParam('normalMap', this._samplerMap(gltf, normalTexture.index));
      }

      var occlusionTexture = _material.occlusionTexture;

      if (_Tools.default.checkIsNull(occlusionTexture)) {
        var texCoord = occlusionTexture.texCoord;
        material.setParam('lightMap', this._samplerMap(gltf, occlusionTexture.index, true));

        if (texCoord != null && texCoord != 0) {// 激活独立通道纹理
        } else {
          material.setParam('aoMap', new _BoolVars.default().valueOf(true));
        }
      }

      var emissiveFactor = _material.emissiveFactor;

      if (_Tools.default.checkIsNull(emissiveFactor)) {
        material.setParam('emissive', new _Vec4Vars.default().valueFromXYZW(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], 1.0));
      }

      var emissiveTexture = _material.emissiveTexture;

      if (_Tools.default.checkIsNull(emissiveTexture)) {
        material.setParam('emissiveMap', this._samplerMap(gltf, emissiveTexture.index, true));
      }

      var renderState = {};

      if (_material.alphaMode) {
        renderState.alphaMode = _material.alphaMode;
      }

      if (_material.doubleSided) {
        renderState.doubleSided = _material.doubleSided;
      }

      material.renderState = renderState;
    }
  }, {
    key: "_parsePositions",
    value: function _parsePositions(gltf, i) {
      var _positionsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_positionsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var positions = new GLTFLoader.DATA[_positionsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_positionsAccessors.byteOffset || 0), _positionsAccessors.count * 3);
      return {
        data: positions,
        bufType: _positionsAccessors.componentType
      };
    }
  }, {
    key: "_parseTangents",
    value: function _parseTangents(gltf, i) {
      var _tangentsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_tangentsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var tangents = new GLTFLoader.DATA[_tangentsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_tangentsAccessors.byteOffset || 0), _tangentsAccessors.count * 4);
      return {
        data: tangents,
        bufType: _tangentsAccessors.componentType
      };
    }
  }, {
    key: "_parseNormals",
    value: function _parseNormals(gltf, i) {
      var _normalsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_normalsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var normals = new GLTFLoader.DATA[_normalsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_normalsAccessors.byteOffset || 0), _normalsAccessors.count * 3);
      return {
        data: normals,
        bufType: _normalsAccessors.componentType
      };
    }
  }, {
    key: "_parseTexcoords",
    value: function _parseTexcoords(gltf, i) {
      var _texcoordsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_texcoordsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var texcoords = new GLTFLoader.DATA[_texcoordsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_texcoordsAccessors.byteOffset || 0), _texcoordsAccessors.count * 2);
      return {
        data: texcoords,
        bufType: _texcoordsAccessors.componentType
      };
    }
  }, {
    key: "_parseIndices",
    value: function _parseIndices(gltf, i) {
      var _indicessAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_indicessAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var indices = new GLTFLoader.DATA[_indicessAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_indicessAccessors.byteOffset || 0), _indicessAccessors.count);
      return {
        data: indices,
        bufType: _indicessAccessors.componentType
      };
    }
  }, {
    key: "_parseJoints",
    value: function _parseJoints(gltf, i) {
      var _jointsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_jointsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var joints = new GLTFLoader.DATA[_jointsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_jointsAccessors.byteOffset || 0), _jointsAccessors.count * 4);
      return {
        data: joints,
        bufType: _jointsAccessors.componentType
      };
    }
  }, {
    key: "_parseWeights",
    value: function _parseWeights(gltf, i) {
      var _weightsAccessors = gltf.accessors[i]; // 解析

      var _buffers = gltf.buffers;
      var _bufferView = gltf.bufferViews[_weightsAccessors.bufferView];
      var _buffer = _buffers[_bufferView.buffer].data; // 后续应该统一缓存,而不是每次newFloat32Array
      // 然后通过accessors.byteOffset和count来截取

      var weights = new GLTFLoader.DATA[_weightsAccessors.componentType](_buffer, (_bufferView.byteOffset || 0) + (_weightsAccessors.byteOffset || 0), _weightsAccessors.count * 4);
      return {
        data: weights,
        bufType: _weightsAccessors.componentType
      };
    }
  }]);

  return GLTFLoader;
}();

exports["default"] = GLTFLoader;

_defineProperty(GLTFLoader, "DATA", {
  5121: Uint8Array,
  5123: Uint16Array,
  5124: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
});

_defineProperty(GLTFLoader, "DATA_COMPONENT", {
  'SCALAR': 1,
  'VEC3': 3,
  'VEC4': 4,
  'MAT4': 16
});

_defineProperty(GLTFLoader, "FILTERS", {
  9729: _Texture2DVars.default.S_FILTERS.S_LINEAR,
  9728: _Texture2DVars.default.S_FILTERS.S_NEAREST,
  9987: _Texture2DVars.default.S_FILTERS.S_LINEAR_MIPMAP_LINEAR,
  9986: _Texture2DVars.default.S_FILTERS.S_NEAREST_MIPMAP_LINEAR,
  9985: _Texture2DVars.default.S_FILTERS.S_LINEAR_MIPMAP_NEAREST,
  9984: _Texture2DVars.default.S_FILTERS.S_NEAREST_MIPMAP_NEAREST
});

_defineProperty(GLTFLoader, "WRAPS", {
  10497: _Texture2DVars.default.S_WRAPS.S_REPEAT,
  33071: _Texture2DVars.default.S_WRAPS.S_CLAMP_TO_EDGE
});

/***/ }),

/***/ 8236:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _Geometry = _interopRequireDefault(__webpack_require__(4720));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _Vec4Vars = _interopRequireDefault(__webpack_require__(2462));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

var _Vector = _interopRequireDefault(__webpack_require__(7141));

var _Texture2DVars = _interopRequireDefault(__webpack_require__(5141));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * OBJLoader。<br/>
 * 提供OBJ模型加载支持,未来将提供将OBJ模型材质强制转为PBR材质的选项。<br/>
 * @author Kkk
 * @date 2021年2月28日13点34分
 */
var OBJLoader = /*#__PURE__*/function () {
  function OBJLoader() {
    _classCallCheck(this, OBJLoader);

    _defineProperty(this, "_m_CustomMatDef", 'BasicLightingDef');

    _defineProperty(this, "_m_AlphaMode", OBJLoader.S_ALPHA_MODE_BLEND);
  }

  _createClass(OBJLoader, [{
    key: "load",
    value:
    /**
     * 加载一个OBJ模型。<br/>
     * @param {Scene}[scene]
     * @param {String}[modelId 可选的ID,表示加载OBJ模型后返回的根节点的ID,如果为null则系统自动分配]
     * @param {String}[src]
     * @param {Function}[callback]
     */
    function load(scene, modelId, src, callback) {
      this._m_Scene = scene;
      this._m_DefaultMatDef = null;
      this._m_Mats = {};
      this._m_CurrentMat = null;
      var modelNode = new _Node.default(scene, {
        id: modelId || _Tools.default.nextId()
      }); // 加载obj模型

      this._load(modelNode, src, callback);
    }
  }, {
    key: "config",
    value: function config(_config) {
      this._m_AlphaMode = _config.alphaMode || this._m_AlphaMode;
    }
    /**
     * 设置Assets路径和自定义要加载的材质定义。<br/>
     * @param {String}[assetsPath]
     * @param {String}[customMatDef]
     */

  }, {
    key: "setAssetsPath",
    value: function setAssetsPath(assetsPath, customMatDef) {
      this._m_AssetsPath = assetsPath;

      if (customMatDef) {
        this._m_CustomMatDef = customMatDef;
      }
    }
  }, {
    key: "_load",
    value: function _load(modelNode, src, callback) {
      var _this = this;

      // 解析OBJ数据块
      this.loadOBJ(modelNode, src, function (state) {
        if (!_this._m_DefaultMatDef) {
          if (_this._m_AssetsPath && _this._m_CustomMatDef) {
            _this._m_DefaultMatDef = _MaterialDef.default.load(_this._m_AssetsPath + _this._m_CustomMatDef);
          } else {
            _this._m_DefaultMatDef = _MaterialDef.default.parse(_Internal.default.S_BASIC_LIGHTING_DEF_DATA);
          }
        } // 加载完实例材质后再创建obj实体


        _this.loadMTLs(modelNode, state, function () {
          _this.createMeshes(modelNode, state); // 加载完成


          if (callback) {
            callback(modelNode);
          }
        });
      });
    }
  }, {
    key: "loadOBJ",
    value: function loadOBJ(modelNode, url, ok) {
      var _this2 = this;

      this.loadFile(url, function (text) {
        var state = _this2.parseOBJ(modelNode, text, url);

        ok(state);
      }, function (error) {
        _Log.default.error(error);
      });
    }
  }, {
    key: "parseOBJ",
    value: function parseOBJ(modelNode, text, url) {
      var regexp = {
        // v float float float
        vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vn float float float
        normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // vt float float
        uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        // f vertex vertex vertex
        face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        // f vertex/uv vertex/uv vertex/uv
        face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
        face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        // f vertex//normal vertex//normal vertex//normal
        face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        // o object_name | g group_name
        object_pattern: /^[og]\s*(.+)?/,
        // s boolean
        smoothing_pattern: /^s\s+(\d+|on|off)/,
        // mtllib file_reference
        material_library_pattern: /^mtllib /,
        // usemtl material_name
        material_use_pattern: /^usemtl /
      };
      url = url || "";
      var state = {
        src: url,
        basePath: this.getBasePath(url),
        objects: [],
        object: {},
        positions: [],
        normals: [],
        uv: [],
        materialLibraries: {}
      };
      this.startObject(state, "", false); // 解析逻辑一部分移植自:
      // https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js

      if (text.indexOf('\r\n') !== -1) {
        // 这比使用regex的String.split更快，后者将两者都拆分
        text = text.replace('\r\n', '\n');
      }

      var lines = text.split('\n');
      var line = '',
          lineFirstChar = '',
          lineSecondChar = '';
      var lineLength = 0;
      var result = []; // 更快地修剪线的左侧。 如果可用，请使用。

      var trimLeft = typeof ''.trimLeft === 'function';

      for (var i = 0, l = lines.length; i < l; i++) {
        line = lines[i];
        line = trimLeft ? line.trimLeft() : line.trim();
        lineLength = line.length;

        if (lineLength === 0) {
          continue;
        }

        lineFirstChar = line.charAt(0);

        if (lineFirstChar === '#') {
          continue;
        }

        if (lineFirstChar === 'v') {
          lineSecondChar = line.charAt(1);

          if (lineSecondChar === ' ' && (result = regexp.vertex_pattern.exec(line)) !== null) {
            // 0                  1      2      3
            // ['v 1.0 2.0 3.0', '1.0', '2.0', '3.0']
            state.positions.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
          } else if (lineSecondChar === 'n' && (result = regexp.normal_pattern.exec(line)) !== null) {
            // 0                   1      2      3
            // ['vn 1.0 2.0 3.0', '1.0', '2.0', '3.0']
            state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
          } else if (lineSecondChar === 't' && (result = regexp.uv_pattern.exec(line)) !== null) {
            // 0               1      2
            // ['vt 0.1 0.2', '0.1', '0.2']
            state.uv.push(parseFloat(result[1]), parseFloat(result[2]));
          } else {
            _Log.default.error('Unexpected vertex/normal/uv line: \'' + line + '\'');

            return;
          }
        } else if (lineFirstChar === 'f') {
          if ((result = regexp.face_vertex_uv_normal.exec(line)) !== null) {
            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
            // 0                        1    2    3    4    5    6    7    8    9   10         11         12
            // ['f 1/1/1 2/2/2 3/3/3', '1', '1', '1', '2', '2', '2', '3', '3', '3', undefined, undefined, undefined]
            this.addFace(state, result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
          } else if ((result = regexp.face_vertex_uv.exec(line)) !== null) {
            // f vertex/uv vertex/uv vertex/uv
            // 0                  1    2    3    4    5    6   7          8
            // ['f 1/1 2/2 3/3', '1', '1', '2', '2', '3', '3', undefined, undefined]
            this.addFace(state, result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);
          } else if ((result = regexp.face_vertex_normal.exec(line)) !== null) {
            // f vertex//normal vertex//normal vertex//normal
            // 0                     1    2    3    4    5    6   7          8
            // ['f 1//1 2//2 3//3', '1', '1', '2', '2', '3', '3', undefined, undefined]
            this.addFace(state, result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);
          } else if ((result = regexp.face_vertex.exec(line)) !== null) {
            // f vertex vertex vertex
            // 0            1    2    3   4
            // ['f 1 2 3', '1', '2', '3', undefined]
            this.addFace(state, result[1], result[2], result[3], result[4]);
          } else {
            _Log.default.error('Unexpected face line: \'' + line + '\'');

            return;
          }
        } else if (lineFirstChar === 'l') {
          var lineParts = line.substring(1).trim().split(' ');
          var lineVertices = [],
              lineUVs = [];

          if (line.indexOf('/') === -1) {
            lineVertices = lineParts;
          } else {
            for (var li = 0, llen = lineParts.length; li < llen; li++) {
              var parts = lineParts[li].split('/');

              if (parts[0] !== '') {
                lineVertices.push(parts[0]);
              }

              if (parts[1] !== '') {
                lineUVs.push(parts[1]);
              }
            }
          }

          this.addLineGeometry(state, lineVertices, lineUVs);
        } else if ((result = regexp.object_pattern.exec(line)) !== null) {
          // o object_name
          // or
          // g group_name
          var id = result[0].substr(1).trim();
          this.startObject(state, id, true);
        } else if (regexp.material_use_pattern.test(line)) {
          // material
          var _id = line.substring(7).trim();

          state.object.material.id = _id;
        } else if (regexp.material_library_pattern.test(line)) {
          // mtl file
          state.materialLibraries[line.substring(7).trim()] = true;
        } else if ((result = regexp.smoothing_pattern.exec(line)) !== null) {
          // smooth shading
          var value = result[1].trim().toLowerCase();
          state.object.material.smooth = value === '1' || value === 'on';
        } else {
          // 跳过空白文件指令
          if (line === '\0') {
            continue;
          }

          _Log.default.error('Unexpected line: \'' + line + '\'');

          return;
        }
      }

      return state;
    }
  }, {
    key: "getBasePath",
    value: function getBasePath(src) {
      var n = src.lastIndexOf('/');
      return n === -1 ? src : src.substring(0, n + 1);
    }
  }, {
    key: "startObject",
    value: function startObject(state, id, fromDeclaration) {
      if (state.object && state.object.fromDeclaration === false) {
        state.object.id = id;
        state.object.fromDeclaration = fromDeclaration !== false;
        return;
      }

      state.object = {
        id: id || '',
        geometry: {
          positions: [],
          normals: [],
          uv: []
        },
        material: {
          id: '',
          smooth: true
        },
        fromDeclaration: fromDeclaration !== false
      };
      state.objects.push(state.object);
    }
  }, {
    key: "parseVertexIndex",
    value: function parseVertexIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
  }, {
    key: "parseNormalIndex",
    value: function parseNormalIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    }
  }, {
    key: "parseUVIndex",
    value: function parseUVIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    }
  }, {
    key: "addVertex",
    value: function addVertex(state, a, b, c) {
      var src = state.positions;
      var dst = state.object.geometry.positions;
      dst.push(src[a + 0]);
      dst.push(src[a + 1]);
      dst.push(src[a + 2]);
      dst.push(src[b + 0]);
      dst.push(src[b + 1]);
      dst.push(src[b + 2]);
      dst.push(src[c + 0]);
      dst.push(src[c + 1]);
      dst.push(src[c + 2]);
    }
    /**
     * 添加一个VertexLine数据。<br/>
     * @param {Object}[state]
     * @param a
     */

  }, {
    key: "addVertexLine",
    value: function addVertexLine(state, a) {
      var src = state.positions;
      var dst = state.object.geometry.positions;
      dst.push(src[a + 0]);
      dst.push(src[a + 1]);
      dst.push(src[a + 2]);
    }
    /**
     * 添加Normal。<br/>
     * @param {Object}[state]
     * @param a
     * @param b
     * @param c
     */

  }, {
    key: "addNormal",
    value: function addNormal(state, a, b, c) {
      var src = state.normals;
      var dst = state.object.geometry.normals;
      dst.push(src[a + 0]);
      dst.push(src[a + 1]);
      dst.push(src[a + 2]);
      dst.push(src[b + 0]);
      dst.push(src[b + 1]);
      dst.push(src[b + 2]);
      dst.push(src[c + 0]);
      dst.push(src[c + 1]);
      dst.push(src[c + 2]);
    }
    /**
     * 添加一个UV。<br/>
     * @param {Object}[state]
     * @param a
     * @param b
     * @param c
     */

  }, {
    key: "addUV",
    value: function addUV(state, a, b, c) {
      var src = state.uv;
      var dst = state.object.geometry.uv;
      dst.push(src[a + 0]);
      dst.push(src[a + 1]);
      dst.push(src[b + 0]);
      dst.push(src[b + 1]);
      dst.push(src[c + 0]);
      dst.push(src[c + 1]);
    }
    /**
     * 添加一个UVLine。<br/>
     * @param {Object}[state]
     * @param a
     */

  }, {
    key: "addUVLine",
    value: function addUVLine(state, a) {
      var src = state.uv;
      var dst = state.object.geometry.uv;
      dst.push(src[a + 0]);
      dst.push(src[a + 1]);
    }
    /**
     * 添加一个Face。<br/>
     * @param {Object}[state]
     * @param a
     * @param b
     * @param c
     * @param d
     * @param ua
     * @param ub
     * @param uc
     * @param ud
     * @param na
     * @param nb
     * @param nc
     * @param nd
     */

  }, {
    key: "addFace",
    value: function addFace(state, a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
      var vLen = state.positions.length;
      var ia = this.parseVertexIndex(a, vLen);
      var ib = this.parseVertexIndex(b, vLen);
      var ic = this.parseVertexIndex(c, vLen);
      var id;

      if (d === undefined) {
        this.addVertex(state, ia, ib, ic);
      } else {
        id = this.parseVertexIndex(d, vLen);
        this.addVertex(state, ia, ib, id);
        this.addVertex(state, ib, ic, id);
      }

      if (ua !== undefined) {
        var uvLen = state.uv.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);

        if (d === undefined) {
          this.addUV(state, ia, ib, ic);
        } else {
          id = this.parseUVIndex(ud, uvLen);
          this.addUV(state, ia, ib, id);
          this.addUV(state, ib, ic, id);
        }
      }

      if (na !== undefined) {
        // 法线多次相同。 如果是这样，请跳过函数调用和parseInt。
        var nLen = state.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
        ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);

        if (d === undefined) {
          this.addNormal(state, ia, ib, ic);
        } else {
          id = this.parseNormalIndex(nd, nLen);
          this.addNormal(state, ia, ib, id);
          this.addNormal(state, ib, ic, id);
        }
      }
    }
    /**
     * 添加一个Line几何数据。<br/>
     * @param {Object}[state]
     * @param {Number[]}[positions]
     * @param {Number[]}[uv]
     */

  }, {
    key: "addLineGeometry",
    value: function addLineGeometry(state, positions, uv) {
      state.object.geometry.type = 'Line';
      var vLen = state.positions.length;
      var uvLen = state.uv.length;

      for (var vi = 0, l = positions.length; vi < l; vi++) {
        this.addVertexLine(state, this.parseVertexIndex(positions[vi], vLen));
      }

      for (var uvi = 0, uvl = uv.length; uvi < uvl; uvi++) {
        this.addUVLine(state, this.parseUVIndex(uv[uvi], uvLen));
      }
    }
    /**
     * 加载以解析状态列出的MTL文件。<br/>
     * @param {Node}[modelNode]
     * @param {Object}[state]
     * @param {Function}[ok]
     */

  }, {
    key: "loadMTLs",
    value: function loadMTLs(modelNode, state, ok) {
      var basePath = state.basePath;
      var srcList = Object.keys(state.materialLibraries);
      var numToLoad = srcList.length;

      for (var i = 0, len = numToLoad; i < len; i++) {
        this.loadMTL(modelNode, basePath, basePath + srcList[i], function () {
          if (--numToLoad === 0) {
            ok();
          }
        });
      }
    }
    /**
     * 加载一个MTL文件。<br/>
     * @param {Node}[modelNode]
     * @param {String}[basePath 表示obj模型的路径,用于加载mtl文件]
     * @param {String}[src obj模型路径]
     * @param {Function}[ok 回调]
     */

  }, {
    key: "loadMTL",
    value: function loadMTL(modelNode, basePath, src, ok) {
      var _this3 = this;

      this.loadFile(src, function (text) {
        _this3.parseMTL(modelNode, text, basePath);

        ok();
      }, function (error) {
        _Log.default.error(error);

        ok();
      });
    }
  }, {
    key: "createTexture",
    value: function createTexture(modelNode, basePath, value, encoding) {
      var textureCfg = {};
      var items = value.split(/\s+/);
      var pos = items.indexOf('-bm');

      if (pos >= 0) {
        //matParams.bumpScale = parseFloat(items[pos + 1]);
        items.splice(pos, 2);
      }

      pos = items.indexOf('-s');

      if (pos >= 0) {
        textureCfg.scale = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
        items.splice(pos, 4); // 只需要3个参数
      }

      pos = items.indexOf('-o');

      if (pos >= 0) {
        textureCfg.translate = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
        items.splice(pos, 4); // 只需要3个参数
      }

      textureCfg.src = basePath + items.join(' ').trim();
      textureCfg.flipY = true;
      textureCfg.encoding = encoding || "linear"; //textureCfg.wrapS = self.wrap;
      //textureCfg.wrapT = self.wrap;

      var texture = new _Texture2DVars.default(this._m_Scene);

      if (textureCfg.encoding == 'sRGB') {
        texture.setTextureFormat(_Texture2DVars.default.S_TEXTURE_FORMAT.S_SRGBA, _Texture2DVars.default.S_TEXTURE_FORMAT.S_RGBA, _Texture2DVars.default.S_TEXTURE_FORMAT.S_UNSIGNED_BYTE);
      }

      texture.setPreloadColor(this._m_Scene, new _Vector.default(0.2, 0.2, 0.2, 1.0));
      texture.setImageSrc(this._m_Scene, textureCfg.src);
      texture.setFlipY(true);
      return texture;
    }
  }, {
    key: "createMaterial",
    value: function createMaterial(modelNode, materialCfg) {
      // obj模型材质使用经典phong
      if (this._m_DefaultMatDef) {
        if (!this._m_Mats[materialCfg.id]) {
          var basicLightingMat = new _Material.default(this._m_Scene, {
            id: materialCfg.id,
            materialDef: this._m_DefaultMatDef
          });
          this._m_Mats[materialCfg.id] = basicLightingMat;
          this._m_CurrentMat = basicLightingMat; // 初始参数

          this._m_CurrentMat.setParam('diffuseColor', new _Vec4Vars.default().valueFromXYZW(0.5, 0.5, 0.5, 1.0));

          this._m_CurrentMat.setParam('ambientColor', new _Vec4Vars.default().valueFromXYZW(0.2, 0.2, 0.2, 1.0));

          this._m_CurrentMat.setParam('specularColor', new _Vec4Vars.default().valueFromXYZW(1.0, 1.0, 1.0, 1.0));

          this._m_CurrentMat.setParam('shininess', new _FloatVars.default().valueOf(32.0));
        }
      }
    }
  }, {
    key: "parseRGB",
    value: function parseRGB(value) {
      var delimiter_pattern = /\s+/;
      var ss = value.split(delimiter_pattern, 3);
      return [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
    }
  }, {
    key: "parseMTL",
    value: function parseMTL(modelNode, mtlText, basePath) {
      var lines = mtlText.split('\n');
      var materialCfg = {
        id: "Default"
      };
      var needCreate = false;
      var line;
      var pos;
      var key;
      var value;
      var alpha;
      basePath = basePath || "";

      for (var i = 0; i < lines.length; i++) {
        line = lines[i].trim();

        if (line.length === 0 || line.charAt(0) === '#') {
          // 跳过注释行
          continue;
        }

        pos = line.indexOf(' ');
        key = pos >= 0 ? line.substring(0, pos) : line;
        key = key.toLowerCase();
        value = pos >= 0 ? line.substring(pos + 1) : '';
        value = value.trim();

        switch (key.toLowerCase()) {
          case "newmtl":
            // 添加一个材质实例到内存中
            materialCfg = {
              id: value
            };
            this.createMaterial(modelNode, materialCfg);
            break;

          case 'ka':
            materialCfg.ambient = this.parseRGB(value);

            this._m_CurrentMat.setParam('ambientColor', new _Vec4Vars.default().valueFromXYZW(materialCfg.ambient[0], materialCfg.ambient[1], materialCfg.ambient[2], 1.0));

            break;

          case 'kd':
            materialCfg.diffuse = this.parseRGB(value);

            this._m_CurrentMat.setParam('diffuseColor', new _Vec4Vars.default().valueFromXYZW(materialCfg.diffuse[0], materialCfg.diffuse[1], materialCfg.diffuse[2], 1.0));

            break;

          case 'ks':
            materialCfg.specular = this.parseRGB(value);

            this._m_CurrentMat.setParam('specularColor', new _Vec4Vars.default().valueFromXYZW(materialCfg.specular[0], materialCfg.specular[1], materialCfg.specular[2], 1.0));

            break;

          case 'map_kd':
            if (!materialCfg.diffuseMap) {
              materialCfg.diffuseMap = this.createTexture(modelNode, basePath, value, "sRGB");

              this._m_CurrentMat.setParam('diffuseMap', materialCfg.diffuseMap);
            }

            break;

          case 'map_ks':
            if (!materialCfg.specularMap) {
              materialCfg.specularMap = this.createTexture(modelNode, basePath, value, "linear");

              this._m_CurrentMat.setParam('specularMap', materialCfg.specularMap);
            }

            break;

          case 'map_bump':
          case 'bump':
            if (!materialCfg.normalMap) {
              materialCfg.normalMap = this.createTexture(modelNode, basePath, value);

              this._m_CurrentMat.setParam('normalMap', materialCfg.normalMap);
            }

            break;

          case 'ns':
            materialCfg.shininess = parseFloat(value);

            this._m_CurrentMat.setParam('shininess', new _FloatVars.default().valueOf(materialCfg.shininess));

            break;

          case 'd':
            alpha = parseFloat(value);

            if (alpha <= 0.1) {
              if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_BLEND) {
                this._m_CurrentMat.alphaMode = 'blend';
              } else if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_DISCARD) {
                this._m_CurrentMat.setParam('alphaDiscard', new _FloatVars.default().valueOf(alpha));
              }
            } else {// this._m_CurrentMat.alphaMode = 'blend';
            }

            if (alpha < 1) {
              materialCfg.alpha = alpha;
              if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_BLEND) materialCfg.alphaMode = "blend";
            }

            break;

          case 'tr':
            alpha = parseFloat(value);

            if (alpha <= 0.1) {
              if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_BLEND) this._m_CurrentMat.alphaMode = 'blend';else if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_DISCARD) this._m_CurrentMat.setParam('alphaDiscard', new _FloatVars.default().valueOf(1 - alpha));
            } else {// this._m_CurrentMat.alphaMode = 'blend';
            }

            if (alpha > 0) {
              materialCfg.alpha = 1 - alpha;
              if (this._m_AlphaMode == OBJLoader.S_ALPHA_MODE_BLEND) materialCfg.alphaMode = "blend";
            }

            break;

          default:
        }
      }
    }
  }, {
    key: "createMeshes",
    value: function createMeshes(modelNode, state) {
      _Log.default.debug("state.objects.length:" + state.objects.length); // merge mtl


      var mtlobjs = {};
      var mo = 0;

      for (var j = 0, k = state.objects.length; j < k; j++) {
        var object = state.objects[j];
        var meshData = object.geometry;
        var isLine = meshData.type === 'Line';
        var materialId = object.material.id;
        var material = void 0;
        var unitType = null;

        if (meshData.positions.length === 0) {
          // 跳过无位置几何属性的部分
          continue;
        }

        if (!mtlobjs[materialId]) {
          mo++;
          var indices = new Array(meshData.positions.length / 3); // Triangle soup

          unitType = indices.length > 65534 ? _Mesh.default.S_INDICES_32 : _Mesh.default.S_INDICES;

          for (var idx = 0; idx < indices.length; idx++) {
            indices[idx] = idx;
          } // 创建Mesh


          var mesh = new _Mesh.default();
          mesh.setData(_Mesh.default.S_POSITIONS, meshData.positions);

          if (meshData.normals.length > 0) {
            mesh.setData(_Mesh.default.S_NORMALS, meshData.normals);
          }

          if (meshData.uv.length > 0) {
            mesh.setData(_Mesh.default.S_UV0, meshData.uv);
          }

          mesh.setData(unitType, indices); // 获取引用的材质实例

          if (materialId && materialId !== "") {
            material = this._m_Mats[materialId];

            if (!material) {
              _Log.default.error("Material not found: " + materialId);
            }
          } else {
            // 提供一个默认材质
            if (this._m_DefaultMatDef) {
              if (!this._m_Mats['Default']) {
                var basicLightingMat = new _Material.default(this._m_Scene, {
                  id: 'Default',
                  materialDef: this._m_DefaultMatDef
                });
                this._m_Mats['Default'] = basicLightingMat;
              }

              material = this._m_Mats['Default'];
            }
          }

          mtlobjs[materialId] = {
            mesh: mesh,
            material: material,
            unitType: unitType
          };
        } else {
          (function () {
            var mesh = mtlobjs[materialId].mesh;
            var unitType = mtlobjs[materialId].unitType;
            var meshPosition = mesh.getData(_Mesh.default.S_POSITIONS);
            var indices = new Array(meshData.positions.length / 3); // Triangle soup

            for (var _idx = 0, offset = meshPosition.length / 3; _idx < indices.length; _idx++) {
              indices[_idx] = _idx + offset;
            }

            if (meshPosition) {
              meshData.positions.forEach(function (p) {
                meshPosition.push(p);
              });
            }

            mesh.setData(_Mesh.default.S_POSITIONS, meshPosition);

            if (meshData.normals.length > 0) {
              var meshNormal = mesh.getData(_Mesh.default.S_NORMALS);

              if (meshNormal) {
                meshData.normals.forEach(function (n) {
                  meshNormal.push(n);
                });
              }

              mesh.setData(_Mesh.default.S_NORMALS, meshNormal);
            }

            if (meshData.uv.length > 0) {
              var meshUV = mesh.getData(_Mesh.default.S_UV0);

              if (meshUV) {
                meshData.uv.forEach(function (uv) {
                  meshUV.push(uv);
                });
              }

              mesh.setData(_Mesh.default.S_UV0, meshUV);
            }

            var meshIndice = mesh.getData(unitType);

            if (meshIndice) {
              indices.forEach(function (i) {
                meshIndice.push(i);
              });
            }

            mesh.setData(unitType, meshIndice);
          })();
        }
      }

      if (mo) {
        _Log.default.debug("实体数量:" + mo);

        for (var mt in mtlobjs) {
          var _material = mtlobjs[mt].material;
          var _unitType = mtlobjs[mt].unitType;
          var _mesh = mtlobjs[mt].mesh; // 创建切线

          var uv0s = _mesh.getData(_Mesh.default.S_UV0);

          if (uv0s) {
            // 切线数据
            var tangents = _Tools.default.generatorTangents2(_mesh.getData(_unitType), _mesh.getData(_Mesh.default.S_POSITIONS), _mesh.getData(_Mesh.default.S_UV0), _mesh.getData(_Mesh.default.S_NORMALS));

            _mesh.setData(_Mesh.default.S_TANGENTS, tangents);
          } else {
            // 切线数据
            var _tangents = _Tools.default.generatorFillTangents2(_mesh.getData(_Mesh.default.S_POSITIONS));

            _mesh.setData(_Mesh.default.S_TANGENTS, _tangents);
          } // 创建Geometry


          var geometry = new _Geometry.default(modelNode, {
            id: 'Geo_' + mt
          });
          geometry.setMesh(_mesh);
          geometry.setMaterial(_material);
          geometry.updateBound();

          if (_material.alphaMode) {
            geometry.setTranslucent();
          }

          modelNode.addChildren(geometry);
        }
      }
    }
  }, {
    key: "loadFile",
    value: function loadFile(url, ok, err) {
      var request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        var response = event.target.response;

        if (request.status === 200) {
          if (ok) {
            ok(response);
          }
        } else if (request.status === 0) {
          // 某些浏览器在使用非HTTP协议时会返回HTTP状态0
          // 例如 “文件：//”或“数据：//”。 处理成功。
          _Log.default.warn('loadFile: HTTP Status 0 received.');

          if (ok) {
            ok(response);
          }
        } else {
          if (err) {
            err(event);
          }
        }
      }, false);
      request.addEventListener('error', function (event) {
        if (err) {
          err(event);
        }
      }, false);
      request.send(null);
    }
  }]);

  return OBJLoader;
}();

exports["default"] = OBJLoader;

_defineProperty(OBJLoader, "S_ALPHA_MODE_BLEND", 'blend');

_defineProperty(OBJLoader, "S_ALPHA_MODE_DISCARD", 'discard');

/***/ }),

/***/ 6797:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _hdrpng = _interopRequireDefault(__webpack_require__(3319));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RadianceLoader = /*#__PURE__*/function () {
  function RadianceLoader() {
    _classCallCheck(this, RadianceLoader);
  }

  _createClass(RadianceLoader, [{
    key: "loadHDR",
    value:
    /**
     * 加载HDR纹理数据。<br/>
     * @param {String}[src]
     * @param {Function}[callback]
     */
    function loadHDR(src, callback) {
      var image = RadianceLoader.rgbeImg();

      image.onload = function () {
        callback(image);
      };

      image.src = src;
    }
  }], [{
    key: "rgbeImg",
    value: function rgbeImg() {
      return new _hdrpng.default().HDRImage();
    }
  }]);

  return RadianceLoader;
}();

exports["default"] = RadianceLoader;

/***/ }),

/***/ 3319:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * hdrpng.js - support for Radiance .HDR and RGBE / RGB9_E5 images in PNG.
 * @author Enki
 * @desc load/save Radiance .HDR, RGBE in PNG and RGB9_E5 in PNG for HTML5, webGL, webGL2.
 */

/**
 * HDRImage - wrapper that exposes default Image like interface for HDR imgaes. (till extending HTMLCanvasElement actually works ..)
 * @returns {HDRImage} a html HDR image element
 */
function HDRImage() {
  var res = document.createElement('canvas'),
      HDRsrc = 't',
      HDRexposure = 1.0,
      HDRgamma = 2.2,
      HDRdata = null,
      context,
      HDRD;

  res.__defineGetter__('exposure', function () {
    return HDRexposure;
  });

  res.__defineSetter__('exposure', function (val) {
    HDRexposure = val;

    if (HDRdata) {
      rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
      context.putImageData(HDRD, 0, 0);
    }
  });

  res.__defineGetter__('gamma', function () {
    return HDRgamma;
  });

  res.__defineSetter__('gamma', function (val) {
    HDRgamma = val;

    if (HDRdata) {
      rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
      context.putImageData(HDRD, 0, 0);
    }
  });

  res.__defineGetter__('dataFloat', function () {
    return rgbeToFloat(HDRdata);
  });

  res.__defineGetter__('dataRGBE', function () {
    return HDRdata;
  });

  res.toHDRBlob = function (cb, m, q) {
    // Array to image.. slightly more involved.
    function createShader(gl, source, type) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      return shader;
    }

    function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
      var program = gl.createProgram(),
          vs,
          fs;
      gl.attachShader(program, vs = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER));
      gl.attachShader(program, fs = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER));
      gl.linkProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return program;
    }

    ;
    var ar = m && m.match(/rgb9_e5/i) ? new Uint8Array(floatToRgb9_e5(rgbeToFloat(HDRdata)).buffer) : new Uint8Array(HDRdata.buffer);
    var vs2 = 'precision highp float;\nattribute vec3 position;\nvarying vec2 tex;\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }';
    var fs2 = 'precision highp float;\nprecision highp sampler2D;\nuniform sampler2D tx;\nvarying vec2 tex;\nvoid main() { gl_FragColor = texture2D(tx,tex); }';
    var x = this.width,
        y = this.height;
    if (x * y * 4 < ar.byteLength) return console.error('not big enough.');
    var c = document.createElement('canvas');
    c.width = x;
    c.height = y;
    var gl = c.getContext('webgl', {
      antialias: false,
      alpha: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: true
    });
    var texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, x, y, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(ar.buffer));
    var program = createProgram(gl, vs2, fs2),
        uniformTexLocation = gl.getUniformLocation(program, 'tx');
    var positions = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0]),
        vertexPosBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(0);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
    gl.useProgram(program);
    gl.uniform1i(uniformTexLocation, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteTexture(texture);
    gl.deleteProgram(program);
    if (cb) return c.toBlob(cb);
  };

  res.__defineGetter__('src', function () {
    return HDRsrc;
  });

  res.__defineSetter__('src', function (val) {
    HDRsrc = val;
    context && context.clearRect(0, 0, this.width, this.height);
    if (val.match(/\.hdr$/i)) loadHDR(val, function (img, width, height) {
      HDRdata = img;
      this.width = this.style.width = width;
      this.height = this.style.height = height;
      context = this.getContext('2d');
      HDRD = context.getImageData(0, 0, width, height);
      rgbeToLDR(img, HDRexposure, HDRgamma, HDRD.data);
      context.putImageData(HDRD, 0, 0);
      this.onload && this.onload();
    }.bind(res));else if (val.match(/\.rgb9_e5\.png$/i)) {
      var i = new Image();
      i.src = val;

      i.onload = function () {
        var c = document.createElement('canvas'),
            x = this.width = this.style.width = c.width = i.width,
            y = this.height = this.style.height = c.height = i.height,
            gl = c.getContext('webgl');
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);
        fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        var res = new Uint8Array(x * y * 4);
        gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fb);
        this.dataRAW = new Uint32Array(res.buffer);
        HDRdata = floatToRgbe(rgb9_e5ToFloat(this.dataRAW));
        context = this.getContext('2d');
        HDRD = context.getImageData(0, 0, x, y);
        rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
        context.putImageData(HDRD, 0, 0);
        this.onload && this.onload();
      }.bind(res);
    } else if (val.match(/\.hdr\.png$|\.rgbe\.png/i)) {
      var i = new Image();
      i.src = val;

      i.onload = function () {
        var c = document.createElement('canvas'),
            x = this.width = this.style.width = c.width = i.width,
            y = this.height = this.style.height = c.height = i.height,
            gl = c.getContext('webgl');
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);
        fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        var res = new Uint8Array(x * y * 4);
        gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fb);
        HDRdata = res;
        context = this.getContext('2d');
        HDRD = context.getImageData(0, 0, x, y);
        rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
        context.putImageData(HDRD, 0, 0);
        this.onload && this.onload();
      }.bind(res);
    }
  });

  return res;
}

function m(a, b) {
  for (var i in b) {
    a[i] = b[i];
  }

  return a;
}

;
/** Load and parse a Radiance .HDR file. It completes with a 32bit RGBE buffer.
 * @param {URL} url location of .HDR file to load.
 * @param {function} completion completion callback.
 * @returns {XMLHttpRequest} the XMLHttpRequest used to download the file.
 */

function loadHDR(url, completion) {
  var req = m(new XMLHttpRequest(), {
    responseType: "arraybuffer"
  });
  req.onerror = completion.bind(req, false);

  req.onload = function () {
    if (this.status >= 400) return this.onerror();
    var header = '',
        pos = 0,
        d8 = new Uint8Array(this.response),
        format; // read header.

    while (!header.match(/\n\n[^\n]+\n/g)) {
      header += String.fromCharCode(d8[pos++]);
    } // check format.


    format = header.match(/FORMAT=(.*)$/m)[1];
    if (format != '32-bit_rle_rgbe') return console.warn('unknown format : ' + format), this.onerror(); // parse resolution

    var rez = header.split(/\n/).reverse()[1].split(' '),
        width = rez[3] * 1,
        height = rez[1] * 1; // Create image.

    var img = new Uint8Array(width * height * 4),
        ipos = 0; // Read all scanlines

    for (var j = 0; j < height; j++) {
      var rgbe = d8.slice(pos, pos += 4),
          scanline = [];

      if (rgbe[0] != 2 || rgbe[1] != 2 || rgbe[2] & 0x80) {
        var len = width,
            rs = 0;
        pos -= 4;

        while (len > 0) {
          img.set(d8.slice(pos, pos += 4), ipos);

          if (img[ipos] == 1 && img[ipos + 1] == 1 && img[ipos + 2] == 1) {
            for (img[ipos + 3] << rs; i > 0; i--) {
              img.set(img.slice(ipos - 4, ipos), ipos);
              ipos += 4;
              len--;
            }

            rs += 8;
          } else {
            len--;
            ipos += 4;
            rs = 0;
          }
        }
      } else {
        if ((rgbe[2] << 8) + rgbe[3] != width) return console.warn('HDR line mismatch ..'), this.onerror();

        for (var i = 0; i < 4; i++) {
          var ptr = i * width,
              ptr_end = (i + 1) * width,
              buf,
              count;

          while (ptr < ptr_end) {
            buf = d8.slice(pos, pos += 2);

            if (buf[0] > 128) {
              count = buf[0] - 128;

              while (count-- > 0) {
                scanline[ptr++] = buf[1];
              }
            } else {
              count = buf[0] - 1;
              scanline[ptr++] = buf[1];

              while (count-- > 0) {
                scanline[ptr++] = d8[pos++];
              }
            }
          }
        }

        for (var i = 0; i < width; i++) {
          img[ipos++] = scanline[i];
          img[ipos++] = scanline[i + width];
          img[ipos++] = scanline[i + 2 * width];
          img[ipos++] = scanline[i + 3 * width];
        }
      }
    }

    completion && completion(img, width, height);
  };

  req.open("GET", url, true);
  req.send(null);
  return req;
}
/** Convert a float buffer to a RGB9_E5 buffer. (ref https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt)
 * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).
 * @param {Uint32Array} [res] Optional output buffer with 32 bit RGB9_E5 per pixel.
 * @returns {Uint32Array} A 32bit uint32 array in RGB9_E5
 */


function floatToRgb9_e5(buffer, res) {
  var r,
      g,
      b,
      v,
      maxColor,
      ExpShared,
      denom,
      s,
      l = buffer.byteLength / 12 | 0,
      res = res || new Uint32Array(l);

  for (var i = 0; i < l; i++) {
    r = Math.min(32768.0, buffer[i * 3]);
    g = Math.min(32768.0, buffer[i * 3 + 1]);
    b = Math.min(32768.0, buffer[i * 3 + 2]);
    maxColor = Math.max(Math.max(r, g), b);
    ExpShared = Math.max(-16, Math.floor(Math.log2(maxColor))) + 16;
    denom = Math.pow(2, ExpShared - 24);

    if (Math.floor(maxColor / denom + 0.5) == 511) {
      denom *= 2;
      ExpShared += 1;
    }

    res[i] = (Math.floor(r / denom + 0.5) << 23) + (Math.floor(g / denom + 0.5) << 14) + (Math.floor(b / denom + 0.5) << 5) + (ExpShared | 0);
  }

  return res;
}
/** Convert an RGB9_E5 buffer to a Float buffer.
 * @param {Uint32Array} Buffer in RGB9_E5 format. (Uint32 buffer).
 * @param {Float32Array} [res] Optional float output buffer.
 * @returns {Float32Array} A Float32Array.
 */


function rgb9_e5ToFloat(buffer, res) {
  var v,
      s,
      l = buffer.byteLength >> 2,
      res = res || new Float32Array(l * 3);

  for (var i = 0; i < l; i++) {
    v = buffer[i];
    s = Math.pow(2, (v & 31) - 24);
    res[i * 3] = (v >>> 23) * s;
    res[i * 3 + 1] = (v >>> 14 & 511) * s;
    res[i * 3 + 2] = (v >>> 5 & 511) * s;
  }

  return res;
}
/** Convert a float buffer to a RGBE buffer.
 * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).
 * @param {Uint8Array} [res] Optional output buffer with 32 bit RGBE per pixel.
 * @returns {Uint8Array} A 32bit uint8 array in RGBE
 */


function floatToRgbe(buffer, res) {
  var r,
      g,
      b,
      v,
      s,
      l = buffer.byteLength / 12 | 0,
      res = res || new Uint8Array(l * 4);

  for (var i = 0; i < l; i++) {
    r = buffer[i * 3];
    g = buffer[i * 3 + 1];
    b = buffer[i * 3 + 2];
    v = Math.max(Math.max(r, g), b);
    e = Math.ceil(Math.log2(v));
    s = Math.pow(2, e - 8);
    res[i * 4] = r / s | 0;
    res[i * 4 + 1] = g / s | 0;
    res[i * 4 + 2] = b / s | 0;
    res[i * 4 + 3] = e + 128;
  }

  return res;
}
/** Convert an RGBE buffer to a Float buffer.
 * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)
 * @param {Float32Array} [res] Optional result buffer containing 3 floats per pixel.
 * @returns {Float32Array} A floating point buffer with 96 bits per pixel (32 per channel, 3 channels).
 */


function rgbeToFloat(buffer, res) {
  var s,
      l = buffer.byteLength >> 2,
      res = res || new Float32Array(l * 3);

  for (var i = 0; i < l; i++) {
    s = Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
    res[i * 3] = buffer[i * 4] * s;
    res[i * 3 + 1] = buffer[i * 4 + 1] * s;
    res[i * 3 + 2] = buffer[i * 4 + 2] * s;
  }

  return res;
}
/** Convert an RGBE buffer to LDR with given exposure and display gamma.
 * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)
 * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)
 * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)
 * @param {Array} [res] res Optional result buffer.
 */


function rgbeToLDR(buffer, exposure, gamma, res) {
  exposure = Math.pow(2, exposure === undefined ? 1 : exposure) / 2;
  if (gamma === undefined) gamma = 2.2;
  var one_over_gamma = 1 / gamma,
      s,
      l = buffer.byteLength >> 2,
      res = res || new Uint8ClampedArray(l * 4);

  for (var i = 0; i < l; i++) {
    s = exposure * Math.pow(2, buffer[i * 4 + 3] - (128 + 8));
    res[i * 4] = 255 * Math.pow(buffer[i * 4] * s, one_over_gamma);
    res[i * 4 + 1] = 255 * Math.pow(buffer[i * 4 + 1] * s, one_over_gamma);
    res[i * 4 + 2] = 255 * Math.pow(buffer[i * 4 + 2] * s, one_over_gamma);
    res[i * 4 + 3] = 255;
  }

  return res;
}
/** Convert an float buffer to LDR with given exposure and display gamma.
 * @param {Float32Array} buffer The input buffer in floating point format.
 * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)
 * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)
 * @param {Array} [res] res Optional result buffer.
 */


function floatToLDR(buffer, exposure, gamma, res) {
  exposure = Math.pow(2, exposure === undefined ? 1 : exposure) / 2;
  if (gamma === undefined) gamma = 2.2;
  var one_over_gamma = 1 / gamma,
      s,
      l = buffer.byteLength / 12 | 0,
      res = res || new Uint8ClampedArray(l * 4);

  for (var i = 0; i < l; i++) {
    res[i * 4] = 255 * Math.pow(buffer[i * 3] * exposure, one_over_gamma);
    res[i * 4 + 1] = 255 * Math.pow(buffer[i * 3 + 1] * exposure, one_over_gamma);
    res[i * 4 + 2] = 255 * Math.pow(buffer[i * 3 + 2] * exposure, one_over_gamma);
    res[i * 4 + 3] = 255;
  }

  return res;
} // Float/RGBE conversions.


HDRImage.floatToRgbe = floatToRgbe;
HDRImage.rgbeToFloat = rgbeToFloat; // Float/RGB9_E5 conversions.

HDRImage.floatToRgb9_e5 = floatToRgb9_e5;
HDRImage.rgb9_e5ToFloat = rgb9_e5ToFloat; // x to LDR conversion.

HDRImage.rgbeToLDR = rgbeToLDR;
HDRImage.floatToLDR = floatToLDR;

var hdrpng = function hdrpng(props) {
  _classCallCheck(this, hdrpng);

  this.HDRImage = HDRImage;
};

exports["default"] = hdrpng;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
exports["default"] = void 0;

var _Scene = _interopRequireDefault(__webpack_require__(4939));

var _Bone = _interopRequireDefault(__webpack_require__(9586));

var _AnimationProcessor = _interopRequireDefault(__webpack_require__(1648));

var _AnimationAction = _interopRequireDefault(__webpack_require__(479));

var _ActionClip = _interopRequireDefault(__webpack_require__(4755));

var _SkinGeometry = _interopRequireDefault(__webpack_require__(6858));

var _Skeleton = _interopRequireDefault(__webpack_require__(1608));

var _Joint = _interopRequireDefault(__webpack_require__(8649));

var _TrackBinding = _interopRequireDefault(__webpack_require__(1245));

var _TrackMixer = _interopRequireDefault(__webpack_require__(7938));

var _AnimKeyframe = _interopRequireDefault(__webpack_require__(6458));

var _AnimKeyframeEnum = _interopRequireDefault(__webpack_require__(7868));

var _QuaternionKeyframe = _interopRequireDefault(__webpack_require__(8081));

var _Vector3Keyframe = _interopRequireDefault(__webpack_require__(6454));

var _Vector4Keyframe = _interopRequireDefault(__webpack_require__(2414));

var _Canvas = _interopRequireDefault(__webpack_require__(5109));

var _Filter = _interopRequireDefault(__webpack_require__(7120));

var _CameraIps = _interopRequireDefault(__webpack_require__(6984));

var _FirstPersonController = _interopRequireDefault(__webpack_require__(8878));

var _Input = _interopRequireDefault(__webpack_require__(4165));

var _SceneBrowsingController = _interopRequireDefault(__webpack_require__(2028));

var _DirectionalLight = _interopRequireDefault(__webpack_require__(7539));

var _GIProbe = _interopRequireDefault(__webpack_require__(2815));

var _Light = _interopRequireDefault(__webpack_require__(513));

var _PointLight = _interopRequireDefault(__webpack_require__(6807));

var _Probe = _interopRequireDefault(__webpack_require__(6967));

var _RefProbe = _interopRequireDefault(__webpack_require__(3330));

var _SpotLight = _interopRequireDefault(__webpack_require__(9098));

var _Material = _interopRequireDefault(__webpack_require__(4008));

var _MaterialDef = _interopRequireDefault(__webpack_require__(8113));

var _SubPass = _interopRequireDefault(__webpack_require__(5449));

var _SubShader = _interopRequireDefault(__webpack_require__(2603));

var _SubShaderDef = _interopRequireDefault(__webpack_require__(4974));

var _SubShaderSource = _interopRequireDefault(__webpack_require__(7057));

var _Technology = _interopRequireDefault(__webpack_require__(2768));

var _TechnologyDef = _interopRequireDefault(__webpack_require__(8173));

var _AABBBoundingBox = _interopRequireDefault(__webpack_require__(3801));

var _BoundingSphere = _interopRequireDefault(__webpack_require__(1846));

var _BoundingVolume = _interopRequireDefault(__webpack_require__(1322));

var _Matrix = _interopRequireDefault(__webpack_require__(2320));

var _MoreMath = _interopRequireDefault(__webpack_require__(431));

var _Plane = _interopRequireDefault(__webpack_require__(7088));

var _Quaternion = _interopRequireDefault(__webpack_require__(453));

var _Vector = _interopRequireDefault(__webpack_require__(9271));

var _Vector2 = _interopRequireDefault(__webpack_require__(5604));

var _Vector3 = _interopRequireDefault(__webpack_require__(7141));

var _Node = _interopRequireDefault(__webpack_require__(2949));

var _Box = _interopRequireDefault(__webpack_require__(5765));

var _GroupPlane = _interopRequireDefault(__webpack_require__(1645));

var _Sphere = _interopRequireDefault(__webpack_require__(6341));

var _SkyBox = _interopRequireDefault(__webpack_require__(9468));

var _FramePicture = _interopRequireDefault(__webpack_require__(5776));

var _Geometry = _interopRequireDefault(__webpack_require__(4720));

var _Picture = _interopRequireDefault(__webpack_require__(7280));

var _LodControl = _interopRequireDefault(__webpack_require__(2482));

var _OctCullingControl = _interopRequireDefault(__webpack_require__(9011));

var _OctNode = _interopRequireDefault(__webpack_require__(9369));

var _Base = _interopRequireDefault(__webpack_require__(512));

var _Clustered = _interopRequireDefault(__webpack_require__(6528));

var _Deferred = _interopRequireDefault(__webpack_require__(870));

var _Forward = _interopRequireDefault(__webpack_require__(5734));

var _ForwardPlus = _interopRequireDefault(__webpack_require__(9526));

var _TileDeferred = _interopRequireDefault(__webpack_require__(6987));

var _DefaultRenderProgram = _interopRequireDefault(__webpack_require__(1393));

var _MultiPassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(8388));

var _MultiPassLightingRenderProgram = _interopRequireDefault(__webpack_require__(4658));

var _SinglePassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(8546));

var _SinglePassLightingRenderProgram = _interopRequireDefault(__webpack_require__(6148));

var _TilePassIBLLightingRenderProgram = _interopRequireDefault(__webpack_require__(2987));

var _TilePassLightingRenderProgram = _interopRequireDefault(__webpack_require__(2390));

var _IDrawable = _interopRequireDefault(__webpack_require__(7664));

var _Internal = _interopRequireDefault(__webpack_require__(3370));

var _Render = _interopRequireDefault(__webpack_require__(3061));

var _RenderQueue = _interopRequireDefault(__webpack_require__(9510));

var _Camera = _interopRequireDefault(__webpack_require__(1550));

var _BasicShadowProcess = _interopRequireDefault(__webpack_require__(5602));

var _DirectionalLightShadowProcess = _interopRequireDefault(__webpack_require__(6177));

var _PointLightShadowProcess = _interopRequireDefault(__webpack_require__(4867));

var _Shadow = _interopRequireDefault(__webpack_require__(1266));

var _SplitOccluders = _interopRequireDefault(__webpack_require__(8578));

var _SpotLightShadowProcess = _interopRequireDefault(__webpack_require__(948));

var _AssetLoader = _interopRequireDefault(__webpack_require__(1193));

var _Events = _interopRequireDefault(__webpack_require__(66));

var _Log = _interopRequireDefault(__webpack_require__(3846));

var _MeshFactor = _interopRequireDefault(__webpack_require__(8583));

var _ProbeTools = _interopRequireDefault(__webpack_require__(5247));

var _Queue = _interopRequireDefault(__webpack_require__(5489));

var _TempVars = _interopRequireDefault(__webpack_require__(2475));

var _Tools = _interopRequireDefault(__webpack_require__(5397));

var _BoolVars = _interopRequireDefault(__webpack_require__(1491));

var _FloatVars = _interopRequireDefault(__webpack_require__(1759));

var _Texture2DTargetVars = _interopRequireDefault(__webpack_require__(1359));

var _Texture2DVars = _interopRequireDefault(__webpack_require__(5141));

var _TextureCubeVars = _interopRequireDefault(__webpack_require__(4048));

var _Vars = _interopRequireDefault(__webpack_require__(3552));

var _Vec2Vars = _interopRequireDefault(__webpack_require__(4690));

var _Vec4Vars = _interopRequireDefault(__webpack_require__(2462));

var _ArrayBuf = _interopRequireDefault(__webpack_require__(6693));

var _Buffer = __webpack_require__(7902);

var _FrameBuffer = _interopRequireDefault(__webpack_require__(7341));

var _FrameContext = _interopRequireDefault(__webpack_require__(6798));

var _Mesh = _interopRequireDefault(__webpack_require__(307));

var _RenderState = _interopRequireDefault(__webpack_require__(8435));

var _Shader = _interopRequireDefault(__webpack_require__(6616));

var _ShaderProgram = _interopRequireDefault(__webpack_require__(9836));

var _ShaderSource = _interopRequireDefault(__webpack_require__(9784));

var _SizeOf = _interopRequireDefault(__webpack_require__(2228));

var _Texture = _interopRequireDefault(__webpack_require__(2584));

var _UniformBuffer = _interopRequireDefault(__webpack_require__(1446));

var _UniformBufferI = _interopRequireDefault(__webpack_require__(6140));

var _Component = _interopRequireDefault(__webpack_require__(9650));

var _Globals = _interopRequireDefault(__webpack_require__(8636));

var _RenderEngine = _interopRequireDefault(__webpack_require__(1797));

var _GLTFLoader = _interopRequireDefault(__webpack_require__(4620));

var _OBJLoader = _interopRequireDefault(__webpack_require__(8236));

var _RadianceLoader = _interopRequireDefault(__webpack_require__(6797));

var _hdrpng = _interopRequireDefault(__webpack_require__(3319));

var _Grid = _interopRequireDefault(__webpack_require__(7698));

var _TextImage = _interopRequireDefault(__webpack_require__(6552));

var _Cylinder = _interopRequireDefault(__webpack_require__(4992));

var _Torus = _interopRequireDefault(__webpack_require__(8011));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  Scene: _Scene.default,
  Bone: _Bone.default,
  AnimationProcessor: _AnimationProcessor.default,
  AnimationAction: _AnimationAction.default,
  ActionClip: _ActionClip.default,
  SkinGeometry: _SkinGeometry.default,
  Skeleton: _Skeleton.default,
  Joint: _Joint.default,
  TrackBinding: _TrackBinding.default,
  TrackMixer: _TrackMixer.default,
  AnimKeyframe: _AnimKeyframe.default,
  AnimKeyframeEnum: _AnimKeyframeEnum.default,
  QuaternionKeyframe: _QuaternionKeyframe.default,
  Vector3Keyframe: _Vector3Keyframe.default,
  Vector4Keyframe: _Vector4Keyframe.default,
  Canvas: _Canvas.default,
  Filter: _Filter.default,
  CameraIps: _CameraIps.default,
  FirstPersonController: _FirstPersonController.default,
  Input: _Input.default,
  SceneBrowsingController: _SceneBrowsingController.default,
  DirectionalLight: _DirectionalLight.default,
  GIProbe: _GIProbe.default,
  Light: _Light.default,
  PointLight: _PointLight.default,
  Probe: _Probe.default,
  RefProbe: _RefProbe.default,
  SpotLight: _SpotLight.default,
  Material: _Material.default,
  MaterialDef: _MaterialDef.default,
  SubPass: _SubPass.default,
  SubShader: _SubShader.default,
  SubShaderDef: _SubShaderDef.default,
  SubShaderSource: _SubShaderSource.default,
  Technology: _Technology.default,
  TechnologyDef: _TechnologyDef.default,
  AABBBoundingBox: _AABBBoundingBox.default,
  BoundingSphere: _BoundingSphere.default,
  BoundingVolume: _BoundingVolume.default,
  Matrix44: _Matrix.default,
  MoreMath: _MoreMath.default,
  Plane: _Plane.default,
  Quaternion: _Quaternion.default,
  Vector2: _Vector.default,
  Vector3: _Vector2.default,
  Vector4: _Vector3.default,
  Box: _Box.default,
  Cylinder: _Cylinder.default,
  Torus: _Torus.default,
  GroupPlane: _GroupPlane.default,
  Grid: _Grid.default,
  Sphere: _Sphere.default,
  SkyBox: _SkyBox.default,
  FramePicture: _FramePicture.default,
  Geometry: _Geometry.default,
  Node: _Node.default,
  Picture: _Picture.default,
  LodControl: _LodControl.default,
  OctCullingControl: _OctCullingControl.default,
  OctNode: _OctNode.default,
  Base: _Base.default,
  Clustered: _Clustered.default,
  Deferred: _Deferred.default,
  Forward: _Forward.default,
  ForwardPlus: _ForwardPlus.default,
  TileDeferred: _TileDeferred.default,
  DefaultRenderProgram: _DefaultRenderProgram.default,
  MultiPassIBLLightingRenderProgram: _MultiPassIBLLightingRenderProgram.default,
  MultiPassLightingRenderProgram: _MultiPassLightingRenderProgram.default,
  SinglePassIBLLightingRenderProgram: _SinglePassIBLLightingRenderProgram.default,
  SinglePassLightingRenderProgram: _SinglePassLightingRenderProgram.default,
  TilePassIBLLightingRenderProgram: _TilePassIBLLightingRenderProgram.default,
  TilePassLightingRenderProgram: _TilePassLightingRenderProgram.default,
  IDrawable: _IDrawable.default,
  Internal: _Internal.default,
  Render: _Render.default,
  RenderQueue: _RenderQueue.default,
  Camera: _Camera.default,
  BasicShadowProcess: _BasicShadowProcess.default,
  DirectionalLightShadowProcess: _DirectionalLightShadowProcess.default,
  PointLightShadowProcess: _PointLightShadowProcess.default,
  Shadow: _Shadow.default,
  SplitOccluders: _SplitOccluders.default,
  SpotLightShadowProcess: _SpotLightShadowProcess.default,
  AssetLoader: _AssetLoader.default,
  Events: _Events.default,
  Log: _Log.default,
  MeshFactor: _MeshFactor.default,
  ProbeTools: _ProbeTools.default,
  Queue: _Queue.default,
  TempVars: _TempVars.default,
  TextImage: _TextImage.default,
  Tools: _Tools.default,
  BoolVars: _BoolVars.default,
  FloatVars: _FloatVars.default,
  Texture2DTargetVars: _Texture2DTargetVars.default,
  Texture2DVars: _Texture2DVars.default,
  TextureCubeVars: _TextureCubeVars.default,
  Vars: _Vars.default,
  Vec2Vars: _Vec2Vars.default,
  Vec4Vars: _Vec4Vars.default,
  ArrayBuf: _ArrayBuf.default,
  Buffer: _Buffer.Buffer,
  FrameBuffer: _FrameBuffer.default,
  FrameContext: _FrameContext.default,
  Mesh: _Mesh.default,
  RenderState: _RenderState.default,
  Shader: _Shader.default,
  ShaderProgram: _ShaderProgram.default,
  ShaderSource: _ShaderSource.default,
  SizeOf: _SizeOf.default,
  Texture: _Texture.default,
  UniformBuffer: _UniformBuffer.default,
  UniformBufferI: _UniformBufferI.default,
  Component: _Component.default,
  Globals: _Globals.default,
  RenderEngine: _RenderEngine.default,
  GLTFLoader: _GLTFLoader.default,
  OBJLoader: _OBJLoader.default,
  RadianceLoader: _RadianceLoader.default,
  hdrpng: _hdrpng.default
};
exports["default"] = _default;
})();

__webpack_exports__ = __webpack_exports__["default"];
/******/ 	return __webpack_exports__;
/******/ })()
;
});