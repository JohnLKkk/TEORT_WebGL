#version 300 es
#define backfaceShadows backfaceShadows
#define _C_PSSM _C_PSSM

precision mediump float;

uniform vec2 _ResolutionInverse;
uniform sampler2D _gDepth;
uniform sampler2D _inDepthMap;
out vec4 _outColor;
uniform sampler2D _inScreenMap;
uniform vec3 _lightDir;
uniform vec3 _lightPos;
uniform mat4 _lightViewProjectMatrix0;
uniform mat4 _lightViewProjectMatrix1;
uniform mat4 _lightViewProjectMatrix2;
uniform mat4 _lightViewProjectMatrix3;
uniform mat4 _lightViewProjectMatrix4;
uniform mat4 _lightViewProjectMatrix5;
uniform sampler2D _shadowMap0;
uniform sampler2D _shadowMap1;
uniform sampler2D _shadowMap2;
uniform sampler2D _shadowMap3;
uniform vec4 _splits;

in mat4 pvInverse;
in vec2 wUv0;
in vec4 pvRow2;

uniform bool backfaceShadows;
uniform float shadowIntensity;
float shadowBorderScale = 1.0f;
#ifdef HARDWARE_SHADOWS
#define SHADOWMAP sampler2DShadow
#define SHADOWCOMPAREOFFSET(tex,coord,offset) textureProjOffset(tex, coord, offset)
#define SHADOWCOMPARE(tex,coord) textureProj(tex, coord)
#define SHADOWGATHER(tex,coord) textureGather(tex, coord.xy, coord.z)
#else
#define SHADOWMAP sampler2D
#define SHADOWCOMPAREOFFSET(tex,coord,offset) step(coord.z, textureProjOffset(tex, coord, offset).r)
#define SHADOWCOMPARE(tex,coord) step(coord.z, textureProj(tex, coord).r)
#define SHADOWGATHER(tex,coord) step(coord.z, textureGather(tex, coord.xy))
#endif

float Shadow_DoShadowCompare(in SHADOWMAP tex,in vec4 projCoord){
return SHADOWCOMPARE(tex, projCoord);
}

float Shadow_BorderCheck(in vec2 coord){
vec4 t = vec4(coord.xy, 0.0f, 1.0f);
t = step(t.wwxy, t.xyzz);
return dot(t,t);
}

float Shadow_Nearest(in SHADOWMAP tex,in vec4 projCoord){
float border = Shadow_BorderCheck(projCoord.xy);
if (border > 0.0f){
return 1.0f;
}
return SHADOWCOMPARE(tex, projCoord);
}
vec3 getPosition(in float depth, in vec2 newTexCoord){

vec4 pos;
pos.xy = (newTexCoord * vec2(2.0f)) - vec2(1.0f);
pos.z  = depth * 2.0f - 1.0f;
pos.w  = 1.0f;
pos    = pvInverse * pos;
pos.xyz /= pos.w;
return pos.xyz;
}
#define GETSHADOW Shadow_Nearest
float getDirectionalLightShadows(in vec4 splits,in float shadowPosition, in SHADOWMAP shadowMap0, in SHADOWMAP shadowMap1, in SHADOWMAP shadowMap2,in SHADOWMAP shadowMap3, in vec4 projCoord0,in vec4 projCoord1,in vec4 projCoord2,in vec4 projCoord3){
float shadow = 1.0f;
if(shadowPosition < splits.x){
shadow = GETSHADOW(shadowMap0, projCoord0 );
}
else if( shadowPosition <  splits.y){
shadowBorderScale = 0.5f;
shadow = GETSHADOW(shadowMap1, projCoord1);
}
else if( shadowPosition <  splits.z){
shadowBorderScale = 0.25f;
shadow = GETSHADOW(shadowMap2, projCoord2);
}
else if( shadowPosition <  splits.w){
shadowBorderScale = 0.125f;
shadow = GETSHADOW(shadowMap3, projCoord3);
}
return shadow;
}
vec3 approximateNormal(in vec4 worldPos,in vec2 texCoord){
float step = _ResolutionInverse.x;
float stepy = _ResolutionInverse.y;
float depth2 = texture(_gDepth, texCoord + vec2(step, -stepy)).r;
float depth3 = texture(_gDepth, texCoord + vec2(-step, -stepy)).r;
vec4 worldPos2 = vec4(getPosition(depth2, texCoord + vec2(step, -stepy)),1.0f);
vec4 worldPos3 = vec4(getPosition(depth3, texCoord + vec2(-step, -stepy)),1.0f);

vec3 v1 = (worldPos - worldPos2).xyz;
vec3 v2 = (worldPos3 - worldPos2).xyz;
return normalize(cross(v1, v2));
}
const mat4 biasMat = mat4(0.5f, 0.0f, 0.0f, 0.0f,
0.0f, 0.5f, 0.0f, 0.0f,
0.0f, 0.0f, 0.5f, 0.0f,
0.5f, 0.5f, 0.5f, 1.0f);
void main(){
float depth = texture(_inDepthMap, wUv0).r;
_outColor = texture(_inScreenMap, wUv0);

if(depth >= 1.0f){
return;
}

vec4 wPosition = vec4(getPosition(depth, wUv0), 1.0f);

vec3 lightDir;
#ifdef PSSM
lightDir = _lightDir;
#else
lightDir = wPosition.xyz - _lightPos;
#endif

#ifndef backfaceShadows
if(backfaceShadows){
vec3 normal = approximateNormal(wPosition, wUv0);
float ndotl = dot(normal, lightDir);
if(ndotl > -0.0f){
return;
}
}
#endif

#if (!defined(POINTLIGHT) && !defined(PSSM))
if( dot(_lightDir, lightDir) < 0.0f){
return;
}
#endif

vec4 projCoord0 = biasMat * _lightViewProjectMatrix0 * wPosition;
vec4 projCoord1 = biasMat * _lightViewProjectMatrix1 * wPosition;
vec4 projCoord2 = biasMat * _lightViewProjectMatrix2 * wPosition;
vec4 projCoord3 = biasMat * _lightViewProjectMatrix3 * wPosition;
#ifdef POINTLIGHT
vec4 projCoord4 = biasMat * _lightViewProjectMatrix4 * wPosition;
vec4 projCoord5 = biasMat * _lightViewProjectMatrix5 * wPosition;
#endif

float shadow = 1.0f;

#if defined(_C_PSSM)
float shadowPosition = pvRow2.x * worldPos.x +  pvRow2.y * worldPos.y +  pvRow2.z * worldPos.z +  pvRow2.w;
#else
#if defined(_C_FADE)
float shadowPosition = pvRow2.x * worldPos.x +  pvRow2.y * worldPos.y +  pvRow2.z * worldPos.z +  pvRow2.w;
#endif
#endif

#ifdef _C_POINTLIGHT_SHADOWS
#else
#ifdef _C_PSSM
shadow = getDirectionalLightShadows(_splits, shadowPosition, _shadowMap0, _shadowMap1, _shadowMap2, _shadowMap3, projCoord0, projCoord1, projCoord2, projCoord3);
#else
#endif
#endif

#ifdef _C_FADE
shadow = clamp(max(0.0f, mix(shadow, 1.0f,(shadowPosition - _C_FADEInfo.x) * _C_FADEInfo.y)), 0.0f, 1.0f);
#endif
#ifdef shadowIntensity
shadow = shadow * shadowIntensity + (1.0f - shadowIntensity);
#else
shadow = shadow * 0.5f + 0.5f;
#endif
_outColor = _outColor * vec4(shadow, shadow, shadow, 1.0f);
}
