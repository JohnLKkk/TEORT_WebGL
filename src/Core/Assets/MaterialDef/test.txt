#version 300 es
precision mediump float;

uniform sampler2D _gDepth;
out vec4 _outColor;
uniform sampler2D _gBuffer0;
uniform sampler2D _gBuffer2;
uniform sampler2D _gBuffer1;
uniform sampler2D _tileLightDecode;
uniform float _tileLightOffsetSize;
uniform int _lightNum;
uniform sampler2D _tileLightIndex;
uniform sampler2D _tileWLightData0;
uniform sampler2D _tileWLightData1;
uniform sampler2D _tileWLightData2;
layout (std140) uniform VIEW
{
vec3 _cameraPosition;
};

in mat4 pvInverse;
in vec2 uv0;
vec3 getPosition(in float depth, in vec2 newTexCoord){

vec4 pos;
pos.xy = (newTexCoord * vec2(2.0)) - vec2(1.0);
pos.z  = depth * 2.0 - 1.0;
pos.w  = 1.0;
pos    = pvInverse * pos;
pos.xyz /= pos.w;
return pos.xyz;
}
void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){
float posLight = step(0.5f, lightType);

lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);
float dist = length(lightVec);

lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);


lightDir.xyz = lightVec / vec3(dist);
}
void ComputeLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in float attenuation, in float shininess, out vec2 brdf){
float diffuseBRDF = max(0.0f, dot(normal, lightDir));
vec3 H = normalize(viewDir + lightDir);
float HdotN = max(0.0f, dot(H, normal));
float specularBRDF = pow( HdotN, shininess );

brdf.x = diffuseBRDF * attenuation;
brdf.y = specularBRDF * attenuation;
}
float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){
float curAngleCos = dot(lightDir, -spotDirection.xyz);
float innerAngleCos = floor(spotDirection.w) * 0.001f;
float outerAngleCos = fract(spotDirection.w);
float innerMinusOuter = innerAngleCos - outerAngleCos;
float falloff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f);

#ifdef SRGB
return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0), 4.0);
#else
return falloff;
#endif
}
void main(){
float depth = texture(_gDepth, uv0).r;
if(depth >= 1.0){
_outColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
return;
}
vec3 wPosition = getPosition(depth, uv0);
vec4 _diffuseColor = texture(_gBuffer0, uv0);
vec4 _specularColorDecode = texture(_gBuffer2, uv0);
vec3 _specularColor = floor(_specularColorDecode.rgb) * 0.1f;
vec3 _ambientColor = min(fract(_specularColorDecode.rgb) * 10.0f, vec3(1.0f));
float _shininess = floor(_diffuseColor.w);
float alpha     = min(fract(_diffuseColor.w) * 10.0f, 1.0f);
vec3 normal = texture(_gBuffer1, uv0).xyz;
vec4 lightColor;
vec4 lightData1;
vec4 lightDir = vec4(0.0f);
vec3 lightVec = vec3(0.0f);
vec2 lightBRDF = vec2(0.0f);
vec3 viewDir = normalize(_cameraPosition.xyz - wPosition.xyz);

_outColor.rgb = vec3(0.0f);
vec3 tile = texture(_tileLightDecode, uv0).xyz;
int uoffset = int(tile.x);
int voffset = int(tile.z);
int count = int(tile.y);
if(count > 0){
int lightId;
float temp;
int offset;
float uvSize = 1.0f / (_tileLightOffsetSize - 1.0f);
vec2 lightUV;
float lightUVSize = 1.0f / (float(_lightNum) - 1.0f);
float lightUVFloat = 0.0f;
for(int i = 0;i < count;i++){
temp = float(uoffset + i);
offset = 0;

if(temp >= _tileLightOffsetSize){
temp -= _tileLightOffsetSize;
offset++;
}
if(temp == _tileLightOffsetSize){
temp = 0.0f;
}

lightUV = vec2(temp * uvSize, float(voffset + offset) * uvSize);
lightId = int(texture(_tileLightIndex, lightUV).x);

lightUVFloat = float(lightId) * lightUVSize;
lightColor = texture(_tileWLightData0, vec2(lightUVFloat));
lightData1 = texture(_tileWLightData1, vec2(lightUVFloat));

ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);


float spotFallOff = 1.0;
if( lightColor.w > 1.0f )
{
spotFallOff = ComputeSpotFalloff( texture(_tileWLightData2, vec2(lightId * lightUVSize)), lightDir.xyz );
}


ComputeLighting(normal, viewDir, lightDir.xyz, lightDir.w * spotFallOff, _shininess, lightBRDF);

_outColor.rgb += lightColor.rgb * ( _diffuseColor.rgb * vec3( lightBRDF.x ) + _specularColor.rgb * vec3( lightBRDF.y ));
}
}
_outColor.a = alpha;
}
