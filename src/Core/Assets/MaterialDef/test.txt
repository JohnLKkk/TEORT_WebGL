"#version 300 es\n#define pcfEdge pcfEdge\n#define shadowIntensity shadowIntensity\n#define backfaceShadows backfaceShadows\n#define _C_PSSM _C_PSSM\n\nprecision mediump float;\n\nuniform vec2 _sMapSizeInverse;\nuniform float _shadowMapSize;\nuniform sampler2D _inDepthMap;\nout vec4 _outColor;\nuniform sampler2D _inScreenMap;\nuniform vec3 _lightDir;\nuniform vec3 _lightPos;\nuniform vec2 _ResolutionInverse;\nuniform mat4 _lightViewProjectMatrix0;\nuniform mat4 _lightViewProjectMatrix1;\nuniform mat4 _lightViewProjectMatrix2;\nuniform mat4 _lightViewProjectMatrix3;\nuniform mat4 _lightViewProjectMatrix4;\nuniform mat4 _lightViewProjectMatrix5;\nuniform sampler2D _shadowMap0;\nuniform sampler2D _shadowMap1;\nuniform sampler2D _shadowMap2;\nuniform sampler2D _shadowMap3;\nuniform vec4 _splits;\n\nin mat4 pvInverse;\nin vec2 wUv0;\nin vec4 pvRow2;\n\nuniform float pcfEdge;\nuniform bool backfaceShadows;\nuniform vec2 fadeInfo;\nuniform float shadowIntensity;\nfloat shadowBorderScale = 1.0f;\n#ifdef HARDWARE_SHADOWS\n#define SHADOWMAP sampler2DShadow\n#define SHADOWCOMPAREOFFSET(tex,coord,offset) textureProjOffset(tex, coord, offset)\n#define SHADOWCOMPARE(tex,coord) textureProj(tex, coord)\n#define SHADOWGATHER(tex,coord) textureGather(tex, coord.xy, coord.z)\n#else\n#define SHADOWMAP sampler2D\n#define SHADOWCOMPAREOFFSET(tex,coord,offset) step(coord.z, textureProjOffset(tex, coord, offset).r)\n#define SHADOWCOMPARE(tex,coord) step(coord.z, textureProj(tex, coord).r)\n#define SHADOWGATHER(tex,coord) step(coord.z, textureGather(tex, coord.xy))\n#endif\n\n#define FILTER_MODE 1\n\n#if FILTER_MODE == 10\n#define GETSHADOW Shadow_Nearest\n#define KERNEL 1.0\n#elif FILTER_MODE == 1\n#ifdef HARDWARE_SHADOWS\n#define GETSHADOW Shadow_Nearest\n#else\n#define GETSHADOW Shadow_DoBilinear_2x2\n#endif\n#define KERNEL 1.0\n#endif\n\n#if (FILTER_MODE == 2)\n#define GETSHADOW Shadow_DoDither_2x2\n#define KERNEL 1.0\n#elif FILTER_MODE == 3\n#define GETSHADOW Shadow_DoPCF\n#define KERNEL 4.0\n#elif FILTER_MODE == 4\n#define GETSHADOW Shadow_DoPCFPoisson\n#define KERNEL 4.0\n#elif FILTER_MODE == 5\n#define GETSHADOW Shadow_DoPCF\n#define KERNEL 8.0\n#endif\n\nfloat Shadow_DoShadowCompare(in SHADOWMAP tex,in vec4 projCoord){\nreturn SHADOWCOMPARE(tex, projCoord);\n}\n\nfloat Shadow_BorderCheck(in vec2 coord){\nvec4 t = vec4(coord.xy, 0.0f, 1.0f);\nt = step(t.wwxy, t.xyzz);\nreturn dot(t,t);\n}\n\nfloat Shadow_Nearest(in SHADOWMAP tex,in vec4 projCoord){\nfloat border = Shadow_BorderCheck(projCoord.xy);\nif (border > 0.0f){\nreturn 1.0f;\n}\nreturn SHADOWCOMPARE(tex, projCoord);\n}\n\nfloat Shadow_DoShadowCompareOffset(in SHADOWMAP tex,in vec4 projCoord,in vec2 offset){\nvec4 coord = vec4(projCoord.xy + offset.xy * _sMapSizeInverse * shadowBorderScale, projCoord.zw);\nreturn SHADOWCOMPARE(tex, coord);\n}\n\n\nfloat Shadow_DoDither_2x2(in SHADOWMAP tex, in vec4 projCoord){\nfloat border = Shadow_BorderCheck(projCoord.xy);\nif (border > 0.0f)\nreturn 1.0f;\n\nfloat shadow = 0.0f;\nvec2 o = vec2(ivec2(mod(floor(gl_FragCoord.xy), 2.0f))); //Strict type checking in GLSL ES\nshadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2(-1.5f, 1.5f)+o));\nshadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2( 0.5f, 1.5f)+o));\nshadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2(-1.5f, -0.5f)+o));\nshadow += Shadow_DoShadowCompareOffset(tex, projCoord, (vec2( 0.5f, -0.5f)+o));\nshadow *= 0.25f;\nreturn shadow;\n}\n\nfloat Shadow_DoBilinear_2x2(in SHADOWMAP tex, in vec4 projCoord){\nfloat border = Shadow_BorderCheck(projCoord.xy);\nif (border > 0.0f){\nreturn 1.0f;\n}\n\nvec4 gather = vec4(0.0f);\n#if defined GL_ARB_gpu_shader5 || defined GL_OES_gpu_shader5\nvec4 coord = vec4(projCoord.xyz / projCoord.www, 0.0f);\ngather = SHADOWGATHER(tex, coord);\n#else\ngather.x = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(0, 1));\ngather.y = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(1, 1));\ngather.z = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(1, 0));\ngather.w = SHADOWCOMPAREOFFSET(tex, projCoord, ivec2(0, 0));\n#endif\n\nvec2 f = fract( projCoord.xy * _shadowMapSize );\nvec2 mx = mix( gather.wx, gather.zy, f.x );\nreturn mix( mx.x, mx.y, f.y );\n}\n\nfloat Shadow_DoPCF(in SHADOWMAP tex,in vec4 projCoord){\n\nfloat shadow = 0.0f;\nfloat border = Shadow_BorderCheck(projCoord.xy);\nif (border > 0.0f)\nreturn 1.0f;\n\nfloat bound = KERNEL * 0.5f - 0.5f;\nbound *= pcfEdge;\nfor (float y = -bound; y <= bound; y += pcfEdge){\nfor (float x = -bound; x <= bound; x += pcfEdge){\nshadow += Shadow_DoShadowCompareOffset(tex, projCoord, vec2(x,y));\n}\n}\n\nshadow = shadow / (KERNEL * KERNEL);\nreturn shadow;\n}\n\nconst vec2 poissonDisk0 =  vec2(-0.1711046f, -0.425016f);\nconst vec2 poissonDisk1 =  vec2(-0.7829809f, 0.2162201f);\nconst vec2 poissonDisk2 =  vec2(-0.2380269f, -0.8835521f);\nconst vec2 poissonDisk3 =  vec2(0.4198045f, 0.1687819f);\nconst vec2 poissonDisk4 =  vec2(-0.684418f, -0.3186957f);\nconst vec2 poissonDisk5 =  vec2(0.6026866f, -0.2587841f);\nconst vec2 poissonDisk6 =  vec2(-0.2412762f, 0.3913516f);\nconst vec2 poissonDisk7 =  vec2(0.4720655f, -0.7664126f);\nconst vec2 poissonDisk8 =  vec2(0.9571564f, 0.2680693f);\nconst vec2 poissonDisk9 =  vec2(-0.5238616f, 0.802707f);\nconst vec2 poissonDisk10 = vec2(0.5653144f, 0.60262f);\nconst vec2 poissonDisk11 = vec2(0.0123658f, 0.8627419f);\n\n\nfloat Shadow_DoPCFPoisson(in SHADOWMAP tex, in vec4 projCoord){\nfloat shadow = 0.0f;\nfloat border = Shadow_BorderCheck(projCoord.xy);\nif (border > 0.0f){\nreturn 1.0f;\n}\n\nvec2 texelSize = _sMapSizeInverse * 4.0f * pcfEdge * shadowBorderScale;\n\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk0 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk1 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk2 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk3 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk4 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk5 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk6 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk7 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk8 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk9 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk10 * texelSize, projCoord.zw));\nshadow += SHADOWCOMPARE(tex, vec4(projCoord.xy + poissonDisk11 * texelSize, projCoord.zw));\n\nreturn shadow * 0.08333333333f;\n}\n\n\nvec3 getPosition(in float depth, in vec2 newTexCoord){\n\nvec4 pos;\npos.xy = (newTexCoord * vec2(2.0f)) - vec2(1.0f);\npos.z  = depth * 2.0f - 1.0f;\npos.w  = 1.0f;\npos    = pvInverse * pos;\npos.xyz /= pos.w;\nreturn pos.xyz;\n}\nfloat getDirectionalLightShadows(in vec4 splits,in float shadowPosition, in SHADOWMAP shadowMap0, in SHADOWMAP shadowMap1, in SHADOWMAP shadowMap2,in SHADOWMAP shadowMap3, in vec4 projCoord0,in vec4 projCoord1,in vec4 projCoord2,in vec4 projCoord3){\nfloat shadow = 1.0f;\nif(shadowPosition < splits.x){\nshadow = GETSHADOW(shadowMap0, projCoord0 );\n}\nelse if( shadowPosition <  splits.y){\nshadowBorderScale = 0.5f;\nshadow = GETSHADOW(shadowMap1, projCoord1);\n}\nelse if( shadowPosition <  splits.z){\nshadowBorderScale = 0.25f;\nshadow = GETSHADOW(shadowMap2, projCoord2);\n}\nelse if( shadowPosition <  splits.w){\nshadowBorderScale = 0.125f;\nshadow = GETSHADOW(shadowMap3, projCoord3);\n}\nreturn shadow;\n}\nvec3 approximateNormal(in vec4 worldPos,in vec2 texCoord, in SHADOWMAP depthMap, in vec2 resolutionInverse){\nfloat step = resolutionInverse.x;\nfloat stepy = resolutionInverse.y;\nfloat depth2 = texture(depthMap, texCoord + vec2(step, -stepy)).r;\nfloat depth3 = texture(depthMap, texCoord + vec2(-step, -stepy)).r;\nvec4 worldPos2 = vec4(getPosition(depth2, texCoord + vec2(step, -stepy)),1.0f);\nvec4 worldPos3 = vec4(getPosition(depth3, texCoord + vec2(-step, -stepy)),1.0f);\n\nvec3 v1 = (worldPos - worldPos2).xyz;\nvec3 v2 = (worldPos3 - worldPos2).xyz;\nreturn normalize(cross(v1, v2));\n}\nconst mat4 biasMat = mat4(0.5f, 0.0f, 0.0f, 0.0f,\n0.0f, 0.5f, 0.0f, 0.0f,\n0.0f, 0.0f, 0.5f, 0.0f,\n0.5f, 0.5f, 0.5f, 1.0f);\nvoid main(){\nfloat depth = texture(_inDepthMap, wUv0).r;\n_outColor = texture(_inScreenMap, wUv0);\n\nif(depth >= 1.0f){\nreturn;\n}\n\nvec4 wPosition = vec4(getPosition(depth, wUv0), 1.0f);\n\nvec3 lightDir;\n#ifdef _C_PSSM\nlightDir = _lightDir;\n#else\nlightDir = wPosition.xyz - _lightPos;\n#endif\n\n#ifndef backfaceShadows\nif(!backfaceShadows){\nvec3 normal = approximateNormal(wPosition, wUv0, _inDepthMap, _ResolutionInverse);\nfloat ndotl = dot(normal, lightDir);\nif(ndotl > 0.0f){\nreturn;\n}\n}\n#endif\n\n#if !defined(_C_POINTLIGHT_SHADOWS)\n#if !defined(_C_PSSM)\nif( dot(_lightDir, lightDir) < 0.0f){\nreturn;\n}\n#endif\n#endif\n\nvec4 projCoord0 = biasMat * _lightViewProjectMatrix0 * wPosition;\nvec4 projCoord1 = biasMat * _lightViewProjectMatrix1 * wPosition;\nvec4 projCoord2 = biasMat * _lightViewProjectMatrix2 * wPosition;\nvec4 projCoord3 = biasMat * _lightViewProjectMatrix3 * wPosition;\n#ifdef POINTLIGHT\nvec4 projCoord4 = biasMat * _lightViewProjectMatrix4 * wPosition;\nvec4 projCoord5 = biasMat * _lightViewProjectMatrix5 * wPosition;\n#endif\n\nfloat shadow = 1.0f;\n\n#if defined(_C_PSSM)\nfloat shadowPosition = pvRow2.x * wPosition.x +  pvRow2.y * wPosition.y +  pvRow2.z * wPosition.z +  pvRow2.w;\n#else\n#if defined(fadeInfo)\nfloat shadowPosition = pvRow2.x * wPosition.x +  pvRow2.y * wPosition.y +  pvRow2.z * wPosition.z +  pvRow2.w;\n#endif\n#endif\n\n#ifdef _C_POINTLIGHT_SHADOWS\n#else\n#ifdef _C_PSSM\nshadow = getDirectionalLightShadows(_splits, shadowPosition, _shadowMap0, _shadowMap1, _shadowMap2, _shadowMap3, projCoord0, projCoord1, projCoord2, projCoord3);\n#else\n#endif\n#endif\n\n#ifdef fadeInfo\nshadow = clamp(max(0.0f, mix(shadow, 1.0f,(shadowPosition - fadeInfo.x) * fadeInfo.y)), 0.0f, 1.0f);\n#endif\n#ifdef shadowIntensity\nshadow = shadow * shadowIntensity + (1.0f - shadowIntensity);\n#else\nshadow = shadow * 0.7f + 0.3f;\n#endif\n_outColor = _outColor * vec4(shadow, shadow, shadow, 1.0f);\n}\n"
